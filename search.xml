<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/undefined/undefined/"/>
      <url>/undefined/undefined/</url>
      
        <content type="html"><![CDATA[<h1 id="17-如何正确地显示随机消息？"><a href="#17-如何正确地显示随机消息？" class="headerlink" title="17 | 如何正确地显示随机消息？"></a>17 | 如何正确地显示随机消息？</h1><p><font>2018-12-21 林晓斌</font></p><p><img src="../../images/mysql45/17/17.jpg"></p><p>我在上一篇文章，为你讲解完 order by 语句的几种执行模式后，就想到了之前一个做英语学习 App 的朋友碰到过的一个性能问题。今天这篇文章，我就从这个性能问题说起，和你说说 MySQL 中的另外一种排序需求，希望能够加深你对 MySQL 排序逻辑的理解。</p><p>这个英语学习 App 首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。</p><p>现在，如果让你来设计这个 SQL 语句，你会怎么写呢？</p><p>为了便于理解，我对这个例子进行了简化：去掉每个级别的用户都有一个对应的单词表这个逻辑，直接就是从一个单词表中随机选出三个单词。这个表的建表语句和初始数据的命令如下：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE `words` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `word` varchar(64) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB; delimiter ;;create procedure idata()begin  declare i int;  set i=0;  while i&lt;10000 do    insert into words(word) values(concat(char(97+(i div 1000)), char(97+(i % 1000 div 100)), char(97+(i % 100 div 10)), char(97+(i % 10))));    set i=i+1;  end while;end;;delimiter ; call idata();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了便于量化说明，我在这个表里面插入了 10000 行记录。接下来，我们就一起看看要随机选择 3 个单词，有什么方法实现，存在什么问题以及如何改进。</p><h1 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h1><p>首先，你会想到用 order by rand() 来实现这个逻辑。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select word from words order by rand() limit 3;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个语句的意思很直白，随机排序取前 3 个。虽然这个 SQL 语句写法很简单，但执行流程却有点复杂的。</p><p>我们先用 explain 命令来看看这个语句的执行情况。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>16 | “order by”是怎么工作的？</title>
      <link href="/mysql45/16/"/>
      <url>/mysql45/16/</url>
      
        <content type="html"><![CDATA[<h1 id="16-“order-by”是怎么工作的？"><a href="#16-“order-by”是怎么工作的？" class="headerlink" title="16 | “order by”是怎么工作的？"></a>16 | “order by”是怎么工作的？</h1><p><font color="gray">2018-12-19 林晓斌</font></p><p><img src="../../images/mysql45/16/16.jpg"></p><p>在你开发应用的时候，一定会经常碰到需要根据指定的字段排序来显示结果的需求。还是以我们前面举例用过的市民表为例，假设你要查询城市是“杭州”的所有人名字，并且按照姓名排序返回前 1000 个人的姓名、年龄。</p><p>假设这个表的部分定义是这样的：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE `t` (  `id` int(11) NOT NULL,  `city` varchar(16) NOT NULL,  `name` varchar(16) NOT NULL,  `age` int(11) NOT NULL,  `addr` varchar(128) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `city` (`city`)) ENGINE=InnoDB;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时，你的 SQL 语句可以这么写：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select city,name,age from t where city='杭州' order by name limit 1000  ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个语句看上去逻辑很清晰，但是你了解它的执行流程吗？今天，我就和你聊聊这个语句是怎么执行的，以及有什么参数会影响执行的行为。</p><h1 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h1><p>前面我们介绍过索引，所以你现在就很清楚了，为避免全表扫描，我们需要在 city 字段加上索引。</p><p>在 city 字段上创建索引之后，我们用 explain 命令来看看这个语句的执行情况。</p><div style="text-align:center"><img src="../../images/mysql45/16/图%201%20使用%20explain%20命令查看语句的执行情况.png"><p><font color="gray">图 1 使用 explain 命令查看语句的执行情况</font></p></div><p>Extra 这个字段中的“Using filesort”表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。</p><p>为了说明这个 SQL 查询语句的执行过程，我们先来看一下 city 这个索引的示意图。</p><div style="text-align:center"><img src="../../images/mysql45/16/图%202%20city%20字段的索引示意图.png"><p><font color="gray">图 2 city 字段的索引示意图</font></p></div><p>从图中可以看到，满足 city=’杭州’条件的行，是从 ID_X 到 ID_(X+N) 的这些记录。</p><p>通常情况下，这个语句执行流程如下所示 ：</p><ol><li>初始化 sort_buffer，确定放入 name、city、age 这三个字段；</li><li>从索引 city 找到第一个满足 city=’杭州’条件的主键 id，也就是图中的 ID_X；</li><li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；</li><li>对 sort_buffer 中的数据按照字段 name 做快速排序；</li><li>按照排序结果取前 1000 行返回给客户端。</li></ol><p>我们暂且把这个排序过程，称为全字段排序，执行流程的示意图如下所示，下一篇文章中我们还会用到这个排序。</p><div style="text-align:center"><img src="../../images/mysql45/16/图%203%20全字段排序.jpg"><p><font color="gray">图 3 全字段排序</font></p></div><p>图中“按 name 排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 <code>sort_buffer_size</code>。</p><p>sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p><p>你可以用下面介绍的方法，来确定一个排序语句是否使用了临时文件。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">/* 打开 optimizer_trace，只对本线程有效 */SET optimizer_trace='enabled=on';  /* @a 保存 Innodb_rows_read 的初始值 */select VARIABLE_VALUE into @a from  performance_schema.session_status where variable_name = 'Innodb_rows_read'; /* 执行语句 */select city, name,age from t where city='杭州' order by name limit 1000;  /* 查看 OPTIMIZER_TRACE 输出 */SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\G /* @b 保存 Innodb_rows_read 的当前值 */select VARIABLE_VALUE into @b from performance_schema.session_status where variable_name = 'Innodb_rows_read'; /* 计算 Innodb_rows_read 差值 */select @b-@a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，你可以从 <code>number_of_tmp_files</code> 中看到是否使用了临时文件。</p><div style="text-align:center"><img src="../../images/mysql45/16/图%204%20全排序的%20OPTIMIZER_TRACE%20部分结果.png"><p><font color="gray">图 4 全排序的 OPTIMIZER_TRACE 部分结果</font></p></div><p>number_of_tmp_files 表示的是，排序过程中使用的临时文件数。你一定奇怪，为什么需要 12 个文件？内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。可以这么简单理解，<strong>MySQL 将需要排序的数据分成 12 份，每一份单独排序后存在这些临时文件中。然后把这 12 个有序文件再合并成一个有序的大文件。</strong></p><p>如果 sort_buffer_size 超过了需要排序的数据量的大小，number_of_tmp_files 就是 0，表示排序可以直接在内存中完成。</p><p>否则就需要放在临时文件中排序。sort_buffer_size 越小，需要分成的份数越多，number_of_tmp_files 的值就越大。</p><p>接下来，我再和你解释一下图 4 中其他两个值的意思。</p><p>我们的示例表中有 4000 条满足 city=’杭州’的记录，所以你可以看到 examined_rows=4000，表示参与排序的行数是 4000 行。</p><p>sort_mode 里面的 packed_additional_fields 的意思是，排序过程对字符串做了“紧凑”处理。即使 name 字段的定义是 varchar(16)，在排序过程中还是要按照实际长度来分配空间的。</p><p>同时，最后一个查询语句 select @b-@a 的返回结果是 4000，表示整个执行过程只扫描了 4000 行。</p><p>这里需要注意的是，为了避免对结论造成干扰，我把 internal_tmp_disk_storage_engine 设置成 MyISAM。否则，select @b-@a 的结果会显示为 4001。</p><p>这是因为查询 OPTIMIZER_TRACE 这个表时，需要用到临时表，而 internal_tmp_disk_storage_engine 的默认值是 InnoDB。如果使用的是 InnoDB 引擎的话，把数据从临时表取出来的时候，会让 Innodb_rows_read 的值加 1。</p><h1 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h1><p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在 sort_buffer 和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p><p>所以如果单行很大，这个方法效率不够好。</p><p>那么，<strong>如果 MySQL 认为排序的单行长度太大会怎么做呢？</strong></p><p>接下来，我来修改一个参数，让 MySQL 采用另外一种算法。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SET max_length_for_sort_data = 16;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>max_length_for_sort_data</code>，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</p><p>city、name、age 这三个字段的定义总长度是 36，我把 max_length_for_sort_data 设置为 16，我们再来看看计算过程有什么改变。</p><p>新的算法放入 sort_buffer 的字段，只有要排序的列（即 name 字段）和主键 id。</p><p>但这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：</p><ol><li>初始化 sort_buffer，确定放入两个字段，即 name 和 id；</li><li>从索引 city 找到第一个满足 city=’杭州’条件的主键 id，也就是图中的 ID_X；</li><li>到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到不满足 city=’杭州’条件为止，也就是图中的 ID_Y；</li><li>对 sort_buffer 中的数据按照字段 name 进行排序；</li><li>遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</li></ol><p>这个执行流程的示意图如下，我把它称为 rowid 排序。</p><div style="text-align:center"><img src="../../images/mysql45/16/图 5 rowid 排序.jpg"><p><font color="gray">图 5 rowid 排序</font></p></div><p>对比图 3 的全字段排序流程图你会发现，rowid 排序多访问了一次表 t 的主键索引，就是步骤 7。</p><p>需要说明的是，最后的“结果集”是一个逻辑概念，实际上 MySQL 服务端从排序后的 sort_buffer 中依次取出 id，然后到原表查到 city、name 和 age 这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。</p><p>根据这个说明过程和图示，你可以想一下，这个时候执行 select @b-@a，结果会是多少呢？</p><p>现在，我们就来看看结果有什么不同。</p><p>首先，图中的 examined_rows 的值还是 4000，表示用于排序的数据是 4000 行。但是 select @b-@a 这个语句的值变成 5000 了。</p><p>因为这时候除了排序过程外，在排序完成后，还要根据 id 去原表取值。由于语句是 limit 1000，因此会多读 1000 行。</p><div style="text-align:center"><img src="../../images/mysql45/16/图%206%20rowid%20排序的%20OPTIMIZER_TRACE%20部分输出.png"><p><font color="gray">图 6 rowid 排序的 OPTIMIZER_TRACE 部分输出</font></p></div><p>从 OPTIMIZER_TRACE 的结果中，你还能看到另外两个信息也变了。</p><ul><li>sort_mode 变成了 &lt;sort_key, rowid&gt;，表示参与排序的只有 name 和 id 这两个字段。</li><li>number_of_tmp_files 变成 10 了，是因为这时候参与排序的行数虽然仍然是 4000 行，但是每一行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了。</li></ul><h1 id="全字段排序-VS-rowid-排序"><a href="#全字段排序-VS-rowid-排序" class="headerlink" title="全字段排序 VS rowid 排序"></a>全字段排序 VS rowid 排序</h1><p>我们来分析一下，从这两个执行流程里，还能得出什么结论。</p><p>如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p><p>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p><p>这也就体现了 MySQL 的一个设计思想：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p><p>对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</p><p>这个结论看上去有点废话的感觉，但是你要记住它，下一篇文章我们就会用到。</p><p>看到这里，你就了解了，MySQL 做排序是一个成本比较高的操作。那么你会问，是不是所有的 order by 都需要排序操作呢？如果不排序就能得到正确的结果，那对系统的消耗会小很多，语句的执行时间也会变得更短。</p><p>其实，并不是所有的 order by 语句，都需要排序操作的。从上面分析的执行过程，我们可以看到，MySQL 之所以需要生成临时表，并且在临时表上做排序操作，<strong>其原因是原来的数据都是无序的。</strong></p><p>你可以设想下，如果能够保证从 city 这个索引上取出来的行，天然就是按照 name 递增排序的话，是不是就可以不用再排序了呢？</p><p>确实是这样的。</p><p>所以，我们可以在这个市民表上创建一个 city 和 name 的联合索引，对应的 SQL 语句是：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">alter table t add index city_user(city, name);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>作为与 city 索引的对比，我们来看看这个索引的示意图。</p><div style="text-align:center"><img src="../../images/mysql45/16/图%207%20city%20和%20name%20联合索引示意图.png"><p><font color="gray">图 7 city 和 name 联合索引示意图</font></p></div><p>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足 city=’杭州’的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要 city 的值是杭州，name 的值就一定是有序的。</p><p>这样整个查询过程的流程就变成了：</p><ol><li>从索引 (city,name) 找到第一个满足 city=’杭州’条件的主键 id；</li><li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回；</li><li>从索引 (city,name) 取下一个记录主键 id；</li><li>重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’杭州’条件时循环结束。</li></ol><div style="text-align:center"><img src="../../images/mysql45/16/图%208%20引入%20(city,name)%20联合索引后，查询语句的执行计划.jpg"><p><font color="gray">图 8 引入 (city,name) 联合索引后，查询语句的执行计划</font></p></div><p>可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用 explain 的结果来印证一下。</p><div style="text-align:center"><img src="../../images/mysql45/16/图%209%20引入%20(city,name)%20联合索引后，查询语句的执行计划.png"><p><font color="gray">图 9 引入 (city,name) 联合索引后，查询语句的执行计划</font></p></div><p>从图中可以看到，Extra 字段中没有 Using filesort 了，也就是不需要排序了。而且由于 (city,name) 这个联合索引本身有序，所以这个查询也不用把 4000 行全都读一遍，只要找到满足条件的前 1000 条记录就可以退出了。也就是说，在我们这个例子里，只需要扫描 1000 次。</p><p>既然说到这里了，我们再往前讨论，<strong>这个语句的执行流程有没有可能进一步简化呢？</strong>不知道你还记不记得，我在第 5 篇文章<a href="../5">《 深入浅出索引（下）》</a>中，和你介绍的覆盖索引。</p><p>这里我们可以再稍微复习一下。<strong>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据。</strong></p><p>按照覆盖索引的概念，我们可以再优化一下这个查询语句的执行流程。</p><p>针对这个查询，我们可以创建一个 city、name 和 age 的联合索引，对应的 SQL 语句就是：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">alter table t add index city_user_age(city, name, age);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时，对于 city 字段的值相同的行来说，还是按照 name 字段的值递增排序的，此时的查询语句也就不再需要排序了。这样整个查询语句的执行流程就变成了：</p><ol><li>从索引 (city,name,age) 找到第一个满足 city=’杭州’条件的记录，取出其中的 city、name 和 age 这三个字段的值，作为结果集的一部分直接返回；</li><li>从索引 (city,name,age) 取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；</li><li>重复执行步骤 2，直到查到第 1000 条记录，或者是不满足 city=’杭州’条件时循环结束。</li></ol><div style="text-align:center"><img src="../../images/mysql45/16/图%2010%20引入%20(city,name,age)%20联合索引后，查询语句的执行流程.jpg"><p><font color="gray">图 10 引入 (city,name,age) 联合索引后，查询语句的执行流程</font></p></div><p>然后，我们再来看看 explain 的结果。</p><div style="text-align:center"><img src="../../images/mysql45/16/图%2011%20引入%20(city,name,age)%20联合索引后，查询语句的执行计划.png"><p><font color="gray">图 11 引入 (city,name,age) 联合索引后，查询语句的执行计划</font></p></div><p>可以看到，Extra 字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多。</p><p>当然，这里并不是说要为了每个查询能用上覆盖索引，就要把语句中涉及的字段都建上联合索引，毕竟索引还是有维护代价的。这是一个需要权衡的决定。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我和你介绍了 MySQL 里面 order by 语句的几种算法流程。</p><p>在开发系统的时候，你总是不可避免地会使用到 order by 语句。你心里要清楚每个语句的排序逻辑是怎么实现的，还要能够分析出在最坏情况下，每个语句的执行对系统资源的消耗，这样才能做到下笔如有神，不犯低级错误。</p><p>最后，我给你留下一个思考题吧。</p><p>假设你的表里面已经有了 city_name(city, name) 这个联合索引，然后你要查杭州和苏州两个城市中所有的市民的姓名，并且按名字排序，显示前 100 条记录。如果 SQL 查询语句是这么写的 ：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from t where city in ('杭州'," 苏州 ") order by name limit 100;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么，这个语句执行的时候会有排序过程吗，为什么？</p><p>如果业务端代码由你来开发，需要实现一个在数据库端不需要排序的方案，你会怎么实现呢？</p><p>进一步地，如果有分页需求，要显示第 101 页，也就是说语句最后要改成 “limit 10000,100”， 你的实现方法又会是什么呢？</p><p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是，当 MySQL 去更新一行，但是要修改的值跟原来的值是相同的，这时候 MySQL 会真的去执行一次修改吗？还是看到值相同就直接返回呢？</p><p>这是第一次我们课后问题的三个选项都有同学选的，所以我要和你需要详细说明一下。</p><p>第一个选项是，MySQL 读出数据，发现值与原来相同，不更新，直接返回，执行结束。这里我们可以用一个锁实验来确认。</p><p>假设，当前表 t 里的值是 (1,2)。</p><div style="text-align:center"><img src="../../images/mysql45/16/图%2012%20锁验证方式.png"><p><font color="gray">图 12 锁验证方式</font></p></div><p>session B 的 update 语句被 blocked 了，加锁这个动作是 InnoDB 才能做的，所以排除选项 1。</p><p>第二个选项是，MySQL 调用了 InnoDB 引擎提供的接口，但是引擎发现值与原来相同，不更新，直接返回。有没有这种可能呢？这里我用一个可见性实验来确认。</p><p>假设当前表里的值是 (1,2)。</p><div style="text-align:center"><img src="../../images/mysql45/16/图%2013%20可见性验证方式.png"><p><font color="gray">图 13 可见性验证方式</font></p></div><p>session A 的第二个 select 语句是一致性读（快照读)，它是不能看见 session B 的更新的。</p><p>现在它返回的是 (1,3)，表示它看见了某个新的版本，这个版本只能是 session A 自己的 update 语句做更新的时候生成。（如果你对这个逻辑有疑惑的话，可以回顾下第 8 篇文章<a href="../8">《事务到底是隔离的还是不隔离的？》</a>中的相关内容）</p><p>所以，我们上期思考题的答案应该是选项 3，即：InnoDB 认真执行了“把这个值修改成 (1,2)”这个操作，该加锁的加锁，该更新的更新。</p><p>然后你会说，MySQL 怎么这么笨，就不会更新前判断一下值是不是相同吗？如果判断一下，不就不用浪费 InnoDB 操作，多去更新一次了？</p><p>其实 MySQL 是确认了的。只是在这个语句里面，MySQL 认为读出来的值，只有一个确定的 (id=1), 而要写的是 (a=3)，只从这两个信息是看不出来“不需要修改”的。</p><p>作为验证，你可以看一下下面这个例子。</p><div style="text-align:center"><img src="../../images/mysql45/16/图%2014%20可见性验证方式%20--%20对照.png"><p><font color="gray">图 14 可见性验证方式 -- 对照</font></p></div><p><strong>补充说明：</strong></p><p>上面我们的验证结果都是在 <code>binlog_format=statement</code> 格 式下进行的。</p><p>@didiren 补充了一个 case， 如果是 binlog_format=row 并且 binlog_row_image=FULL 的时候，由于 MySQL 需要在 binlog 里面记录所有的字段，所以在读数据的时候就会把所有数据都读出来了。</p><p>根据上面说的规则，“既然读了数据，就会判断”， 因此在这时候，select * from t where id=1，结果就是“返回 (1,2)”。</p><p>同理，如果是 binlog_row_image=NOBLOB, 会读出除 blob 外的所有字段，在我们这个例子里，结果还是“返回 (1,2)”。</p><p>对应的代码如图 15 所示。这是 MySQL 5.6 版本引入的，在此之前我没有看过。所以，特此说明。</p><div style="text-align:center"><img src="../../images/mysql45/16/图%2015%20binlog_row_image=FULL%20读字段逻辑.png"><p><font color="gray">图 15 binlog_row_image=FULL 读字段逻辑</font></p></div><p>类似的，@mahonebags 同学提到了 timestamp 字段的问题。结论是：如果表中有 timestamp 字段而且设置了自动更新的话，那么更新“别的字段”的时候，MySQL 会读入所有涉及的字段，这样通过判断，就会发现不需要修改。</p><p>这两个点我会在后面讲更新性能的文章中再展开。</p><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../review">上一篇</a>    直播回顾 | 林晓斌：我的 MySQL 心路历程</p><p><a href="../17">下一篇</a>    17 | 如何正确地显示随机消息？</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>直播回顾 | 林晓斌：我的 MySQL 心路历程</title>
      <link href="/mysql45/review/"/>
      <url>/mysql45/review/</url>
      
        <content type="html"><![CDATA[<h1 id="直播回顾-林晓斌：我的-MySQL-心路历程"><a href="#直播回顾-林晓斌：我的-MySQL-心路历程" class="headerlink" title="直播回顾 | 林晓斌：我的 MySQL 心路历程"></a>直播回顾 | 林晓斌：我的 MySQL 心路历程</h1><p><font color="gray">2018-12-18 林晓斌</font></p><p><img src="../../images/mysql45/review/review.jpg"></p><p>在专栏上线后的 11 月 21 日，我来到极客时间做了一场直播，主题就是“我的 MySQL 心路历程”。今天，我特意将这个直播的回顾文章，放在了专栏下面，希望你可以从我这些年和 MySQL 打交道的经历中，找到对你有所帮助的点。</p><p>这里，我先和你说一下，在这个直播中，我主要分享的内容：</p><ol><li>我和 MySQL 打交道的经历；</li><li>你为什么要了解数据库原理；</li><li>我建议的 MySQL 学习路径；</li><li>DBA 的修炼之道。</li></ol><h1 id="我的经历"><a href="#我的经历" class="headerlink" title="我的经历"></a>我的经历</h1><h2 id="以丰富的经历进入百度"><a href="#以丰富的经历进入百度" class="headerlink" title="以丰富的经历进入百度"></a>以丰富的经历进入百度</h2><p>我是福州大学毕业的，据我了解，那时候我们学校的应届生很难直接进入百度，都要考到浙江大学读个研究生才行。没想到的是，我投递了简历后居然进了面试。</p><p>入职以后，我跑去问当时的面试官，为什么我的简历可以通过筛选？他们说：“因为你的简历厚啊”。我在读书的时候，确实做了很多项目，也实习过不少公司，所以简历里面的经历就显得很丰富了。</p><p>在面试的时候，有个让我印象很深刻的事儿。面试官问我说，你有这么多实习经历，有没有什么比较好玩儿的事？我想了想答道，跟你说个数据量很大的事儿 ，在跟移动做日志分析的时候我碰到了几千万行的数据。他听完以后就笑了。</p><p>后来，我进了百度才知道，几千万行那都是小数据。</p><h2 id="开始尝试看源码解决问题"><a href="#开始尝试看源码解决问题" class="headerlink" title="开始尝试看源码解决问题"></a>开始尝试看源码解决问题</h2><p>加入百度后，我是在贴吧做后端程序，比如权限系统等等。其实很简单，就是写一个 C 语言程序，响应客户端请求，然后返回结果。</p><p>那个时候，我还仅仅是个 MySQL 的普通用户，使用了一段时间后就出现问题了：一个跑得很快的请求，偶尔会又跑得非常慢。老板问这是什么原因，而我又不好意思说不知道，于是就自己上网查资料。</p><p>但是，2008 年那会儿，网上资料很少，花了挺长时间也没查出个所以然。最终，我只好去看源码。翻到源码，我当时就觉得它还蛮有意思的。而且，源码真的可以帮我解决一些问题。</p><p>于是一发不可收拾，我从那时候就入了源码的“坑”。</p><h2 id="混社区分享经验"><a href="#混社区分享经验" class="headerlink" title="混社区分享经验"></a>混社区分享经验</h2><p>2010 年的时候，阿里正好在招数据库的开发人员。虽然那时我还只是看得懂源码，没有什么开发经验，但还是抱着试试看的态度投了简历。然后顺利通过了面试，成功进入了阿里。之后，我就跟着褚霸（霸爷）干了 7 年多才离开了阿里。</p><p>在百度的时候，我基本上没有参加过社区活动。因为那时候百度可能更提倡内部分享，解决问题的经验基本上都是在内网分享。所以，去了阿里以后，我才建了博客、开了微博。我在阿里的花名叫丁奇，博客、微博、社区也因此都是用的这个名字。</p><h1 id="为什么要了解数据库原理？"><a href="#为什么要了解数据库原理？" class="headerlink" title="为什么要了解数据库原理？"></a>为什么要了解数据库原理？</h1><p>这里，我讲几个亲身经历的事情，和你聊聊为什么要了解数据库原理。</p><h2 id="了解原理能帮你更好地定位问题"><a href="#了解原理能帮你更好地定位问题" class="headerlink" title="了解原理能帮你更好地定位问题"></a>了解原理能帮你更好地定位问题</h2><p>一次同学聚会，大家谈起了技术问题。一个在政府里的同学说，他们的系统很奇怪，每天早上都得重启一下应用程序，否则就提示连接数据库失败，他们都不知道该怎么办。</p><p>我分析说，按照这个错误提示，应该就是连接时间过长了，断开了连接。数据库默认的超时时间是 8 小时，而你们平时六点下班，下班之后系统就没有人用了，等到第二天早上九点甚至十点才上班，这中间的时间已经超过 10 个小时了，数据库的连接肯定就会断开了。</p><p>我当时说，估计这个系统程序写得比较差，连接失败也不会重连，仍然用原来断掉的连接，所以就报错了。然后，我让他回去把超时时间改得长一点。后来他跟我说，按照这个方法，问题已经解决了。</p><p>由此，我也更深刻地体会到，作为开发人员，即使我们只知道每个参数的意思，可能就可以给出一些问题的正确应对方法。</p><h2 id="了解原理能让你更巧妙地解决问题"><a href="#了解原理能让你更巧妙地解决问题" class="headerlink" title="了解原理能让你更巧妙地解决问题"></a>了解原理能让你更巧妙地解决问题</h2><p>我在做贴吧系统的时候，每次访问页面都要请求一次权限。所以，这个请求权限的请求，访问概率会非常高，不可能每次都去数据库里查，怎么办呢？</p><p>我想了个简单的方案：在应用程序里面开了个很大的内存，启动的时候就把整张表全部 load 到内存里去。这样再有权限请求的时候，直接从内存里取就行了。</p><p>数据库重启时，我的进程也会跟着重启，接下来就会到数据表里面做全表扫描，把整个用户相关信息全部塞到内存里面去。</p><p>但是，后来我遇到了一个很郁闷的情况。有时候 MySQL 崩溃了，我的程序重新加载权限到内存里，结果这个 select 语句要执行 30 分钟左右。本来 MySQL 正常重启一下是很快的，进程重启也很快，正常加载权限的过程只需要两分钟就跑完了。但是，为什么异常重启的时候就要 30 分钟呢？</p><p>我没辙了，只好去看源码。然后，我发现 MySQL 有个机制，当它觉得系统空闲时会尽量去刷脏页。</p><p>具体到我们的例子里，MySQL 重启以后，会执行我的进程做全表扫描，但是因为这个时候权限数据还没有初始化完成，我的 Server 层不可能提供服务，于是 MySQL 里面就只有我那一个 select 全表扫描的请求，MySQL 就认为现在很闲，开始拼命地刷脏页，结果就吃掉了大量的磁盘资源，导致我的全表扫描也跑得很慢。</p><p>知道了这个机制以后，我就写了个脚本，每隔 0.5 秒发一个请求，执行一个简单的 SQL 查询，告诉数据库其实我现在很忙，脏页刷得慢一点。</p><p>脚本一发布使用，脏页果然刷得慢了，加载权限的扫描也跑得很快了。据说我离职两年多以后，这个脚本还在用。</p><p>你看，如果我们懂得一些参数，并可以理解这些参数，就可以做正确的设置了。而如果我们进一步地懂得一些原理，就可以更巧妙地解决问题了。</p><h2 id="看得懂源码让你有更多的方法"><a href="#看得懂源码让你有更多的方法" class="headerlink" title="看得懂源码让你有更多的方法"></a>看得懂源码让你有更多的方法</h2><p>2012 年的时候，阿里双十一业务的压力比较大。当时还没有这么多的 SSD，是机械硬盘的时代。</p><p>为了应对压力我们开始引入 SSD，但是不敢把 SSD 直接当存储用，而是作为二级缓存。当时，我们用了一个叫作 Flashcache 的开源系统（现在已经是老古董级别了，不知道你有没有听过这个系统）。</p><p>Flashcache 实现，把 SSD 当作物理盘的二级缓存，可以提升性能。但是，我们自己部署后发现性能提升的效果没有预想的那么好，甚至还不如纯机械盘。</p><p>于是，我跟霸爷就开始研究。霸爷负责分析 Flashcache 的源码，我负责分析 MySQL 源码。后来我们发现 Flashcache 是有脏页比例的，当脏页比例到了 80% 就会停下来强行刷盘。</p><p>一开始我们以为这个脏页比例是全部的 20%，看了源码才知道，原来它分了很多个桶，比如说一个桶 20M，这个桶如果用完 80%，它就认为脏页满了，就开始刷脏页。这也就意味着，如果你是顺序写的话，很容易就会把一个桶写满。</p><p>知道了这个原理以后，我就把日志之类顺序写的数据全都放到了机械硬盘，把随机写的数据放到了 Flashcache 上。这样修改以后，效果就好了。</p><p>你看，如果能看得懂源码，你的操作行为就会不一样。</p><h1 id="MySQL-学习路径"><a href="#MySQL-学习路径" class="headerlink" title="MySQL 学习路径"></a>MySQL 学习路径</h1><p>说到 MySQL 的学习路径，其实我上面分享的这些内容，都可以归结为学习路径。</p><p>首先你要会用，要去了解每个参数的意义，这样你的运维行为（使用行为）就会不一样。千万不要从网上拿了一些使用建议，别人怎么用，你就怎么用，而不去想为什么。再往后，就要去了解每个参数的实现原理。一旦你了解了这些原理，你的操作行为就会不一样。 再进一步，如果看得懂源码，那么你对数据库的理解也会不一样。</p><p>再来讲讲我是怎么带应届生的。实践是很好的学习方式，所以我会让新人来了以后先搭主备，然后你就会发现每个人的自学能力都不一样。比如遇到有延迟，或者我们故意构造一个主备数据不一致的场景，让新人了解怎么分析问题，解决问题。</p><p>如果一定要总结出一条学习路径的话，那首先要会<strong>用</strong>，然后可以<strong>发现问题</strong>。</p><p>在专栏里面，我在每篇文章末尾，都会提出一个常见问题，作为思考题。这些问题都不会很难，是跟专栏文章挂钩、又是会经常遇到的，但又无法直接从文章里拿到答案。</p><p>我的建议是，你可以尝试先不看答案自己去思考，或者去数据库里面翻一翻，这将会是一个不错的过程。</p><p>再下一步就是<strong>实践</strong>。之后当你觉得开始有一些“线”的概念了，再去<strong>看 MySQL 的官方手册</strong>。在我的专栏里，有人曾问我要不要直接去看手册？</p><p>我的建议是，一开始千万不要着急看手册，这里面有 100 多万个英文单词，你就算再厉害，也是看了后面忘了前面。所以，你一定要自己先有脉络，然后有一个知识网络，再看手册去查漏补缺。</p><p>我自己就是这么一路走过来的。</p><p>另外，在专栏的留言区，很多用户都希望我能推荐一本书搭配专栏学习。如果只推荐一本的话，我建议你读一下《高性能 MySQL》这本书，它是 MySQL 这个领域的经典图书，已经出到第三版了，你可以想象一下它的流行度。</p><p>这本书的其中两位译者（彭立勋、翟卫祥）是我原团队的小伙伴，有着非常丰富的 MySQL 源码开发经验，他们对 MySQL 的深刻理解，让这本书保持了跟原作英文版同样高的质量。</p><h1 id="DBA-的修炼"><a href="#DBA-的修炼" class="headerlink" title="DBA 的修炼"></a>DBA 的修炼</h1><h2 id="DBA-和开发工程师有什么相同点？"><a href="#DBA-和开发工程师有什么相同点？" class="headerlink" title="DBA 和开发工程师有什么相同点？"></a>DBA 和开发工程师有什么相同点？</h2><p>我带过开发团队，也带过 DBA 团队，所以可以分享一下这两个岗位的交集。</p><p>其实，DBA 本身要有些开发底子，比如说做运维系统的开发。另外，自动化程度越高，DBA 的日常运维工作量就越少，DBA 得去了解开发业务逻辑，往业务架构师这个方向去做。</p><p>开发工程师也是一样，不能所有的问题都指望 DBA 来解决。因为，DBA 在每个公司都是很少的几个人。所以，开发也需要对数据库原理有一定的了解，这样向 DBA 请教问题时才能更专业，更高效地解决问题。</p><p>所以说，这两个岗位应该有一定程度的融合，即：开发要了解数据库原理，DBA 要了解业务和开发。</p><h2 id="DBA-有前途吗？"><a href="#DBA-有前途吗？" class="headerlink" title="DBA 有前途吗？"></a>DBA 有前途吗？</h2><p>这里我要强调的是，每个岗位都有前途，只需要根据时代变迁稍微调整一下方向。</p><p>像原来开玩笑说 DBA 要体力好，因为得搬服务器。后来 DBA 的核心技能成了会搭库、会主备切换，但是现在这些也不够用了，因为已经有了自动化系统。</p><p>所以，DBA 接下来一方面是要了解业务，做业务的架构师；另一方面，是要有前瞻性，做主动诊断系统，把每个业务的问题挑出来做成月报，让业务开发去优化，有不清楚的地方，开发同学会来找你咨询。你帮助他们做好了优化之后，可以把优化的指标呈现出来。这将很好地体现出你对于公司的价值。</p><h2 id="有哪些比较好的习惯和提高-SQL-效率的方法？"><a href="#有哪些比较好的习惯和提高-SQL-效率的方法？" class="headerlink" title="有哪些比较好的习惯和提高 SQL 效率的方法？"></a>有哪些比较好的习惯和提高 SQL 效率的方法？</h2><p>这个方法，总结起来就是：要多写 SQL，培养自己对 SQL 语句执行效率的感觉。以后再写或者建索引的时候，知道这个语句执行下去大概的时间复杂度，是全表扫描还是索引扫描、是不是需要回表，在心里都有一个大概的概念。</p><p>这样每次写出来的 SQL 都会快一点，而且不容易犯低级错误。这也正式我开设这个专栏的目标。</p><h2 id="看源码需要什么技术？"><a href="#看源码需要什么技术？" class="headerlink" title="看源码需要什么技术？"></a>看源码需要什么技术？</h2><p>看源码的话，一是要掌握 C 和 C++；另外还要熟悉一些调试工具。因为代码是静态的，运行起来是动态的，看代码是单线程的，运行起来是多线程的，所以要会调试。</p><p>另外，我不建议你用可视化的工具。虽然可视化工具很方便，但你不知道这个操作点下去以后，实际上做了什么，所以我建议你自己手写代码和 SQL 语句，这样对一些底层原理你会更明白。</p><h2 id="怎么学习-C、C-？"><a href="#怎么学习-C、C-？" class="headerlink" title="怎么学习 C、C++？"></a>怎么学习 C、C++？</h2><p>我在读研究生的时候，在 C 和 C++ 语言的学习上进步最大。</p><p>那时，我去给专科上 C 和 C++ 的课。我觉得自己已经会了，完全可以教得了。但去了之后，我才知道，自己会跟能够教别人完全是两码事儿。备课的时候，你不能只讲会用的部分，还得把原理讲清楚。这样，就会倒逼自己进行更深入更全面的学习。</p><p>有的人看完技术博客和专栏，会把这篇文章的提纲列一下，写写自己的问题和对这篇文章的理解。这个过程，是非常利于学习的。因为你听进来是一回事儿，讲出去则是另一回事儿。</p><h2 id="学数据库要保持什么心态？"><a href="#学数据库要保持什么心态？" class="headerlink" title="学数据库要保持什么心态？"></a>学数据库要保持什么心态？</h2><p>不只是数据库，所有多线程的服务，调试和追查问题的过程都是很枯燥的，遇到问题都会很麻烦。但是，你找出问题时的那一下会很爽。</p><p>我觉得你得找到这种感觉，它可以支持你度过接下来要枯燥很久的那段时光，这样你才能继续坚持下去。</p><p>当然，如果有更快乐的学习过程还是更好的，希望这个专栏能让你学习得轻松些。</p><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><p><a href="../15">上一篇</a>    15 | 答疑文章（一）：日志和索引相关问题</p><p><a href="../16">下一篇</a>    16 | “order by”是怎么工作的？</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>15 | 答疑文章（一）：日志和索引相关问题</title>
      <link href="/mysql45/15/"/>
      <url>/mysql45/15/</url>
      
        <content type="html"><![CDATA[<h1 id="15-答疑文章（一）：日志和索引相关问题"><a href="#15-答疑文章（一）：日志和索引相关问题" class="headerlink" title="15 | 答疑文章（一）：日志和索引相关问题"></a>15 | 答疑文章（一）：日志和索引相关问题</h1><p><font color="gray">2018-12-17 林晓斌</font></p><p><img src="../../images/mysql45/15/15.jpg"></p><p>在今天这篇答疑文章更新前，MySQL 实战这个专栏已经更新了 14 篇。在这些文章中，大家在评论区留下了很多高质量的留言。现在，每篇文章的评论区都有热心的同学帮忙总结文章知识点，也有不少同学提出了很多高质量的问题，更有一些同学帮忙解答其他同学提出的问题。</p><p>在浏览这些留言并回复的过程中，我倍受鼓舞，也尽我所知地帮助你解决问题、和你讨论。可以说，你们的留言活跃了整个专栏的氛围、提升了整个专栏的质量，谢谢你们。</p><p>评论区的大多数留言我都直接回复了，对于需要展开说明的问题，我都拿出小本子记了下来。这些被记下来的问题，就是我们今天这篇答疑文章的素材了。</p><p>到目前为止，我已经收集了 47 个问题，很难通过今天这一篇文章全部展开。所以，我就先从中找了几个联系非常紧密的问题，串了起来，希望可以帮你解决关于日志和索引的一些疑惑。而其他问题，我们就留着后面慢慢展开吧。</p><h1 id="日志相关问题"><a href="#日志相关问题" class="headerlink" title="日志相关问题"></a>日志相关问题</h1><p>我在第 2 篇文章<a href="../2">《日志系统：一条 SQL 更新语句是如何执行的？》</a>中，和你讲到 binlog（归档日志）和 redo log（重做日志）配合崩溃恢复的时候，用的是反证法，说明了如果没有两阶段提交，会导致 MySQL 出现主备数据不一致等问题。</p><p>在这篇文章下面，很多同学在问，在两阶段提交的不同瞬间，MySQL 如果发生异常重启，是怎么保证数据完整性的？</p><p>现在，我们就从这个问题开始吧。</p><p>我再放一次两阶段提交的图，方便你学习下面的内容。</p><div style="text-align:center"><img src="../../images/mysql45/15/图%201%20两阶段提交示意图.jpg"><p><font color="gray">图 1 两阶段提交示意图</font></p></div><p>这里，我要先和你解释一个误会式的问题。有同学在评论区问到，这个图不是一个 update 语句的执行流程吗，怎么还会调用 commit 语句？</p><p>他产生这个疑问的原因，是把<strong>两个“commit”的概念</strong>混淆了：</p><ul><li>他说的“commit 语句”，是指 MySQL 语法中，用于提交一个事务的命令。一般跟 begin/start transaction 配对使用。</li><li>而我们图中用到的这个“commit 步骤”，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，这个事务就提交完成了。</li><li>“commit 语句”执行的时候，会包含“commit 步骤”。</li></ul><p>而我们这个例子里面，没有显式地开启事务，因此这个 update 语句自己就是一个事务，在执行完成后提交事务时，就会用到这个“commit 步骤“。</p><p>接下来，我们就一起分析一下<strong>在两阶段提交的不同时刻，MySQL 异常重启会出现什么现象。</strong></p><p>如果在图中时刻 A 的地方，也就是写入 redo log 处于 prepare 阶段之后、写 binlog 之前，发生了崩溃（crash），由于此时 binlog 还没写，redo log 也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog 还没写，所以也不会传到备库。到这里，大家都可以理解。</p><p>大家出现问题的地方，主要集中在时刻 B，也就是 binlog 写完，redo log 还没 commit 前发生 crash，那崩溃恢复的时候 MySQL 会怎么处理？</p><p>我们先来看一下崩溃恢复时的判断规则。</p><ol><li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；</li><li>如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：<br>a. 如果是，则提交事务；<br>b. 否则，回滚事务。</li></ol><p>这里，时刻 B 发生 crash 对应的就是 2(a) 的情况，崩溃恢复过程中事务会被提交。</p><p>现在，我们继续延展一下这个问题。</p><h2 id="追问-1：MySQL-怎么知道-binlog-是完整的"><a href="#追问-1：MySQL-怎么知道-binlog-是完整的" class="headerlink" title="追问 1：MySQL 怎么知道 binlog 是完整的?"></a>追问 1：MySQL 怎么知道 binlog 是完整的?</h2><p>回答：一个事务的 binlog 是有完整格式的：</p><ul><li>statement 格式的 binlog，最后会有 COMMIT；</li><li>row 格式的 binlog，最后会有一个 XID event。</li></ul><p>另外，在 MySQL 5.6.2 版本以后，还引入了 <code>binlog-checksum</code> 参数，用来验证 binlog 内容的正确性。对于 binlog 日志由于磁盘原因，可能会在日志中间出错的情况，MySQL 可以通过校验 checksum 的结果来发现。所以，MySQL 还是有办法验证事务 binlog 的完整性的。</p><h2 id="追问-2：redo-log-和-binlog-是怎么关联起来的"><a href="#追问-2：redo-log-和-binlog-是怎么关联起来的" class="headerlink" title="追问 2：redo log 和 binlog 是怎么关联起来的?"></a>追问 2：redo log 和 binlog 是怎么关联起来的?</h2><p>回答：它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：</p><ul><li>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；</li><li>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。</li></ul><h2 id="追问-3：处于-prepare-阶段的-redo-log-加上完整-binlog，重启就能恢复，MySQL-为什么要这么设计"><a href="#追问-3：处于-prepare-阶段的-redo-log-加上完整-binlog，重启就能恢复，MySQL-为什么要这么设计" class="headerlink" title="追问 3：处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?"></a>追问 3：处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?</h2><p>回答：其实，这个问题还是跟我们在反证法中说到的数据与备份的一致性有关。在时刻 B，也就是 binlog 写完以后 MySQL 发生崩溃，这时候 binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。</p><p>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p><h2 id="追问-4：如果这样的话，为什么还要两阶段提交呢？干脆先-redo-log-写完，再写-binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"><a href="#追问-4：如果这样的话，为什么还要两阶段提交呢？干脆先-redo-log-写完，再写-binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？" class="headerlink" title="追问 4：如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"></a>追问 4：如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？</h2><p>回答：其实，两阶段提交是经典的分布式系统问题，并不是 MySQL 独有的。</p><p>如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。</p><p>对于 InnoDB 引擎来说，如果 redo log 提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果 redo log 直接提交，然后 binlog 写入的时候失败，InnoDB 又回滚不了，数据和 binlog 日志又不一致了。</p><p>两阶段提交就是为了给所有人一个机会，当每个人都说“我 ok”的时候，再一起提交。</p><h2 id="追问-5：不引入两个日志，也就没有两阶段提交的必要了。只用-binlog-来支持崩溃恢复，又能支持归档，不就可以了？"><a href="#追问-5：不引入两个日志，也就没有两阶段提交的必要了。只用-binlog-来支持崩溃恢复，又能支持归档，不就可以了？" class="headerlink" title="追问 5：不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？"></a>追问 5：不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？</h2><p>回答：这位同学的意思是，只保留 binlog，然后可以把提交流程改成这样：… -&gt; “数据更新到内存” -&gt; “写 binlog” -&gt; “提交事务”，是不是也可以提供崩溃恢复的能力？</p><p>答案是不可以。</p><p>如果说<strong>历史原因</strong>的话，那就是 InnoDB 并不是 MySQL 的原生存储引擎。MySQL 的原生引擎是 MyISAM，设计之初就有没有支持崩溃恢复。</p><p>InnoDB 在作为 MySQL 的插件加入 MySQL 引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。</p><p>InnoDB 接入了 MySQL 后，发现既然 binlog 没有崩溃恢复的能力，那就用 InnoDB 原有的 redo log 好了。</p><p>而如果说<strong>实现上的原因</strong>的话，就有很多了。就按照问题中说的，只用 binlog 来实现崩溃恢复的流程，我画了一张示意图，这里就没有 redo log 了。</p><div style="text-align:center"><img src="../../images/mysql45/15/图%202%20只用%20binlog%20支持崩溃恢复.jpg"><p><font color="gray">图 2 只用 binlog 支持崩溃恢复</font></p></div><p>这样的流程下，binlog 还是不能支持崩溃恢复的。我说一个不支持的点吧：binlog 没有能力恢复“数据页”。</p><p>如果在图中标的位置，也就是 binlog2 写完了，但是整个事务还没有 commit 的时候，MySQL 发生了 crash。</p><p>重启后，引擎内部事务 2 会回滚，然后应用 binlog2 可以补回来；但是对于事务 1 来说，系统已经认为提交完成了，不会再应用一次 binlog1。</p><p>但是，InnoDB 引擎使用的是 WAL 技术，执行事务的时候，写完内存和日志，事务就算完成了。如果之后崩溃，要依赖于日志来恢复数据页。</p><p>也就是说在图中这个位置发生崩溃的话，事务 1 也是可能丢失了的，而且是数据页级的丢失。此时，binlog 里面并没有记录数据页的更新细节，是补不回来的。</p><p>你如果要说，那我优化一下 binlog 的内容，让它来记录数据页的更改可以吗？但，这其实就是又做了一个 redo log 出来。</p><p>所以，至少现在的 binlog 能力，还不能支持崩溃恢复。</p><h2 id="追问-6：那能不能反过来，只用-redo-log，不要-binlog？"><a href="#追问-6：那能不能反过来，只用-redo-log，不要-binlog？" class="headerlink" title="追问 6：那能不能反过来，只用 redo log，不要 binlog？"></a>追问 6：那能不能反过来，只用 redo log，不要 binlog？</h2><p>回答：如果只从崩溃恢复的角度来讲是可以的。你可以把 binlog 关掉，这样就没有两阶段提交了，但系统依然是 crash-safe 的。</p><p>但是，如果你了解一下业界各个公司的使用场景的话，就会发现在正式的生产库上，binlog 都是开着的。因为 binlog 有着 redo log 无法替代的功能。</p><p>一个是归档。redo log 是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log 也就起不到归档的作用。</p><p>一个就是 MySQL 系统依赖于 binlog。binlog 作为 MySQL 一开始就有的功能，被用在了很多地方。其中，MySQL 系统高可用的基础，就是 binlog 复制。</p><p>还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费 MySQL 的 binlog 来更新自己的数据。关掉 binlog 的话，这些下游系统就没法输入了。</p><p>总之，由于现在包括 MySQL 高可用在内的很多系统机制都依赖于 binlog，所以“鸠占鹊巢”redo log 还做不到。你看，发展生态是多么重要。</p><h2 id="追问-7：redo-log-一般设置多大？"><a href="#追问-7：redo-log-一般设置多大？" class="headerlink" title="追问 7：redo log 一般设置多大？"></a>追问 7：redo log 一般设置多大？</h2><p>回答：redo log 太小的话，会导致很快就被写满，然后不得不强行刷 redo log，这样 WAL 机制的能力就发挥不出来了。</p><p>所以，如果是现在常见的几个 TB 的磁盘的话，就不要太小气了，直接将 redo log 设置为 4 个文件、每个文件 1GB 吧。</p><h2 id="追问-8：正常运行中的实例，数据写入后的最终落盘，是从-redo-log-更新过来的还是从-buffer-pool-更新过来的呢？"><a href="#追问-8：正常运行中的实例，数据写入后的最终落盘，是从-redo-log-更新过来的还是从-buffer-pool-更新过来的呢？" class="headerlink" title="追问 8：正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？"></a>追问 8：正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？</h2><p>回答：这个问题其实问得非常好。这里涉及到了，“redo log 里面到底是什么”的问题。</p><p>实际上，redo log 并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由 redo log 更新过去”的情况。</p><ol><li>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与 redo log 毫无关系。</li><li>在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让 redo log 更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</li></ol><h2 id="追问-9：redo-log-buffer-是什么？是先修改内存，还是先写-redo-log-文件？"><a href="#追问-9：redo-log-buffer-是什么？是先修改内存，还是先写-redo-log-文件？" class="headerlink" title="追问 9：redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？"></a>追问 9：redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？</h2><p>回答：这两个问题可以一起回答。</p><p>在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">begin;insert into t1 ...insert into t2 ...commit;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没 commit 的时候就直接写到 redo log 文件里。</p><p>所以，redo log buffer 就是一块内存，用来先存 redo 日志的。也就是说，在执行第一个 insert 的时候，数据的内存被修改了，redo log buffer 也写入了日志。</p><p>但是，真正把日志写到 redo log 文件（文件名是 ib_logfile+ 数字），是在执行 commit 语句的时候做的。</p><p>（这里说的是事务执行过程中不会“主动去刷盘”，以减少不必要的 IO 消耗。但是可能会出现“被动写入磁盘”，比如内存不够、其他事务提交等情况。这个问题我们会在后面第 22 篇文章《MySQL 有哪些“饮鸩止渴”的提高性能的方法？》中再详细展开）。</p><p>单独执行一个更新语句的时候，InnoDB 会自己启动一个事务，在语句执行完成的时候提交。过程跟上面是一样的，只不过是“压缩”到了一个语句里面完成。</p><p>以上这些问题，就是把大家提过的关于 redo log 和 binlog 的问题串起来，做的一次集中回答。如果你还有问题，可以在评论区继续留言补充。</p><h1 id="业务设计问题"><a href="#业务设计问题" class="headerlink" title="业务设计问题"></a>业务设计问题</h1><p>接下来，我再和你分享 @ithunter 同学在第 8 篇文章<a href="https://time.geekbang.org/column/article/70562">《</a><a href="../8">事务到底是隔离的还是不隔离的？</a><a href="https://time.geekbang.org/column/article/70562">》</a>的评论区提到的跟索引相关的一个问题。我觉得这个问题挺有趣、也挺实用的，其他同学也可能会碰上这样的场景，在这里解答和分享一下。</p><p>问题是这样的（我文字上稍微做了点修改，方便大家理解）：</p><blockquote><p>业务上有这样的需求，A、B 两个用户，如果互相关注，则成为好友。设计上是有两张表，一个是 like 表，一个是 friend 表，like 表有 user_id、liker_id 两个字段，我设置为复合唯一索引即 uk_user_id_liker_id。语句执行逻辑是这样的：</p></blockquote><blockquote><p>以 A 关注 B 为例：<br>第一步，先查询对方有没有关注自己（B 有没有关注 A）<br>select * from like where user_id = B and liker_id = A;</p></blockquote><blockquote><p>如果有，则成为好友<br>insert into friend;</p></blockquote><blockquote><p>没有，则只是单向关注关系<br>insert into like;</p></blockquote><blockquote><p>但是如果 A、B 同时关注对方，会出现不会成为好友的情况。因为上面第 1 步，双方都没关注对方。第 1 步即使使用了排他锁也不行，因为记录不存在，行锁无法生效。请问这种情况，在 MySQL 锁层面有没有办法处理？</p></blockquote><p>首先，我要先赞一下这样的提问方式。虽然极客时间现在的评论区还不能追加评论，但如果大家能够一次留言就把问题讲清楚的话，其实影响也不大。所以，我希望你在留言提问的时候，也能借鉴这种方式。</p><p>接下来，我把 @ithunter 同学说的表模拟出来，方便我们讨论。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE `like` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `user_id` int(11) NOT NULL,  `liker_id` int(11) NOT NULL,  PRIMARY KEY (`id`),  UNIQUE KEY `uk_user_id_liker_id` (`user_id`,`liker_id`)) ENGINE=InnoDB; CREATE TABLE `friend` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `friend_1_id` int(11) NOT NULL,  `firned_2_id` int(11) NOT NULL,  UNIQUE KEY `uk_friend` (`friend_1_id`,`firned_2_id`)  PRIMARY KEY (`id`)) ENGINE=InnoDB;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然这个题干中，并没有说到 friend 表的索引结构。但我猜测 friend_1_id 和 friend_2_id 也有索引，为便于描述，我给加上唯一索引。</p><p>顺便说明一下，“like”是关键字，我一般不建议使用关键字作为库名、表名、字段名或索引名。</p><p>我把他的疑问翻译一下，在并发场景下，同时有两个人，设置为关注对方，就可能导致无法成功加为朋友关系。</p><p>现在，我用你已经熟悉的时刻顺序表的形式，把这两个事务的执行语句列出来：</p><div style="text-align:center"><img src="../../images/mysql45/15/图%203%20并发“喜欢”逻辑操作顺序.png"><p><font color="gray">图 3 并发“喜欢”逻辑操作顺序</font></p></div><p>由于一开始 A 和 B 之间没有关注关系，所以两个事务里面的 select 语句查出来的结果都是空。</p><p>因此，session 1 的逻辑就是“既然 B 没有关注 A，那就只插入一个单向关注关系”。session 2 也同样是这个逻辑。</p><p>这个结果对业务来说就是 bug 了。因为在业务设定里面，这两个逻辑都执行完成以后，是应该在 friend 表里面插入一行记录的。</p><p>如提问里面说的，“第 1 步即使使用了排他锁也不行，因为记录不存在，行锁无法生效”。不过，我想到了另外一个方法，来解决这个问题。</p><p>首先，要给“like”表增加一个字段，比如叫作 relation_ship，并设为整型，取值 1、2、3。</p><blockquote><p>值是 1 的时候，表示 user_id 关注 liker_id;<br>值是 2 的时候，表示 liker_id 关注 user_id;<br>值是 3 的时候，表示互相关注。</p></blockquote><p>然后，当 A 关注 B 的时候，逻辑改成如下所示的样子：</p><p>应用代码里面，比较 A 和 B 的大小，如果 A&lt;B，就执行下面的逻辑</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">begin; /* 启动事务 */insert into `like`(user_id, liker_id, relation_ship) values(A, B, 1) on duplicate key update relation_ship=relation_ship | 1;select relation_ship from `like` where user_id=A and liker_id=B;/* 代码中判断返回的 relation_ship，  如果是 1，事务结束，执行 commit  如果是 3，则执行下面这两个语句：  */insert ignore into friend(friend_1_id, friend_2_id) values(A,B);commit;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 A&gt;B，则执行下面的逻辑</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">begin; /* 启动事务 */insert into `like`(user_id, liker_id, relation_ship) values(B, A, 2) on duplicate key update relation_ship=relation_ship | 2;select relation_ship from `like` where user_id=B and liker_id=A;/* 代码中判断返回的 relation_ship，  如果是 2，事务结束，执行 commit  如果是 3，则执行下面这两个语句：*/insert ignore into friend(friend_1_id, friend_2_id) values(B,A);commit;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个设计里，让“like”表里的数据保证 user_id &lt; liker_id，这样不论是 A 关注 B，还是 B 关注 A，在操作“like”表的时候，如果反向的关系已经存在，就会出现行锁冲突。</p><p>然后，<code>insert … on duplicate</code> 语句，确保了在事务内部，执行了这个 SQL 语句后，就强行占住了这个行锁，之后的 select 判断 relation_ship 这个逻辑时就确保了是在行锁保护下的读操作。</p><p>操作符 “|” 是按位或，连同最后一句 insert 语句里的 ignore，是为了保证重复调用时的幂等性。</p><p>这样，即使在双方“同时”执行关注操作，最终数据库里的结果，也是 like 表里面有一条关于 A 和 B 的记录，而且 relation_ship 的值是 3， 并且 friend 表里面也有了 A 和 B 的这条记录。</p><p>不知道你会不会吐槽：之前明明还说尽量不要使用唯一索引，结果这个例子一上来我就创建了两个。这里我要再和你说明一下，之前文章我们讨论的，是在“业务开发保证不会插入重复记录”的情况下，着重要解决性能问题的时候，才建议尽量使用普通索引。</p><p>而像这个例子里，按照这个设计，业务根本就是保证“我一定会插入重复数据，数据库一定要要有唯一性约束”，这时就没啥好说的了，唯一索引建起来吧。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这是专栏的第一篇答疑文章。</p><p>我针对前 14 篇文章，大家在评论区中的留言，从中摘取了关于日志和索引的相关问题，串成了今天这篇文章。这里我也要再和你说一声，有些我答应在答疑文章中进行扩展的话题，今天这篇文章没来得及扩展，后续我会再找机会为你解答。所以，篇幅所限，评论区见吧。</p><p>最后，虽然这篇是答疑文章，但课后问题还是要有的。</p><p>我们创建了一个简单的表 t，并插入一行，然后对这一行做修改。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE `t` (`id` int(11) NOT NULL primary key auto_increment,`a` int(11) DEFAULT NULL) ENGINE=InnoDB;insert into t values(1,2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候，表 t 里有唯一的一行数据 (1,2)。假设，我现在要执行：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; update t set a=2 where id=1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你会看到这样的结果：</p><p><img src="../../images/mysql45/15/%E8%AF%BE%E5%90%8E%E9%97%AE%E9%A2%98.png"></p><p>结果显示，匹配 (rows matched) 了一行，修改 (Changed) 了 0 行。</p><p>仅从现象上看，MySQL 内部在处理这个命令的时候，可以有以下三种选择：</p><ol><li>更新都是先读后写的，MySQL 读出数据，发现 a 的值本来就是 2，不更新，直接返回，执行结束；</li><li>MySQL 调用了 InnoDB 引擎提供的“修改为 (1,2)”这个接口，但是引擎发现值与原来相同，不更新，直接返回；</li><li>InnoDB 认真执行了“把这个值修改成 (1,2)”这个操作，该加锁的加锁，该更新的更新。</li></ol><p>你觉得实际情况会是以上哪种呢？你可否用构造实验的方式，来证明你的结论？进一步地，可以思考一下，MySQL 为什么要选择这种策略呢？</p><p>你可以把你的验证方法和思考写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是，用一个计数表记录一个业务表的总行数，在往业务表插入数据的时候，需要给计数值加 1。</p><p>逻辑实现上是启动一个事务，执行两个语句：</p><ol><li>insert into 数据表；</li><li>update 计数表，计数值加 1。</li></ol><p>从系统并发能力的角度考虑，怎么安排这两个语句的顺序。</p><p>这里，我直接复制 @阿建 的回答过来供你参考：</p><blockquote><p>并发系统性能的角度考虑，应该先插入操作记录，再更新计数表。<br>知识点在<a href="../7">《行锁功过：怎么减少行锁对性能的影响？》</a><br>因为更新计数表涉及到行锁的竞争，先插入再更新能最大程度地减少事务之间的锁等待，提升并发度。</p></blockquote><p>评论区有同学说，应该把 update 计数表放后面，因为这个计数表可能保存了多个业务表的计数值。如果把 update 计数表放到事务的第一个语句，多个业务表同时插入数据的话，等待时间会更长。</p><p>这个答案的结论是对的，但是理解不太正确。即使我们用一个计数表记录多个业务表的行数，也肯定会给表名字段加唯一索引。类似于下面这样的表结构：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE `rows_stat` (  `table_name` varchar(64) NOT NULL,  `row_count` int(10) unsigned NOT NULL,  PRIMARY KEY (`table_name`)) ENGINE=InnoDB;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在更新计数表的时候，一定会传入 <code>where table_name=$table_name</code>，使用主键索引，更新加行锁只会锁在一行上。</p><p>而在不同业务表插入数据，是更新不同的行，不会有行锁。</p><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../14">上一篇</a>    14 | count(*)这么慢，我该怎么办？</p><p><a href="../review">下一篇</a>    直播回顾 | 林晓斌：我的 MySQL 心路历程</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14 | count(*)这么慢，我该怎么办？</title>
      <link href="/mysql45/14/"/>
      <url>/mysql45/14/</url>
      
        <content type="html"><![CDATA[<h1 id="14-count-这么慢，我该怎么办？"><a href="#14-count-这么慢，我该怎么办？" class="headerlink" title="14 | count(*)这么慢，我该怎么办？"></a>14 | count(*)这么慢，我该怎么办？</h1><p><font color="gray">2018-12-14 林晓斌</font></p><p><img src="../../images/mysql45/14/14.jpg"></p><p>在开发系统的时候，你可能经常需要计算一个表的行数，比如一个交易系统的所有变更记录总数。这时候你可能会想，一条 <code>select count(*) from t</code> 语句不就解决了吗？</p><p>但是，你会发现随着系统中记录数越来越多，这条语句执行得也会越来越慢。然后你可能就想了，MySQL 怎么这么笨啊，记个总数，每次要查的时候直接读出来，不就好了吗。</p><p>那么今天，我们就来聊聊 count(*) 语句到底是怎样实现的，以及 MySQL 为什么会这么实现。然后，我会再和你说说，如果应用中有这种频繁变更并需要统计表行数的需求，业务设计上可以怎么做。</p><h1 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*) 的实现方式"></a>count(*) 的实现方式</h1><p>你首先要明确的是，在不同的 MySQL 引擎中，count(*) 有不同的实现方式。</p><ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；</li><li>而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul><p>这里需要注意的是，我们在这篇文章里讨论的是没有过滤条件的 count(*)，如果加了 where 条件的话，MyISAM 表也是不能返回得这么快的。</p><p>在前面的文章中，我们一起分析了为什么要使用 InnoDB，因为不论是在事务支持、并发能力还是在数据安全方面，InnoDB 都优于 MyISAM。我猜你的表也一定是用了 InnoDB 引擎。这就是当你的记录数越来越多的时候，计算一个表的总行数会越来越慢的原因。</p><p>那<strong>为什么 InnoDB 不跟 MyISAM 一样，也把数字存起来呢？</strong></p><p>这是因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。这里，我用一个算 count(*) 的例子来为你解释一下。</p><p>假设表 t 中现在有 10000 条记录，我们设计了三个用户并行的会话。</p><ul><li>会话 A 先启动事务并查询一次表的总行数；</li><li>会话 B 启动事务，插入一行后记录后，查询表的总行数；</li><li>会话 C 先启动一个单独的语句，插入一行记录后，查询表的总行数。</li></ul><p>我们假设从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的。</p><div style="text-align:center"><img src="../../images/mysql45/14/图%201%20会话%20A、B、C%20的执行流程.png"><p><font color="gray">图 1 会话 A、B、C 的执行流程</font></p></div><p>你会看到，在最后一个时刻，三个会话 A、B、C 会同时查询表 t 的总行数，但拿到的结果却不同。</p><p>这和 InnoDB 的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是 MVCC 来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于 count(*) 请求来说，InnoDB 只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</p><blockquote><p>备注：如果你对 MVCC 记忆模糊了，可以再回顾下第 3 篇文章<a href="../3">《事务隔离：为什么你改了我还看不见？》</a>和第 8 篇文章<a href="../8">《事务到底是隔离的还是不隔离的？》</a>中的相关内容。</p></blockquote><p>当然，现在这个看上去笨笨的 MySQL，在执行 count(*) 操作的时候还是做了优化的。</p><p>你知道的，InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 count(<em>) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。*<em>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</em></em></p><p>如果你用过 <code>show table status</code> 命令的话，就会发现这个命令的输出结果里面也有一个 TABLE_ROWS 用于显示这个表当前有多少行，这个命令执行挺快的，那这个 TABLE_ROWS 能代替 count(*) 吗？</p><p>你可能还记得在第 10 篇文章<a href="../10">《 MySQL 为什么有时候会选错索引？》</a>中我提到过，索引统计的值是通过采样来估算的。实际上，TABLE_ROWS 就是从这个采样估算得来的，因此它也很不准。有多不准呢，官方文档说误差可能达到 40% 到 50%。<strong>所以，show table status 命令显示的行数也不能直接使用。</strong></p><p>到这里我们小结一下：</p><ul><li>MyISAM 表虽然 count(*) 很快，但是不支持事务；</li><li>show table status 命令虽然返回很快，但是不准确；</li><li>InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题。</li></ul><p>那么，回到文章开头的问题，如果你现在有一个页面经常要显示交易系统的操作记录总数，到底应该怎么办呢？答案是，我们只能自己计数。</p><p>接下来，我们讨论一下，看看自己计数有哪些方法，以及每种方法的优缺点有哪些。</p><p>这里，我先和你说一下这些方法的基本思路：你需要自己找一个地方，把操作记录表的行数存起来。</p><h1 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h1><p>对于更新很频繁的库来说，你可能会第一时间想到，用缓存系统来支持。</p><p>你可以用一个 Redis 服务来保存这个表的总行数。这个表每被插入一行 Redis 计数就加 1，每被删除一行 Redis 计数就减 1。这种方式下，读和更新操作都很快，但你再想一下这种方式存在什么问题吗？</p><p>没错，缓存系统可能会丢失更新。</p><p>Redis 的数据不能永久地留在内存里，所以你会找一个地方把这个值定期地持久化存储起来。但即使这样，仍然可能丢失更新。试想如果刚刚在数据表中插入了一行，Redis 中保存的值也加了 1，然后 Redis 异常重启了，重启后你要从存储 redis 数据的地方把这个值读回来，而刚刚加 1 的这个计数操作却丢失了。</p><p>当然了，这还是有解的。比如，Redis 异常重启以后，到数据库里面单独执行一次 count(*) 获取真实的行数，再把这个值写回到 Redis 里就可以了。异常重启毕竟不是经常出现的情况，这一次全表扫描的成本，还是可以接受的。</p><p>但实际上，<strong>将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 Redis 正常工作，这个值还是逻辑上不精确的。</strong></p><p>你可以设想一下有这么一个页面，要显示操作记录的总数，同时还要显示最近操作的 100 条记录。那么，这个页面的逻辑就需要先到 Redis 里面取出计数，再到数据表里面取数据记录。</p><p>我们是这么定义不精确的：</p><ol><li>一种是，查到的 100 行结果里面有最新插入记录，而 Redis 的计数里还没加 1；</li><li>另一种是，查到的 100 行结果里没有最新插入的记录，而 Redis 的计数里已经加了 1。</li></ol><p>这两种情况，都是逻辑不一致的。</p><p>我们一起来看看这个时序图。</p><div style="text-align:center"><img src="../../images/mysql45/14/图%202%20会话%20A、B%20执行时序图.png"><p><font color="gray">图 2 会话 A、B 执行时序图</font></p></div><p>图 2 中，会话 A 是一个插入交易记录的逻辑，往数据表里插入一行 R，然后 Redis 计数加 1；会话 B 就是查询页面显示时需要的数据。</p><p>在图 2 的这个时序里，在 T3 时刻会话 B 来查询的时候，会显示出新插入的 R 这个记录，但是 Redis 的计数还没加 1。这时候，就会出现我们说的数据不一致。</p><p>你一定会说，这是因为我们执行新增记录逻辑时候，是先写数据表，再改 Redis 计数。而读的时候是先读 Redis，再读数据表，这个顺序是相反的。那么，如果保持顺序一样的话，是不是就没问题了？我们现在把会话 A 的更新顺序换一下，再看看执行结果。</p><div style="text-align:center"><img src="../../images/mysql45/14/图%203%20调整顺序后，会话%20A、B%20的执行时序图.png"><p><font color="gray">图 3 调整顺序后，会话 A、B 的执行时序图</font></p></div><p>你会发现，这时候反过来了，会话 B 在 T3 时刻查询的时候，Redis 计数加了 1 了，但还查不到新插入的 R 这一行，也是数据不一致的情况。</p><p>在并发系统里面，我们是无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，所以，我们说即使 Redis 正常工作，这个计数值还是逻辑上不精确的。</p><h1 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h1><p>根据上面的分析，用缓存系统保存计数有丢失数据和计数不精确的问题。那么，<strong>如果我们把这个计数直接放到数据库里单独的一张计数表 C 中，又会怎么样呢？</strong></p><p>首先，这解决了崩溃丢失的问题，InnoDB 是支持崩溃恢复不丢数据的。</p><blockquote><p>备注：关于 InnoDB 的崩溃恢复，你可以再回顾一下第 2 篇文章<a href="../2">《日志系统：一条 SQL 更新语句是如何执行的？》</a>中的相关内容。</p></blockquote><p>然后，我们再看看能不能解决计数不精确的问题。</p><p>你会说，这不一样吗？无非就是把图 3 中对 Redis 的操作，改成了对计数表 C 的操作。只要出现图 3 的这种执行序列，这个问题还是无解的吧？</p><p>这个问题还真不是无解的。</p><p>我们这篇文章要解决的问题，都是由于 InnoDB 要支持事务，从而导致 InnoDB 表不能把 count(*) 直接存起来，然后查询的时候直接返回形成的。</p><p>所谓以子之矛攻子之盾，现在我们就利用“事务”这个特性，把问题解决掉。</p><div style="text-align:center"><img src="../../images/mysql45/14/图%204%20会话%20A、B%20的执行时序图.png"><p><font color="gray">图 4 会话 A、B 的执行时序图</font></p></div><p>我们来看下现在的执行结果。虽然会话 B 的读操作仍然是在 T3 执行的，但是因为这时候更新事务还没有提交，所以计数值加 1 这个操作对会话 B 还不可见。</p><p>因此，会话 B 看到的结果里， 查计数值和“最近 100 条记录”看到的结果，逻辑上就是一致的。</p><h1 id="不同的-count-用法"><a href="#不同的-count-用法" class="headerlink" title="不同的 count 用法"></a>不同的 count 用法</h1><p>在前面文章的评论区，有同学留言问到：在 <code>select count(?) from t</code> 这样的查询语句里面，<code>count(*)</code>、<code>count(主键 id)</code>、<code>count(字段)</code> 和 <code>count(1)</code> 等不同用法的性能，有哪些差别。今天谈到了 count(*) 的性能问题，我就借此机会和你详细说明一下这几种用法的性能差别。</p><p>需要注意的是，下面的讨论还是基于 InnoDB 引擎的。</p><p>这里，首先你要弄清楚 count() 的语义。count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。</p><p>所以，count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</p><p>至于分析性能差别的时候，你可以记住这么几个原则：</p><ol><li>server 层要什么就给什么；</li><li>InnoDB 只给必要的值；</li><li>现在的优化器只优化了 count(*) 的语义为“取行数”，其他“显而易见”的优化并没有做。</li></ol><p>这是什么意思呢？接下来，我们就一个个地来看看。</p><p><strong>对于 count(主键 id) 来说</strong>，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p><p><strong>对于 count(1) 来说</strong>，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p><p>单看这两个用法的差别的话，你能对比出来，count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</p><p><strong>对于 count(字段) 来说</strong>：</p><ol><li>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</li><li>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</li></ol><p>也就是前面的第一条原则，server 层要什么字段，InnoDB 就返回什么字段。</p><p><strong>但是 count(*) 是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</p><p>看到这里，你一定会说，优化器就不能自己判断一下吗，主键 id 肯定非空啊，为什么不能按照 count(*) 来处理，多么简单的优化啊。</p><p>当然，MySQL 专门针对这个语句进行优化，也不是不可以。但是这种需要专门优化的情况太多了，而且 MySQL 已经优化过 count(*) 了，你直接使用这种用法就可以了。</p><p>所以结论是：按照效率排序的话，count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)，所以我建议你，尽量使用 <code>count(*)</code>。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我和你聊了聊 MySQL 中获得表行数的两种方法。我们提到了在不同引擎中 count(*) 的实现方式是不一样的，也分析了用缓存系统来存储计数值存在的问题。</p><p>其实，把计数放在 Redis 里面，不能够保证计数和 MySQL 表里的数据精确一致的原因，是<strong>这两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。</strong>而把计数值也放在 MySQL 中，就解决了一致性视图的问题。</p><p>InnoDB 引擎支持事务，我们利用好事务的原子性和隔离性，就可以简化在业务开发时的逻辑。这也是 InnoDB 引擎备受青睐的原因之一。</p><p>最后，又到了今天的思考题时间了。</p><p>在刚刚讨论的方案中，我们用了事务来确保计数准确。由于事务可以保证中间结果不被别的事务读到，因此修改计数值和插入新记录的顺序是不影响逻辑结果的。但是，从并发系统性能的角度考虑，你觉得在这个事务序列里，应该先插入操作记录，还是应该先更新计数表呢？</p><p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾给出我的参考答案。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期我给你留的问题是，什么时候使用 alter table t engine=InnoDB 会让一个表占用的空间反而变大。</p><p>在这篇文章的评论区里面，大家都提到了一个点，就是这个表，本身就已经没有空洞的了，比如说刚刚做过一次重建表操作。</p><p>在 DDL 期间，如果刚好有外部的 DML 在执行，这期间可能会引入一些新的空洞。</p><p>@飞翔 提到了一个更深刻的机制，是我们在文章中没说的。在重建表的时候，InnoDB 不会把整张表占满，每个页留了 1/16 给后续的更新用。也就是说，其实重建表之后不是“最”紧凑的。</p><p>假如是这么一个过程：</p><ol><li>将表 t 重建一次；</li><li>插入一部分数据，但是插入的这些数据，用掉了一部分的预留空间；</li><li>这种情况下，再重建一次表 t，就可能会出现问题中的现象。</li></ol><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../13">上一篇</a>    13 | 为什么表数据删掉一半，表文件大小不变？</p><p><a href="../15">下一篇</a>    15 | 答疑文章（一）：日志和索引相关问题</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13 | 为什么表数据删掉一半，表文件大小不变？</title>
      <link href="/mysql45/13/"/>
      <url>/mysql45/13/</url>
      
        <content type="html"><![CDATA[<h1 id="13-为什么表数据删掉一半，表文件大小不变？"><a href="#13-为什么表数据删掉一半，表文件大小不变？" class="headerlink" title="13 | 为什么表数据删掉一半，表文件大小不变？"></a>13 | 为什么表数据删掉一半，表文件大小不变？</h1><p><font color="gray">2018-12-12 林晓斌</font></p><p><img src="../../images/mysql45/13/13.jpg"></p><p>经常会有同学来问我，我的数据库占用空间太大，我把一个最大的表删掉了一半的数据，怎么表文件的大小还是没变？</p><p>那么今天，我就和你聊聊数据库表的空间回收，看看如何解决这个问题。</p><p>这里，我们还是针对 MySQL 中应用最广泛的 InnoDB 引擎展开讨论。一个 InnoDB 表包含两部分，即：表结构定义和数据。在 MySQL 8.0 版本以前，表结构是存在以 <code>.frm</code> 为后缀的文件里。而 MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中了。因为表结构定义占用的空间很小，所以我们今天主要讨论的是表数据。</p><p>接下来，我会先和你说明为什么简单地删除表数据达不到表空间回收的效果，然后再和你介绍正确回收空间的方法。</p><h1 id="参数-innodb-file-per-table"><a href="#参数-innodb-file-per-table" class="headerlink" title="参数 innodb_file_per_table"></a>参数 innodb_file_per_table</h1><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 <code>innodb_file_per_table</code> 控制的：</p><ol><li>这个参数设置为 <code>OFF</code> 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li><li>这个参数设置为 <code>ON</code> 表示的是，每个 InnoDB 表数据存储在一个以 <code>.ibd</code> 为后缀的文件中。</li></ol><p>从 MySQL 5.6.6 版本开始，它的默认值就是 <code>ON</code> 了。</p><p>我建议你不论使用 MySQL 的哪个版本，都将这个值设置为 ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 <code>drop table</code> 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p><p>所以，<strong>将 innodb_file_per_table 设置为 ON，是推荐做法，我们接下来的讨论都是基于这个设置展开的。</strong></p><p>我们在删除整个表的时候，可以使用 <code>drop table</code> 命令回收表空间。但是，我们遇到的更多的删除数据的场景是删除某些行，这时就遇到了我们文章开头的问题：表中的数据被删除了，但是表空间却没有被回收。</p><p>我们要彻底搞明白这个问题的话，就要从数据删除流程说起了。</p><h1 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h1><p>我们先再来看一下 InnoDB 中一个索引的示意图。在前面<a href="../4">第 4</a>和<a href="../5">第 5</a>篇文章中，我和你介绍索引时曾经提到过，InnoDB 里的数据都是用 B+ 树的结构组织的。</p><div style="text-align:center"><img src="../../images/mysql45/13/图%201%20B+%20树索引示意图.png"><p><font color="gray">图 1 B+ 树索引示意图</font></p></div><p>假设，我们要删掉 R4 这个记录，InnoDB 引擎只会把 R4 这个记录标记为删除。如果之后要再插入一个 ID 在 300 和 600 之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</p><p>现在，你已经知道了 InnoDB 的数据是按页存储的，那么如果我们删掉了一个数据页上的所有记录，会怎么样？</p><p>答案是，整个数据页就可以被复用了。</p><p>但是，<strong>数据页的复用跟记录的复用是不同的。</strong></p><p>记录的复用，只限于符合范围条件的数据。比如上面的这个例子，R4 这条记录被删除后，如果插入一个 ID 是 400 的行，可以直接复用这个空间。但如果插入的是一个 ID 是 800 的行，就不能复用这个位置了。</p><p>而当整个页从 B+ 树里面摘掉以后，可以复用到任何位置。以图 1 为例，如果将数据页 page A 上的所有记录删除以后，page A 会被标记为可复用。这时候如果要插入一条 ID=50 的记录需要使用新页的时候，page A 是可以被复用的。</p><p>如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。</p><p>进一步地，如果我们用 delete 命令把整个表的数据删除呢？结果就是，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。</p><p>你现在知道了，delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过 delete 命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。</p><p>实际上，<strong>不止是删除数据会造成空洞，插入数据也会。</strong></p><p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</p><p>假设图 1 中 page A 已经满了，这时我要再插入一行数据，会怎样呢？</p><div style="text-align:center"><img src="../../images/mysql45/13/图%202%20插入数据导致页分裂.png"><p><font color="gray">图 2 插入数据导致页分裂</font></p></div><p>可以看到，由于 page A 满了，再插入一个 ID 是 550 的数据时，就不得不再申请一个新的页面 page B 来保存数据了。页分裂完成后，page A 的末尾就留下了空洞（注意：实际上，可能不止 1 个记录的位置是空洞）。</p><p>另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的。</p><p>也就是说，经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。</p><p>而重建表，就可以达到这样的目的。</p><h1 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h1><p>试想一下，如果你现在有一个表 A，需要做空间收缩，为了把表中存在的空洞去掉，你可以怎么做呢？</p><p>你可以新建一个与表 A 结构相同的表 B，然后按照主键 ID 递增的顺序，把数据一行一行地从表 A 里读出来再插入到表 B 中。</p><p>由于表 B 是新建的表，所以表 A 主键索引上的空洞，在表 B 中就都不存在了。显然地，表 B 的主键索引更紧凑，数据页的利用率也更高。如果我们把表 B 作为临时表，数据从表 A 导入表 B 的操作完成后，用表 B 替换 A，从效果上看，就起到了收缩表 A 空间的作用。</p><p>这里，你可以使用 <code>alter table A engine=InnoDB</code> 命令来重建表。在 MySQL 5.5 版本之前，这个命令的执行流程跟我们前面描述的差不多，区别只是这个临时表 B 不需要你自己创建，MySQL 会自动完成转存数据、交换表名、删除旧表的操作。</p><div style="text-align:center"><img src="../../images/mysql45/13/图%203%20改锁表%20DDL.png"><p><font color="gray">图 3 改锁表 DDL</font></p></div><p>显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表 A 的话，就会造成数据丢失。因此，在整个 DDL 过程中，表 A 中不能有更新。也就是说，这个 DDL 不是 Online 的。</p><p>而在<strong>MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化。</strong></p><p>我给你简单描述一下引入了 Online DDL 之后，重建表的流程：</p><ol><li>建立一个临时文件，扫描表 A 主键的所有数据页；</li><li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</li><li>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态；</li><li>用临时文件替换表 A 的数据文件。</li></ol><div style="text-align:center"><img src="../../images/mysql45/13/图%204%20Online%20DDL.png"><p><font color="gray">图 4 Online DDL</font></p></div><p>可以看到，与图 3 过程的不同之处在于，由于日志文件记录和重放操作这个功能的存在，这个方案在重建表的过程中，允许对表 A 做增删改操作。这也就是 Online DDL 名字的来源。</p><p>我记得有同学在第 6 篇讲表锁的文章<a href="../6">《全局锁和表锁 ：给表加个字段怎么索这么多阻碍？》</a>的评论区留言说，DDL 之前是要拿 MDL 写锁的，这样还能叫 Online DDL 吗？</p><p>确实，图 4 的流程中，alter 语句在启动的时候需要获取 MDL 写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。</p><p>为什么要退化呢？为了实现 Online，MDL 读锁不会阻塞增删改操作。</p><p>那为什么不干脆直接解锁呢？为了保护自己，禁止其他线程对这个表同时做 DDL。</p><p>而对于一个大表来说，Online DDL 最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个 DDL 过程来说，锁的时间非常短。对业务来说，就可以认为是 Online 的。</p><p>需要补充说明的是，上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很消耗 IO 和 CPU 资源的。因此，如果是线上服务，你要很小心地控制操作时间。如果想要比较安全的操作的话，我推荐你使用 GitHub 开源的 gh-ost 来做。</p><h1 id="Online-和-inplace"><a href="#Online-和-inplace" class="headerlink" title="Online 和 inplace"></a>Online 和 inplace</h1><p>说到 Online，我还要再和你澄清一下它和另一个跟 DDL 有关的、容易混淆的概念 inplace 的区别。</p><p>你可能注意到了，在图 3 中，我们把表 A 中的数据导出来的存放位置叫作 tmp_table。这是一个临时表，是在 server 层创建的。</p><p>在图 4 中，根据表 A 重建出来的数据是放在“tmp_file”里的，这个临时文件是 InnoDB 在内部创建出来的。整个 DDL 过程都在 InnoDB 内部完成。对于 server 层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。</p><p>所以，我现在问你，如果你有一个 1TB 的表，现在磁盘间是 1.2TB，能不能做一个 inplace 的 DDL 呢？</p><p>答案是不能。因为，tmp_file 也是要占用临时空间的。</p><p>我们重建表的这个语句 <code>alter table t engine=InnoDB</code>，其实隐含的意思是：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">alter table t engine=innodb,ALGORITHM=inplace;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>跟 inplace 对应的就是拷贝表的方式了，用法是：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">alter table t engine=innodb,ALGORITHM=copy;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当你使用 ALGORITHM=copy 的时候，表示的是强制拷贝表，对应的流程就是图 3 的操作过程。</p><p>但我这样说你可能会觉得，inplace 跟 Online 是不是就是一个意思？</p><p>其实不是的，只是在重建表这个逻辑中刚好是这样而已。</p><p>比如，如果我要给 InnoDB 表的一个字段加全文索引，写法是：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">alter table t add FULLTEXT(field_name);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个过程是 inplace 的，但会阻塞增删改操作，是非 Online 的。</p><p>如果说这两个逻辑之间的关系是什么的话，可以概括为：</p><ol><li>DDL 过程如果是 Online 的，就一定是 inplace 的；</li><li>反过来未必，也就是说 inplace 的 DDL，有可能不是 Online 的。截止到 MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引 (SPATIAL index) 就属于这种情况。</li></ol><p>最后，我们再延伸一下。</p><p>在第 10 篇文章<a href="../10">《MySQL 为什么有时候会选错索引》</a>的评论区中，有同学问到使用 <code>optimize table</code>、<code>analyze table</code> 和 <code>alter table</code> 这三种方式重建表的区别。这里，我顺便再简单和你解释一下。</p><ul><li>从 MySQL 5.6 版本开始，alter table t engine = InnoDB（也就是 recreate）默认的就是上面图 4 的流程了；</li><li>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；</li><li>optimize table t 等于 recreate+analyze。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我和你讨论了数据库中收缩表空间的方法。</p><p>现在你已经知道了，如果要收缩一个表，只是 delete 掉表里面不用的数据的话，表文件的大小是不会变的，你还要通过 alter table 命令重建表，才能达到表文件变小的目的。我跟你介绍了重建表的两种实现方式，Online DDL 的方式是可以考虑在业务低峰期使用的，而 MySQL 5.5 及之前的版本，这个命令是会阻塞 DML 的，这个你需要特别小心。</p><p>最后，又到了我们的课后问题时间。</p><p>假设现在有人碰到了一个“想要收缩表空间，结果适得其反”的情况，看上去是这样的：</p><ol><li>一个表 t 文件大小为 1TB；</li><li>对这个表执行 alter table t engine=InnoDB；</li><li>发现执行完成后，空间不仅没变小，还稍微大了一点儿，比如变成了 1.01TB。</li></ol><p>你觉得可能是什么原因呢 ？</p><p>你可以把你觉得可能的原因写在留言区里，我会在下一篇文章的末尾把大家描述的合理的原因都列出来，以后其他同学就不用掉到这样的坑里了。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>在上期文章最后，我留给你的问题是，如果一个高配的机器，redo log 设置太小，会发生什么情况。</p><p>每次事务提交都要写 redo log，如果设置太小，很快就会被写满，也就是下面这个图的状态，这个“环”将很快被写满，write pos 一直追着 CP。</p><p><img src="../../images/mysql45/12/%E5%9B%BE%202%20redo%20log%20%E7%8A%B6%E6%80%81%E5%9B%BE.jpg"></p><p>这时候系统不得不停止所有更新，去推进 checkpoint。</p><p>这时，你看到的现象就是<strong>磁盘压力很小，但是数据库出现间歇性的性能下跌。</strong></p><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../12">上一篇</a>    12 | 为什么我的MySQL会“抖”一下？</p><p><a href="../14">下一篇</a>    14 | count(*)这么慢，我该怎么办？</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12 | 为什么我的MySQL会“抖”一下？</title>
      <link href="/mysql45/12/"/>
      <url>/mysql45/12/</url>
      
        <content type="html"><![CDATA[<h1 id="12-为什么我的MySQL会“抖”一下？"><a href="#12-为什么我的MySQL会“抖”一下？" class="headerlink" title="12 | 为什么我的MySQL会“抖”一下？"></a>12 | 为什么我的MySQL会“抖”一下？</h1><p><font color="gray">2018-12-10 林晓斌</font></p><p><img src="../../images/mysql45/12/12.jpg"></p><p>平时的工作中，不知道你有没有遇到过这样的场景，一条 SQL 语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。</p><p>看上去，这就像是数据库“抖”了一下。今天，我们就一起来看一看这是什么原因。</p><h1 id="你的-SQL-语句为什么变“慢”了"><a href="#你的-SQL-语句为什么变“慢”了" class="headerlink" title="你的 SQL 语句为什么变“慢”了"></a>你的 SQL 语句为什么变“慢”了</h1><p>在前面第 2 篇文章<a href="../2">《日志系统：一条 SQL 更新语句是如何执行的？》</a>中，我为你介绍了 WAL 机制。现在你知道了，InnoDB 在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作 redo log（重做日志），也就是《孔乙己》里咸亨酒店掌柜用来记账的粉板，在更新内存写完 redo log 后，就返回给客户端，本次更新成功。</p><p>做下类比的话，掌柜记账的账本是数据文件，记账用的粉板是日志文件（redo log），掌柜的记忆就是内存。</p><p>掌柜总要找时间把账本更新一下，这对应的就是把内存里的数据写入磁盘的过程，术语就是 flush。在这个 flush 操作执行之前，孔乙己的赊账总额，其实跟掌柜手中账本里面的记录是不一致的。因为孔乙己今天的赊账金额还只在粉板上，而账本里的记录是老的，还没把今天的赊账算进去。</p><p><strong>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</strong>。</p><p>不论是脏页还是干净页，都在内存中。在这个例子里，内存对应的就是掌柜的记忆。</p><p>接下来，我们用一个示意图来展示一下“孔乙己赊账”的整个操作过程。假设原来孔乙己欠账 10 文，这次又要赊 9 文。</p><div style="text-align:center"><img src="../../images/mysql45/12/图%201%20“孔乙己赊账”更新和%20flush%20过程.jpg"><p><font color="gray">图 1 “孔乙己赊账”更新和 flush 过程</font></p></div><p>回到文章开头的问题，你不难想象，平时执行很快的更新操作，其实就是在写内存和日志，而 MySQL 偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。</p><p>那么，什么情况会引发数据库的 flush 过程呢？</p><p>我们还是继续用咸亨酒店掌柜的这个例子，想一想：掌柜在什么情况下会把粉板上的赊账记录改到账本上？</p><ul><li>第一种场景是，粉板满了，记不下了。这时候如果再有人来赊账，掌柜就只得放下手里的活儿，将粉板上的记录擦掉一些，留出空位以便继续记账。当然在擦掉之前，他必须先将正确的账目记录到账本中才行。<br>这个场景，对应的就是 InnoDB 的 redo log 写满了。这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写。我在第二讲画了一个 redo log 的示意图，这里我改成环形，便于大家理解。</li></ul><div style="text-align:center"><img src="../../images/mysql45/12/图%202%20redo%20log%20状态图.jpg"><p><font color="gray">图 2 redo log 状态图</font></p></div><p>checkpoint 可不是随便往前修改一下位置就可以的。比如图 2 中，把 checkpoint 位置从 CP 推进到 CP’，就需要将两个点之间的日志（浅绿色部分），对应的所有脏页都 flush 到磁盘上。之后，图中从 write pos 到 CP’之间就是可以再写入的 redo log 的区域。</p><ul><li>第二种场景是，这一天生意太好，要记住的事情太多，掌柜发现自己快记不住了，赶紧找出账本把孔乙己这笔账先加进去。<br>这种场景，对应的就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。<br>你一定会说，这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据页，然后拿 redo log 出来应用不就行了？这里其实是从性能考虑的。如果刷脏页一定会写盘，就保证了每个数据页有两种状态：<ul><li>一种是内存里存在，内存里就肯定是正确的结果，直接返回；</li><li>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。<br>这样的效率最高。</li></ul></li><li>第三种场景是，生意不忙的时候，或者打烊之后。这时候柜台没事，掌柜闲着也是闲着，不如更新账本。<br>这种场景，对应的就是 MySQL 认为系统“空闲”的时候。当然，MySQL“这家酒店”的生意好起来可是会很快就能把粉板记满的，所以“掌柜”要合理地安排时间，即使是“生意好”的时候，也要见缝插针地找时间，只要有机会就刷一点“脏页”。</li><li>第四种场景是，年底了咸亨酒店要关门几天，需要把账结清一下。这时候掌柜要把所有账都记到账本上，这样过完年重新开张的时候，就能就着账本明确账目情况了。<br>这种场景，对应的就是 MySQL 正常关闭的情况。这时候，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</li></ul><p>接下来，<strong>你可以分析一下上面四种场景对性能的影响。</strong></p><p>其中，第三种情况是属于 MySQL 空闲时的操作，这时系统没什么压力，而第四种场景是数据库本来就要关闭了。这两种情况下，你不会太关注“性能”问题。所以这里，我们主要来分析一下前两种场景下的性能问题。</p><p>第一种是“redo log 写满了，要 flush 脏页”，这种情况是 InnoDB 要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为 0。</p><p>第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。<strong>InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</strong></p><ul><li>第一种是，还没有使用的；</li><li>第二种是，使用了并且是干净页；</li><li>第三种是，使用了并且是脏页。</li></ul><p>InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。</p><p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p><p>所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：</p><ol><li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li><li>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。</li></ol><p>所以，InnoDB 需要有控制脏页比例的机制，来尽量避免上面的这两种情况。</p><h1 id="InnoDB-刷脏页的控制策略"><a href="#InnoDB-刷脏页的控制策略" class="headerlink" title="InnoDB 刷脏页的控制策略"></a>InnoDB 刷脏页的控制策略</h1><p>接下来，我就来和你说说 InnoDB 脏页的控制策略，以及和这些策略相关的参数。</p><p>首先，你要正确地告诉 InnoDB 所在主机的 IO 能力，这样 InnoDB 才能知道需要全力刷脏页的时候，可以刷多快。</p><p>这就要用到 <code>innodb_io_capacity</code> 这个参数了，它会告诉 InnoDB 你的磁盘能力。这个值我建议你设置成磁盘的 IOPS。磁盘的 IOPS 可以通过 fio 这个工具来测试，下面的语句是我用来测试磁盘随机读写的命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">fio -filename<span class="token operator">=</span><span class="token variable">$filename</span> -direct<span class="token operator">=</span><span class="token number">1</span> -iodepth <span class="token number">1</span> -thread -rw<span class="token operator">=</span>randrw -ioengine<span class="token operator">=</span>psync -bs<span class="token operator">=</span>16k -size<span class="token operator">=</span>500M -numjobs<span class="token operator">=</span><span class="token number">10</span> -runtime<span class="token operator">=</span><span class="token number">10</span> -group_reporting -name<span class="token operator">=</span>mytest <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其实，因为没能正确地设置 <code>innodb_io_capacity</code> 参数，而导致的性能问题也比比皆是。之前，就曾有其他公司的开发负责人找我看一个库的性能问题，说 MySQL 的写入速度很慢，TPS 很低，但是数据库主机的 IO 压力并不大。经过一番排查，发现罪魁祸首就是这个参数的设置出了问题。</p><p>他的主机磁盘用的是 SSD，但是 <code>innodb_io_capacity</code> 的值设置的是 <code>300</code>。于是，InnoDB 认为这个系统的能力就这么差，所以刷脏页刷得特别慢，甚至比脏页生成的速度还慢，这样就造成了脏页累积，影响了查询和更新性能。</p><p>虽然我们现在已经定义了“全力刷脏页”的行为，但平时总不能一直是全力刷吧？毕竟磁盘能力不能只用来刷脏页，还需要服务用户请求。所以接下来，我们就一起看看 InnoDB 怎么控制引擎按照“全力”的百分比来刷脏页。</p><p>根据我前面提到的知识点，试想一下，<strong>如果你来设计策略控制刷脏页的速度，会参考哪些因素呢？</strong></p><p>这个问题可以这么想，如果刷太慢，会出现什么情况？首先是内存脏页太多，其次是 redo log 写满。</p><p>所以，InnoDB 的刷盘速度就是要参考这两个因素：一个是脏页比例，一个是 redo log 写盘速度。</p><p>InnoDB 会根据这两个因素先单独算出两个数字。</p><p>参数 <code>innodb_max_dirty_pages_pct</code> 是脏页比例上限，默认值是 <code>75%</code>。InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字，计算这个数字的伪代码类似这样：</p><pre class="line-numbers language-none"><code class="language-none">F1(M){  if M&gt;=innodb_max_dirty_pages_pct then      return 100;  return 100*M/innodb_max_dirty_pages_pct;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，我们假设为 N。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。F2(N) 算法比较复杂，你只要知道 N 越大，算出来的值越大就好了。</p><p>然后，<strong>根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，之后引擎就可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度。</strong></p><p>上述的计算流程比较抽象，不容易理解，所以我画了一个简单的流程图。图中的 F1、F2 就是上面我们通过脏页比例和 redo log 写入速度算出来的两个值。</p><div style="text-align:center"><img src="../../images/mysql45/12/图%203%20InnoDB%20刷脏页速度策略.png"><p><font color="gray">图 3 InnoDB 刷脏页速度策略</font></p></div><p>现在你知道了，InnoDB 会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用 IO 资源并可能影响到了你的更新语句，都可能是造成你从业务端感知到 MySQL“抖”了一下的原因。</p><p>要尽量避免这种情况，你就要合理地设置 <code>innodb_io_capacity</code> 的值，并且**平时要多关注脏页比例，不要让它经常接近 75%**。</p><p>其中，脏页比例是通过 <code>Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total</code> 得到的，具体的命令参考下面的代码：<del><font color="red">下面的命令没看懂，演示也报错</font></del></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';select @a/@b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来，我们再看一个有趣的策略。</p><p>一旦一个查询请求需要在执行过程中先 flush 掉一个脏页时，这个查询就可能要比平时慢了。而 MySQL 中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。</p><p>在 InnoDB 中，<code>innodb_flush_neighbors</code> 参数就是用来控制这个行为的，值为 <code>1</code> 的时候会有上述的“连坐”机制，值为 <code>0</code> 时表示不找邻居，自己刷自己的。</p><p>找“邻居”这个优化在机械硬盘时代是很有意义的，可以减少很多随机 IO。机械硬盘的随机 IOPS 一般只有几百，相同的逻辑操作减少随机 IO 就意味着系统性能的大幅度提升。</p><p>而如果使用的是 SSD 这类 IOPS 比较高的设备的话，我就建议你把 <code>innodb_flush_neighbors</code> 的值设置成 <code>0</code>。因为这时候 IOPS 往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操作，减少 SQL 语句响应时间。</p><p>在 MySQL 8.0 中，<code>innodb_flush_neighbors</code> 参数的默认值已经是 <code>0</code> 了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我延续第 2 篇中介绍的 WAL 的概念，和你解释了这个机制后续需要的刷脏页操作和执行时机。利用 WAL 技术，数据库将随机写转换成了顺序写，大大提升了数据库的性能。</p><p>但是，由此也带来了内存脏页的问题。脏页会被后台线程自动 flush，也会由于数据页淘汰而触发 flush，而刷脏页的过程由于会占用资源，可能会让你的更新和查询语句的响应时间长一些。在文章里，我也给你介绍了控制刷脏页的方法和对应的监控方式。</p><p>文章最后，我给你留下一个思考题吧。</p><p>一个内存配置为 128GB、innodb_io_capacity 设置为 20000 的大规格实例，正常会建议你将 redo log 设置成 4 个 1GB 的文件。</p><p>但如果你在配置的时候不慎将 redo log 设置成了 1 个 100M 的文件，会发生什么情况呢？又为什么会出现这样的情况呢？</p><p>你可以把你的分析结论写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期我留给你的问题是，给一个学号字段创建索引，有哪些方法。</p><p>由于这个学号的规则，无论是正向还是反向的前缀索引，重复度都比较高。因为维护的只是一个学校的，因此前面 6 位（其中，前三位是所在城市编号、第四到第六位是学校编号）其实是固定的，邮箱后缀都是 @gamil.com，因此可以只存入学年份加顺序编号，它们的长度是 9 位。</p><p>而其实在此基础上，可以用数字类型来存这 9 位数字。比如 201100001，这样只需要占 4 个字节。其实这个就是一种 hash，只是它用了最简单的转换规则：字符串转数字的规则，而刚好我们设定的这个背景，可以保证这个转换后结果的唯一性。</p><p>评论区中，也有其他一些很不错的见解。</p><p>评论用户 @封建的风 说，一个学校的总人数这种数据量，50 年才 100 万学生，这个表肯定是小表。为了业务简单，直接存原来的字符串。这个答复里面包含了“优化成本和收益”的思想，我觉得值得 at 出来。</p><p>@小潘 同学提了另外一个极致的方向。如果碰到表数据量特别大的场景，通过这种方式的收益是很不错的。</p><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../11">上一篇</a>    11 | 怎么给字符串字段加索引？</p><p><a href="../13">下一篇</a>    13 | 为什么表数据删掉一半，表文件大小不变？</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11 | 怎么给字符串字段加索引？</title>
      <link href="/mysql45/11/"/>
      <url>/mysql45/11/</url>
      
        <content type="html"><![CDATA[<h1 id="11-怎么给字符串字段加索引？"><a href="#11-怎么给字符串字段加索引？" class="headerlink" title="11 | 怎么给字符串字段加索引？"></a>11 | 怎么给字符串字段加索引？</h1><p><font color="gray">2018-12-07 林晓斌</font></p><p><img src="../../images/mysql45/10/10.jpg"></p><p>现在，几乎所有的系统都支持邮箱登录，如何在邮箱这样的字段上建立合理的索引，是我们今天要讨论的问题。</p><p>假设，你现在维护一个支持邮箱登录的系统，用户表是这么定义的：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create table SUser(  ID bigint unsigned primary key,  email varchar(64),   ... )engine=innodb; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select f1, f2 from SUser where email='xxx';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从第 4 和第 5 篇讲解索引的文章中，我们可以知道，如果 email 这个字段上没有索引，那么这个语句就只能做全表扫描。</p><p>同时，MySQL 是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</p><p>比如，这两个在 email 字段上创建索引的语句：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; alter table SUser add index index1(email);或mysql&gt; alter table SUser add index index2(email(6));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一个语句创建的 index1 索引里面，包含了每个记录的整个字符串；而第二个语句创建的 index2 索引里面，对于每个记录都是只取前 6 个字节。</p><p>那么，这两种不同的定义在数据结构和存储上有什么区别呢？如图 2 和 3 所示，就是这两个索引的示意图。</p><div style="text-align:center"><img src="../../images/mysql45/11/图%201%20email%20索引结构.jpg"><p><font color="gray">图 1 email 索引结构</font></p></div><div style="text-align:center"><img src="../../images/mysql45/11/图%202%20email(6)%20索引结构.jpg"><p><font color="gray">图 2 email(6) 索引结构</font></p></div><p>从图中你可以看到，由于 email(6) 这个索引结构中每个邮箱字段都只取前 6 个字节（即：zhangs），所以占用的空间会更小，这就是使用前缀索引的优势。</p><p>但，这同时带来的损失是，可能会增加额外的记录扫描次数。</p><p>接下来，我们再看看下面这个语句，在这两个索引定义下分别是怎么执行的。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select id,name,email from SUser where email='zhangssxyz@xxx.com';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>如果使用的是 index1</strong>（即 email 整个字符串的索引结构），执行顺序是这样的：</p><ol><li>从 index1 索引树找到满足索引值是 <code>'zhangssxyz@xxx.com'</code> 的这条记录，取得 ID2 的值；</li><li>到主键上查到主键值是 ID2 的行，判断 email 的值是正确的，将这行记录加入结果集；</li><li>取 index1 索引树上刚刚查到的位置的下一条记录，发现已经不满足 <code>email='zhangssxyz@xxx.com'</code> 的条件了，循环结束。</li></ol><p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p><p><strong>如果使用的是 index2</strong>（即 email(6) 索引结构），执行顺序是这样的：</p><ol><li>从 index2 索引树找到满足索引值是 <code>'zhangs'</code> 的记录，找到的第一个是 ID1；</li><li>到主键上查到主键值是 ID1 的行，判断出 email 的值不是 <code>'zhangssxyz@xxx.com'</code>，这行记录丢弃；</li><li>取 index2 上刚刚查到的位置的下一条记录，发现仍然是 <code>'zhangs'</code>，取出 ID2，再到 ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li><li>重复上一步，直到在 idxe2 上取到的值不是 <code>'zhangs'</code> 时，循环结束。</li></ol><p>在这个过程中，要回主键索引取 4 次数据，也就是扫描了 4 行。</p><p>通过这个对比，你很容易就可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多。</p><p>但是，对于这个查询语句来说，如果你定义的 index2 不是 email(6) 而是 email(7)，也就是说取 email 字段的前 7 个字节来构建索引的话，即满足前缀 <code>'zhangss'</code> 的记录只有一个，也能够直接查到 ID2，只扫描一行就结束了。</p><p>也就是说<strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p><p>于是，你就有个问题：当要给字符串创建前缀索引时，有什么方法能够确定我应该使用多长的前缀呢？</p><p>实际上，我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</p><p>首先，你可以使用下面这个语句，算出这个列上有多少个不同的值：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select count(distinct email) as L from SUser;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下 4~7 个字节的前缀索引，可以用这个语句：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select   count(distinct left(email,4)）as L4,  count(distinct left(email,5)）as L5,  count(distinct left(email,6)）as L6,  count(distinct left(email,7)）as L7,from SUser;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值，假设这里 L6、L7 都满足，你就可以选择前缀长度为 6。</p><h1 id="前缀索引对覆盖索引的影响"><a href="#前缀索引对覆盖索引的影响" class="headerlink" title="前缀索引对覆盖索引的影响"></a>前缀索引对覆盖索引的影响</h1><p>前面我们说了使用前缀索引可能会增加扫描行数，这会影响到性能。其实，前缀索引的影响不止如此，我们再看一下另外一个场景。</p><p>你先来看看这个 SQL 语句：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select id,email from SUser where email='zhangssxyz@xxx.com';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与前面例子中的 SQL 语句</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select id,name,email from SUser where email='zhangssxyz@xxx.com';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>相比，这个语句只要求返回 id 和 email 字段。</p><p>所以，如果使用 index1（即 email 整个字符串的索引结构）的话，可以利用覆盖索引，从 index1 查到结果后直接就返回了，不需要回到 ID 索引再去查一次。而如果使用 index2（即 email(6) 索引结构）的话，就不得不回到 ID 索引再去判断 email 字段的值。</p><p>即使你将 index2 的定义修改为 email(18) 的前缀索引，这时候虽然 index2 已经包含了所有的信息，但 InnoDB 还是要回到 id 索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</p><p>也就是说，使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p><h1 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h1><p>对于类似于邮箱这样的字段来说，使用前缀索引的效果可能还不错。但是，遇到前缀的区分度不够好的情况时，我们要怎么办呢？</p><p>比如，我们国家的身份证号，一共 18 位，其中前 6 位是地址码，所以同一个县的人的身份证号前 6 位一般会是相同的。</p><p>假设你维护的数据库是一个市的公民信息系统，这时候如果对身份证号做长度为 6 的前缀索引的话，这个索引的区分度就非常低了。</p><p>按照我们前面说的方法，可能你需要创建长度为 12 以上的前缀索引，才能够满足区分度要求。</p><p>但是，索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。</p><p>那么，如果我们能够确定业务需求里面只有按照身份证进行等值查询的需求，还有没有别的处理方法呢？这种方法，既可以占用更小的空间，也能达到相同的查询效率。</p><p>答案是，有的。</p><p><strong>第一种方式是使用倒序存储。</strong>如果你存储身份证号的时候把它倒过来存，每次查询的时候，你可以这么写：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select field_list from t where id_card = reverse('input_id_card_string');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于身份证号的最后 6 位没有地址码这样的重复逻辑，所以最后这 6 位很可能就提供了足够的区分度。当然了，实践中你不要忘记使用 count(distinct) 方法去做个验证。</p><p><strong>第二种方式是使用 hash 字段。</strong>你可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后每次插入新记录的时候，都同时用 <code>crc32()</code> 这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过 crc32() 函数得到的结果可能是相同的，所以你的查询语句 where 部分要判断 id_card 的值是否精确相同。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select field_list from t where id_card_crc=crc32('input_id_card_string') and id_card='input_id_card_string'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，索引的长度变成了 4 个字节，比原来小了很多。</p><p>接下来，我们再一起看看<strong>使用倒序存储和使用 hash 字段这两种方法的异同点。</strong></p><p>首先，它们的相同点是，都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在 [ID_X, ID_Y] 的所有市民了。同样地，hash 字段的方式也只能支持等值查询。</p><p>它们的区别，主要体现在以下三个方面：</p><ol><li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而 hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。</li><li>在 CPU 消耗方面，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些。</li><li>从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在今天这篇文章中，我跟你聊了聊字符串字段创建索引的场景。我们来回顾一下，你可以使用的方式有：</p><ol><li>直接创建完整索引，这样可能比较占用空间；</li><li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</li><li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li><li>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li></ol><p>在实际应用中，你要根据业务字段的特点选择使用哪种方式。</p><p>好了，又到了最后的问题时间。</p><p>如果你在维护一个学校的学生信息数据库，学生登录名的统一格式是 “学号 @gmail.com”, 而学号的规则是：十五位的数字，其中前三位是所在城市编号、第四到第六位是学校编号、第七位到第十位是入学年份、最后五位是顺序编号。</p><p>系统登录的时候都需要学生输入登录名和密码，验证正确后才能继续使用系统。就只考虑登录验证这个行为的话，你会怎么设计这个登录名的索引呢？</p><p>你可以把你的分析思路和设计结果写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上篇文章中的第一个例子，评论区有几位同学说没有复现，大家要检查一下隔离级别是不是 RR（Repeatable Read，可重复读），创建的表 t 是不是 InnoDB 引擎。我把复现过程做成了一个视频，供你参考。</p><video src="https://time.geekbang.org/column/article/71492" controls="controls">your browser does not support the video tag</video><p>在上一篇文章最后，我给你留的问题是，为什么经过这个操作序列，explain 的结果就不对了？这里，我来为你分析一下原因。</p><p>delete 语句删掉了所有的数据，然后再通过 call idata() 插入了 10 万行数据，看上去是覆盖了原来的 10 万行。</p><p>但是，session A 开启了事务并没有提交，所以之前插入的 10 万行数据是不能删除的。这样，之前的数据每一行数据都有两个版本，旧版本是 delete 之前的数据，新版本是标记为 deleted 的数据。</p><p>这样，索引 a 上的数据其实就有两份。</p><p>然后你会说，不对啊，主键上的数据也不能删，那没有使用 force index 的语句，使用 explain 命令看到的扫描行数为什么还是 100000 左右？（潜台词，如果这个也翻倍，也许优化器还会认为选字段 a 作为索引更合适）</p><p>是的，不过这个是主键，主键是直接按照表的行数来估计的。而表的行数，优化器直接用的是 <code>show table status</code> 的值。</p><p>这个值的计算方法，我会在后面有文章为你详细讲解。</p><p><img src="../../images/mysql45/11/status.png"></p><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../10">上一篇</a>    10 | MySQL为什么有时候会选错索引？</p><p><a href="../12">下一篇</a>    12 | 为什么我的MySQL会“抖”一下？</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10 | MySQL为什么有时候会选错索引？</title>
      <link href="/mysql45/10/"/>
      <url>/mysql45/10/</url>
      
        <content type="html"><![CDATA[<h1 id="10-MySQL为什么有时候会选错索引？"><a href="#10-MySQL为什么有时候会选错索引？" class="headerlink" title="10 | MySQL为什么有时候会选错索引？"></a>10 | MySQL为什么有时候会选错索引？</h1><p><font color="gray">2018-12-05 林晓斌</font></p><p><img src="../../images/mysql45/10/10.jpg"></p><p>前面我们介绍过索引，你已经知道了在 MySQL 中一张表其实是可以支持多个索引的。但是，你写 SQL 语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由 MySQL 来确定的。</p><p>不知道你有没有碰到过这种情况，一条本来可以执行得很快的语句，却由于 MySQL 选错了索引，而导致执行速度变得很慢？</p><p>我们一起来看一个例子吧。</p><p>我们先建一个简单的表，表里有 a、b 两个字段，并分别建上索引：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE `t` (  `id` int(11) NOT NULL,  `a` int(11) DEFAULT NULL,  `b` int(11) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `a` (`a`),  KEY `b` (`b`)) ENGINE=InnoDB;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，我们往表 t 中插入 10 万行记录，取值按整数递增，即：(1,1,1)，(2,2,2)，(3,3,3) 直到 (100000,100000,100000)。</p><p>我是用存储过程来插入数据的，这里我贴出来方便你复现：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">delimiter ;;create procedure idata()begin  declare i int;  set i=1;  while(i&lt;=100000)do    insert into t values(i, i, i);    set i=i+1;  end while;end;;delimiter ;call idata();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们分析一条 SQL 语句：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from t where a between 10000 and 20000;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你一定会说，这个语句还用分析吗，很简单呀，a 上有索引，肯定是要使用索引 a 的。</p><p>你说得没错，图 1 显示的就是使用 <code>explain</code> 命令看到的这条语句的执行情况。</p><div style="text-align:center"><img src="../../images/mysql45/10/图%201%20使用%20explain%20命令查看语句执行情况.png"><p><font color="gray">图 1 使用 explain 命令查看语句执行情况</font></p></div><p>从图 1 看上去，这条查询语句的执行也确实符合预期，key 这个字段值是 <code>a</code>，表示优化器选择了索引 a。</p><p>不过别急，这个案例不会这么简单。在我们已经准备好的包含了 10 万行数据的表上，我们再做如下操作。</p><div style="text-align:center"><img src="../../images/mysql45/10/图%202%20session%20A%20和%20session%20B%20的执行流程.png"><p><font color="gray">图 2 session A 和 session B 的执行流程</font></p></div><p>这里，session A 的操作你已经很熟悉了，它就是开启了一个事务。随后，session B 把数据都删除后，又调用了 idata 这个存储过程，插入了 10 万行数据。</p><p>这时候，session B 的查询语句 <code>select * from t where a between 10000 and 20000</code> 就不会再选择索引 a 了<del><font color="red">这里我实验多次，MySQL5.7.37似乎修复了这样一个bug</font></del>。我们可以通过慢查询日志（slow log）来查看一下具体的执行情况。</p><p>为了说明优化器选择的结果是否正确，我增加了一个对照，即：使用 <code>force index(a)</code> 来让优化器强制使用索引 a（这部分内容，我还会在这篇文章的后半部分中提到）。</p><p>下面的三条 SQL 语句，就是这个实验过程。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set long_query_time=0;select * from t where a between 10000 and 20000; /*Q1*/select * from t force index(a) where a between 10000 and 20000;/*Q2*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>第一句，是将慢查询日志的阈值设置为 0，表示这个线程接下来的语句都会被记录入慢查询日志中；</li><li>第二句，Q1 是 session B 原来的查询；</li><li>第三句，Q2 是加了 force index(a) 来和 session B 原来的查询语句执行情况对比。</li></ul><p>如图 3 所示是这三条 SQL 语句执行完成后的慢查询日志。</p><div style="text-align:center"><img src="../../images/mysql45/10/图%203%20slow%20log%20结果.png"><p><font color="gray">图 3 slow log 结果</font></p></div><p>可以看到，Q1 扫描了 10 万行，显然是走了全表扫描，执行时间是 40 毫秒。Q2 扫描了 10001 行，执行了 21 毫秒。也就是说，我们在没有使用 force index 的时候，MySQL 用错了索引，导致了更长的执行时间。</p><p>这个例子对应的是我们平常不断地删除历史数据和新增数据的场景。这时，MySQL 竟然会选错索引，是不是有点奇怪呢？今天，我们就从这个奇怪的结果说起吧。</p><h1 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h1><p>在第一篇文章中，我们就提到过，选择索引是优化器的工作。</p><p>而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。</p><p>当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</p><p>我们这个简单的查询语句并没有涉及到临时表和排序，所以 MySQL 选错索引肯定是在判断扫描行数的时候出问题了。</p><p>那么，问题就是：<strong>扫描行数是怎么判断的？</strong></p><p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。</p><p>这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</p><p>我们可以使用 <code>show index</code> 方法，看到一个索引的基数。如图 4 所示，就是表 t 的 show index 的结果 。虽然这个表的每一行的三个字段值都是一样的，但是在统计信息中，这三个索引的基数值并不同，而且其实都不准确。</p><div style="text-align:center"><img src="../../images/mysql45/10/图 4 表 t 的 show index 结果.png"><p><font color="gray">图 4 表 t 的 show index 结果</font></p></div><p>那么，<strong>MySQL 是怎样得到索引的基数的呢？</strong>这里，我给你简单介绍一下 MySQL 采样统计的方法。</p><p>为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。</p><p>采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p><p>而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。</p><p>在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 <code>innodb_stats_persistent</code> 的值来选择：</p><ul><li>设置为 <code>on</code> 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。</li><li>设置为 <code>off</code> 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。</li></ul><p>由于是采样统计，所以不管 N 是 20 还是 8，这个基数都是很容易不准的。</p><p>但，这还不是全部。</p><p>你可以从图 4 中看到，这次的索引统计值（cardinality 列）虽然不够精确，但大体上还是差不多的，选错索引一定还有别的原因。</p><p>其实索引统计只是一个输入，对于一个具体的语句来说，优化器还要判断，执行这个语句本身要扫描多少行。</p><p>接下来，我们再一起看看优化器预估的，这两个语句的扫描行数是多少。</p><div style="text-align:center"><img src="../../images/mysql45/10/图%205%20意外的%20explain%20结果.png"><p><font color="gray">图 5 意外的 explain 结果</font></p></div><p>rows 这个字段表示的是预计扫描行数。</p><p>其中，Q1 的结果还是符合预期的，rows 的值是 104620；但是 Q2 的 rows 值是 37116，偏差就大了。而图 1 中我们用 explain 命令看到的 rows 是只有 10001 行，是这个偏差误导了优化器的判断。</p><p>到这里，可能你的第一个疑问不是为什么不准，而是优化器为什么放着扫描 37000 行的执行计划不用，却选择了扫描行数是 100000 的执行计划呢？</p><p>这是因为，如果使用索引 a，每次从索引 a 上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的。</p><p>而如果选择扫描 10 万行，是直接在主键索引上扫描的，没有额外的代价。</p><p>优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。</p><p>使用普通索引需要把回表的代价算进去，在图 1 执行 explain 的时候，也考虑了这个策略的代价 ，但图 1 的选择是对的。也就是说，这个策略并没有问题。</p><p>所以冤有头债有主，MySQL 选错索引，这件事儿还得归咎到没能准确地判断出扫描行数。至于为什么会得到错误的扫描行数，这个原因就作为课后问题，留给你去分析了。</p><p>既然是统计信息不对，那就修正。<code>analyze table t</code> 命令，可以用来重新统计索引信息。我们来看一下执行效果。</p><div style="text-align:center"><img src="../../images/mysql45/10/图%206%20执行%20analyze%20table%20t%20命令恢复的%20explain%20结果.png"><p><font color="gray">图 6 执行 analyze table t 命令恢复的 explain 结果</font></p></div><p>这回对了。</p><p>所以在实践中，如果你发现 explain 的结果预估的 rows 值跟实际情况差距比较大，可以采用这个方法来处理。</p><p>其实，如果只是索引统计不准确，通过 analyze 命令可以解决很多问题，但是前面我们说了，优化器可不止是看扫描行数。</p><p>依然是基于这个表 t，我们看看另外一个语句：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从条件上看，这个查询没有符合条件的记录，因此会返回空集合。</p><p>在开始执行这条语句之前，你可以先设想一下，如果你来选择索引，会选择哪一个呢？</p><p>为了便于分析，我们先来看一下 a、b 这两个索引的结构图。</p><div style="text-align:center"><img src="../../images/mysql45/10/图%207%20a、b%20索引的结构图.png"><p><font color="gray">图 7 a、b 索引的结构图</font></p></div><p>如果使用索引 a 进行查询，那么就是扫描索引 a 的前 1000 个值，然后取到对应的 id，再到主键索引上去查出每一行，然后根据字段 b 来过滤。显然这样需要扫描 1000 行。</p><p>如果使用索引 b 进行查询，那么就是扫描索引 b 的最后 50001 个值，与上面的执行过程相同，也是需要回到主键索引上取值再判断，所以需要扫描 50001 行。</p><p>所以你一定会想，如果使用索引 a 的话，执行速度明显会快很多。那么，下面我们就来看看到底是不是这么一回事儿。</p><p>图 8 是执行 explain 的结果。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; explain select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><div style="text-align:center"><img src="../../images/mysql45/10/图%208%20使用%20explain%20方法查看执行计划%202.png"><p><font color="gray">图 8 使用 explain 方法查看执行计划 2</font></p></div><p>可以看到，返回结果中 key 字段显示，这次优化器选择了索引 b，而 rows 字段显示需要扫描的行数是 50198。</p><p>从这个结果中，你可以得到两个结论：</p><ol><li>扫描行数的估计值依然不准确；</li><li>这个例子里 MySQL 又选错了索引。</li></ol><h1 id="索引选择异常和处理"><a href="#索引选择异常和处理" class="headerlink" title="索引选择异常和处理"></a>索引选择异常和处理</h1><p>其实大多数时候优化器都能找到正确的索引，但偶尔你还是会碰到我们上面举例的这两种情况：原本可以执行得很快的 SQL 语句，执行速度却比你预期的慢很多，你应该怎么办呢？</p><p><strong>一种方法是，像我们第一个例子一样，采用 force index 强行选择一个索引。</strong>MySQL 会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果 force index 指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。</p><p>我们来看看第二个例子。刚开始分析时，我们认为选择索引 a 会更好。现在，我们就来看看执行效果：</p><div style="text-align:center"><img src="../../images/mysql45/10/图%209%20使用不同索引的语句执行耗时.png"><p><font color="gray">图 9 使用不同索引的语句执行耗时</font></p></div><p>可以看到，原本语句需要执行 2.23 秒，而当你使用 force index(a) 的时候，只用了 0.05 秒，比优化器的选择快了 40 多倍。</p><p>也就是说，优化器没有选择正确的索引，force index 起到了“矫正”的作用。</p><p>不过很多程序员不喜欢使用 force index，一来这么写不优美，二来如果索引改了名字，这个语句也得改，显得很麻烦。而且如果以后迁移到别的数据库的话，这个语法还可能会不兼容。</p><p>但其实使用 force index 最主要的问题还是变更的及时性。因为选错索引的情况还是比较少出现的，所以开发的时候通常不会先写上 force index。而是等到线上出现问题的时候，你才会再去修改 SQL 语句、加上 force index。但是修改之后还要测试和发布，对于生产系统来说，这个过程不够敏捷。</p><p>所以，数据库的问题最好还是在数据库内部来解决。那么，在数据库里面该怎样解决呢？</p><p>既然优化器放弃了使用索引 a，说明 a 还不够合适，所以<strong>第二种方法就是，我们可以考虑修改语句，引导 MySQL 使用我们期望的索引。</strong>比如，在这个例子里，显然把“<code>order by b limit 1</code>” 改成 “<code>order by b,a limit 1</code>” ，语义的逻辑是相同的。</p><p>我们来看看改之后的效果：</p><div style="text-align:center"><img src="../../images/mysql45/10/图%2010%20order%20by%20b,a%20limit%201%20执行结果.png"><p><font color="gray">图 10 order by b,a limit 1 执行结果</font></p></div><p>之前优化器选择使用索引 b，是因为它认为使用索引 b 可以避免排序（b 本身是索引，已经是有序的了，如果选择索引 b 的话，不需要再做排序，只需要遍历），所以即使扫描行数多，也判定为代价更小。</p><p>现在 order by b,a 这种写法，要求按照 b,a 排序，就意味着使用这两个索引都需要排序。因此，扫描行数成了影响决策的主要条件，于是此时优化器选了只需要扫描 1000 行的索引 a。</p><p>当然，这种修改并不是通用的优化手段，只是刚好在这个语句里面有 limit 1，因此如果有满足条件的记录， <code>order by b limit 1</code> 和 <code>order by b,a limit 1</code> 都会返回 b 是最小的那一行，逻辑上一致，才可以这么做。</p><p>如果你觉得修改语义这件事儿不太好，这里还有一种改法，图 11 是执行效果。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from  (select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 100)alias limit 1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><div style="text-align:center"><img src="../../images/mysql45/10/图%2011%20改写%20SQL%20的%20explain.png"><p><font color="gray">图 11 改写 SQL 的 explain</font></p></div><p>在这个例子里，我们用 limit 100 让优化器意识到，使用 b 索引代价是很高的。其实是我们根据数据特征诱导了一下优化器，也不具备通用性。</p><p><strong>第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</strong></p><p>不过，在这个例子中，我没有找到通过新增索引来改变优化器行为的方法。这种情况其实比较少，尤其是经过 DBA 索引优化过的库，再碰到这个 bug，找到一个更合适的索引一般比较难。</p><p>如果我说还有一个方法是删掉索引 b，你可能会觉得好笑。但实际上我碰到过两次这样的例子，最终是 DBA 跟业务开发沟通后，发现这个优化器错误选择的索引其实根本没有必要存在，于是就删掉了这个索引，优化器也就重新选择到了正确的索引。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天我们一起聊了聊索引统计的更新机制，并提到了优化器存在选错索引的可能性。</p><p>对于由于索引统计信息不准确导致的问题，你可以用 <code>analyze table</code> 来解决。</p><p>而对于其他优化器误判的情况，你可以在应用端用 <code>force index</code> 来强行指定索引，也可以通过修改语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题。</p><p>你可能会说，今天这篇文章后面的几个例子，怎么都没有展开说明其原理。我要告诉你的是，今天的话题，我们面对的是 MySQL 的 bug，每一个展开都必须深入到一行行代码去量化，实在不是我们在这里应该做的事情。</p><p>所以，我把我用过的解决方法跟你分享，希望你在碰到类似情况的时候，能够有一些思路。</p><p>你平时在处理 MySQL 优化器 bug 的时候有什么别的方法，也发到评论区分享一下吧。</p><p>最后，我给你留下一个思考题。前面我们在构造第一个例子的过程中，通过 session A 的配合，让 session B 删除数据后又重新插入了一遍数据，然后就发现 explain 结果中，rows 字段从 10001 变成 37000 多。</p><p>而如果没有 session A 的配合，只是单独执行 <code>delete from t</code> 、<code>call idata()</code>、<code>explain</code> 这三句话，会看到 rows 字段其实还是 10000 左右。你可以自己验证一下这个结果。</p><p>这是什么原因呢？也请你分析一下吧。</p><p>你可以把你的分析结论写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我在上一篇文章最后留给你的问题是，如果某次写入使用了 change buffer 机制，之后主机异常重启，是否会丢失 change buffer 和数据。</p><p>这个问题的答案是不会丢失，留言区的很多同学都回答对了。虽然是只更新内存，但是在事务提交的时候，我们把 change buffer 的操作也记录到 redo log 里了，所以崩溃恢复的时候，change buffer 也能找回来。</p><p>在评论区有同学问到，merge 的过程是否会把数据直接写回磁盘，这是个好问题。这里，我再为你分析一下。</p><p>merge 的执行流程是这样的：</p><ol><li>从磁盘读入数据页到内存（老版本的数据页）；</li><li>从 change buffer 里找出这个数据页的 change buffer 记录 (可能有多个），依次应用，得到新版数据页；</li><li>写 redo log。这个 redo log 包含了数据的变更和 change buffer 的变更。</li></ol><p>到这里 merge 过程就结束了。这时候，数据页和内存中 change buffer 对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。</p><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../9">上一篇</a>    09 | 普通索引和唯一索引，应该怎么选择？</p><p><a href="../11">下一篇</a>    11 | 怎么给字符串字段加索引？</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>09 | 普通索引和唯一索引，应该怎么选择？</title>
      <link href="/mysql45/9/"/>
      <url>/mysql45/9/</url>
      
        <content type="html"><![CDATA[<h1 id="09-普通索引和唯一索引，应该怎么选择？"><a href="#09-普通索引和唯一索引，应该怎么选择？" class="headerlink" title="09 | 普通索引和唯一索引，应该怎么选择？"></a>09 | 普通索引和唯一索引，应该怎么选择？</h1><p><font color="gray">2018-12-03 林晓斌</font></p><p><img src="../../images/mysql45/9/9.jpg"></p><p>在前面的基础篇文章中，我给你介绍过索引的基本概念，相信你已经了解了唯一索引和普通索引的区别。今天我们就继续来谈谈，在不同的业务场景下，应该选择普通索引，还是唯一索引？</p><p>假设你在维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的 SQL 语句：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select name from CUser where id_card = 'xxxxxxxyyyyyyzzzzz';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以，你一定会考虑在 id_card 字段上建索引。</p><p>由于身份证号字段比较大，我不建议你把身份证号当做主键，那么现在你有两个选择，要么给 id_card 字段创建唯一索引，要么创建一个普通索引。如果业务代码已经保证了不会写入重复的身份证号，那么这两个选择逻辑上都是正确的。</p><p>现在我要问你的是，从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什么呢？</p><p>简单起见，我们还是用第 4 篇文章<a href="../4">《深入浅出索引（上）》</a>中的例子来说明，假设字段 k 上的值都不重复。</p><div style="text-align:center"><img src="../../images/mysql45/4/图%204%20InnoDB%20的索引组织结构.png"><p><font color="gray">图 1 InnoDB 的索引组织结构</font></p></div><p>接下来，我们就从这两种索引对查询语句和更新语句的性能影响来进行分析。</p><h1 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h1><p>假设，执行查询的语句是 <code>select id from T where k=5</code>。这个查询语句在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。</p><ul><li>对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li></ul><p>那么，这个不同带来的性能差距会有多少呢？答案是，微乎其微。</p><p>你知道的，InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。</p><p>因为引擎是按页读写的，所以说，当找到 k=5 的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p><p>当然，如果 k=5 这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。</p><p>但是，我们之前计算过，对于整型字段，一个数据页可以放近千个 key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的 CPU 来说可以忽略不计。</p><h1 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h1><p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，我需要先跟你介绍一下 change buffer。</p><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p>需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。</p><p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。</p><p>显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率。</p><p>那么，<strong>什么条件下可以使用 change buffer 呢？</strong></p><p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。</p><p>因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。</p><p>change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 <code>innodb_change_buffer_max_size</code> 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p><p>现在，你已经理解了 change buffer 的机制，那么我们再一起来看看<strong>如果要在这张表中插入一个新记录 (4,400) 的话，InnoDB 的处理流程是怎样的。</strong></p><p>第一种情况是，<strong>这个记录要更新的目标页在内存中</strong>。这时，InnoDB 的处理流程如下：</p><ul><li>对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。</li></ul><p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。</p><p>但，这不是我们关注的重点。</p><p>第二种情况是，<strong>这个记录要更新的目标页不在内存中</strong>。这时，InnoDB 的处理流程如下：</p><ul><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</li></ul><p>将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><p>之前我就碰到过一件事儿，有个 DBA 的同学跟我反馈说，他负责的某个业务的库内存命中率突然从 99% 降低到了 75%，整个系统处于阻塞状态，更新语句全部堵住。而探究其原因后，我发现这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引。</p><h1 id="change-buffer-的使用场景"><a href="#change-buffer-的使用场景" class="headerlink" title="change buffer 的使用场景"></a>change buffer 的使用场景</h1><p>通过上面的分析，你已经清楚了使用 change buffer 对更新过程的加速作用，也清楚了 change buffer 只限于用在普通索引的场景下，而不适用于唯一索引。那么，现在有一个问题就是：普通索引的所有场景，使用 change buffer 都可以起到加速作用吗？</p><p>因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p><p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。</p><h1 id="索引选择和实践"><a href="#索引选择和实践" class="headerlink" title="索引选择和实践"></a>索引选择和实践</h1><p>回到我们文章开头的问题，普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，我建议你尽量选择普通索引。</p><p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。</p><p>在实际使用中，你会发现，普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。</p><p>特别地，在使用机械硬盘时，change buffer 这个机制的收效是非常显著的。所以，当你有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，那你应该特别关注这些表里的索引，尽量使用普通索引，然后把 change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。</p><h1 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h1><p>理解了 change buffer 的原理，你可能会联想到我在前面文章中和你介绍过的 redo log 和 WAL。</p><p>在前面文章的评论中，我发现有同学混淆了 redo log 和 change buffer。WAL 提升性能的核心机制，也的确是尽量减少随机读写，这两个概念确实容易混淆。所以，这里我把它们放到了同一个流程里来说明，便于你区分这两个概念。</p><blockquote><p>备注：这里，你可以再回顾下第 2 篇文章<a href="../2">《日志系统：一条 SQL 更新语句是如何执行的？》</a>中的相关内容。</p></blockquote><p>现在，我们要在表上执行这个插入语句：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里，我们假设当前 k 索引树的状态，查找到位置后，k1 所在的数据页在内存 (InnoDB buffer pool) 中，k2 所在的数据页不在内存中。如图 2 所示是带 change buffer 的更新状态图。</p><div style="text-align:center"><img src="../../images/mysql45/9/图%202%20带%20change%20buffer%20的更新过程.png"><p><font color="gray">图 2 带 change buffer 的更新过程</font></p></div><p>分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。</p><p>这条更新语句做了如下的操作（按照图中的数字顺序）：</p><ol><li>Page 1 在内存中，直接更新内存；</li><li>Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息</li><li>将上述两个动作记入 redo log 中（图中 3 和 4）。</li></ol><p>做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。</p><p>同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。</p><p>那在这之后的读请求，要怎么处理呢？</p><p>比如，我们现在要执行 <code>select * from t where k in (k1, k2)</code>。这里，我画了这两个读请求的流程图。</p><p>如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表空间（ibdata1）和 redo log（ib_log_fileX）无关了。所以，我在图中就没画出这两部分。</p><div style="text-align:center"><img src="../../images/mysql45/9/图%203%20带%20change%20buffer%20的读过程.png"><p><font color="gray">图 3 带 change buffer 的读过程</font></p></div><p>从图中可以看到：</p><ol><li>读 Page 1 的时候，直接从内存返回。有几位同学在前面文章的评论中问到，WAL 之后如果读数据，是不是一定要读盘，是不是一定要从 redo log 里面把数据更新以后才可以返回？其实是不用的。你可以看一下图 3 的这个状态，虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。</li><li>要读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，然后应用 change buffer 里面的操作日志，生成一个正确的版本并返回结果。</li></ol><p>可以看到，直到需要读 Page 2 的时候，这个数据页才会被读入内存。</p><p>所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，<strong>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。</strong></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我从普通索引和唯一索引的选择开始，和你分享了数据的查询和更新过程，然后说明了 change buffer 的机制以及应用场景，最后讲到了索引选择的实践。</p><p>由于唯一索引用不上 change buffer 的优化机制，因此如果业务可以接受，从性能角度出发我建议你优先考虑非唯一索引。</p><p>最后，又到了思考题时间。</p><p>通过图 2 你可以看到，change buffer 一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致 change buffer 丢失呢？change buffer 丢失可不是小事儿，再从磁盘读入数据可就没有了 merge 过程，就等于是数据丢失了。会不会出现这种情况呢？</p><p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><p><strong>补充：</strong><br>评论区大家对“是否使用唯一索引”有比较多的讨论，主要是纠结在“业务可能无法确保”的情况。这里，我再说明一下：</p><ul><li>首先，业务正确性优先。咱们这篇文章的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。这种情况下，本篇文章的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，可以给你多提供一个排查思路。</li><li>然后，在一些“归档库”的场景，你是可以考虑使用普通索引的。比如，线上数据只需要保留半年，然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率，可以考虑把表里面的唯一索引改成普通索引。</li></ul><h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是：如何构造一个“数据无法修改”的场景。评论区里已经有不少同学给出了正确答案，这里我再描述一下。</p><p><img src="../../images/mysql45/9/%E4%B8%8A%E6%9C%9F%E9%97%AE%E9%A2%98%E6%83%85%E5%BD%A21.png"></p><p>这样，session A 看到的就是我截图的效果了。</p><p>其实，还有另外一种场景，同学们在留言区都还没有提到。</p><p><img src="../../images/mysql45/9/%E4%B8%8A%E6%9C%9F%E9%97%AE%E9%A2%98%E6%83%85%E5%BD%A22.png"></p><p>这个操作序列跑出来，session A 看的内容也是能够复现我截图的效果的。这个 session B’启动的事务比 A 要早，其实是上期我们描述事务版本的可见性规则时留的彩蛋，因为规则里还有一个“活跃事务的判断”，我是准备留到这里再补充的。</p><p>当我试图在这里讲述完整规则的时候，发现第 8 篇文章<a href="../8">《事务到底是隔离的还是不隔离的？》</a>中的解释引入了太多的概念，以致于分析起来非常复杂。</p><p>因此，我重写了第 8 篇，这样我们人工去判断可见性的时候，才会更方便。【看到这里，我建议你能够再重新打开第 8 篇文章并认真学习一次。如果学习的过程中，有任何问题，也欢迎你给我留言】</p><p>用新的方式来分析 session B’的更新为什么对 session A 不可见就是：在 session A 视图数组创建的瞬间，session B’是活跃的，属于“版本未提交，不可见”这种情况。</p><p>业务中如果要绕过这类问题。</p><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../8">上一篇</a>    08 | 事务到底是隔离的还是不隔离的？</p><p><a href="../10">下一篇</a>    10 | MySQL为什么有时候会选错索引？</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>08 | 事务到底是隔离的还是不隔离的？</title>
      <link href="/mysql45/8/"/>
      <url>/mysql45/8/</url>
      
        <content type="html"><![CDATA[<h1 id="08-事务到底是隔离的还是不隔离的？"><a href="#08-事务到底是隔离的还是不隔离的？" class="headerlink" title="08 | 事务到底是隔离的还是不隔离的？"></a>08 | 事务到底是隔离的还是不隔离的？</h1><p><font color="gray">2018-11-30 林晓斌</font></p><p><img src="../../images/mysql45/8/8.jpg"></p><blockquote><p>你好，我是林晓斌。<br>你现在看到的这篇文章是我重写过的。在第一版文章发布之后，我发现在介绍事务可见性规则时，由于引入了太多概念，导致理解起来很困难。随后，我索性就重写了这篇文章。<br>现在的用户留言中，还能看到第一版文章中引入的 <code>up_limit_id</code> 的概念，为了避免大家产生误解，再此特地和大家事先说明一下。</p></blockquote><p>我在第 3 篇文章和你讲事务隔离级别的时候提到过，如果是可重复读隔离级别，事务 T 启动的时候会创建一个视图 <code>read-view</code>，之后事务 T 执行期间，即使有其他事务修改了数据，事务 T 看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。</p><p>但是，我在上一篇文章中，和你分享行锁的时候又提到，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？</p><p>我给你举一个例子吧。下面是一个只有两行的表的初始化语句。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE `t` (  `id` int(11) NOT NULL,  `k` int(11) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB;insert into t(id, k) values(1,1),(2,2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div style="text-align:center"><img src="../../images/mysql45/8/图%201%20事务%20A、B、C%20的执行流程.png"><p><font color="gray">图 1 事务 A、B、C 的执行流程</font></p></div><p>这里，我们需要注意的是事务的启动时机。</p><p><code>begin/start transaction</code> 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 <code>start transaction with consistent snapshot</code> 这个命令。</p><blockquote><p>第一种启动方式，一致性视图是在执行第一个快照读语句时创建的；<br>第二种启动方式，一致性视图是在执行 <code>start transaction with consistent snapshot</code> 时创建的。</p></blockquote><p>还需要注意的是，在整个专栏里面，我们的例子中如果没有特别说明，都是默认 <code>autocommit=1</code>。</p><p>在这个例子中，事务 C 没有显式地使用 <code>begin/commit</code>，表示这个 update 语句本身就是一个事务，语句完成的时候会自动提交。事务 B 在更新了行之后查询 ; 事务 A 在一个只读事务中查询，并且时间顺序上是在事务 B 的查询之后。</p><p>这时，如果我告诉你事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是 1，你是不是感觉有点晕呢？</p><p>所以，今天这篇文章，我其实就是想和你说明白这个问题，希望借由把这个疑惑解开的过程，能够帮助你对 InnoDB 的事务和锁有更进一步的理解。</p><p>在 MySQL 里，有两个“视图”的概念：</p><ul><li>一个是 <code>view</code>。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 <code>create view …</code> ，而它的查询方法与表一样。</li><li>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 <code>consistent read view</code>，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。</li></ul><p>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</p><p>在第 3 篇文章<a href="../3">《事务隔离：为什么你改了我还看不见？》</a>中，我跟你解释过一遍 MVCC 的实现逻辑。今天为了说明查询和更新的区别，我换一个方式来说明，把 <code>read view</code> 拆开。你可以结合这两篇文章的说明来更深一步地理解 MVCC。</p><h1 id="“快照”在-MVCC-里是怎么工作的？"><a href="#“快照”在-MVCC-里是怎么工作的？" class="headerlink" title="“快照”在 MVCC 里是怎么工作的？"></a>“快照”在 MVCC 里是怎么工作的？</h1><p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</p><p>这时，你会说这看上去不太现实啊。如果一个库有 100G，那么我启动一个事务，MySQL 就要拷贝 100G 的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。</p><p>实际上，我们并不需要拷贝出这 100G 的数据。我们先来看看这个快照是怎么实现的。</p><p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 <code>transaction id</code>。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。</p><p>而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 <code>transaction id</code> 赋值给这个数据版本的事务 ID，记为 <code>row trx_id</code>。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p><p>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 <code>row trx_id</code>。</p><p>如图 2 所示，就是一个记录被多个事务连续更新后的状态。</p><div style="text-align:center"><img src="../../images/mysql45/8/图%202%20行状态变更图.png"><p><font color="gray">图 2 行状态变更图</font></p></div><p>图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 <code>transaction id</code> 为 <code>25</code> 的事务更新的，因此它的 <code>row trx_id</code> 也是 <code>25</code>。</p><p>你可能会问，前面的文章不是说，语句更新会生成 undo log（回滚日志）吗？那么，<strong>undo log 在哪呢？</strong></p><p>实际上，图 2 中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。</p><p>明白了多版本和 <code>row trx_id</code> 的概念后，我们再来想一下，InnoDB 是怎么定义那个“100G”的快照的。</p><p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p><p>因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。</p><p>当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。</p><p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。</p><p>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。</p><p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p><p>而数据版本的可见性规则，就是基于数据的 <code>row trx_id</code> 和这个一致性视图的对比结果得到的。</p><p>这个视图数组把所有的 <code>row trx_id</code> 分成了几种不同的情况。</p><div style="text-align:center"><img src="../../images/mysql45/8/图%203%20数据版本可见性规则.png"><p><font color="gray">图 3 数据版本可见性规则</font></p></div><p>这样，对于当前事务的启动瞬间来说，一个数据版本的 <code>row trx_id</code>，有以下几种可能：</p><ol><li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li><li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li><li>如果落在黄色部分，那就包括两种情况<br>a. 若 <code>row trx_id</code> 在数组中，表示这个版本是由还没提交的事务生成的，不可见；<br>b. 若 <code>row trx_id</code> 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ol><p>比如，对于图 2 中的数据来说，如果有一个事务，它的低水位是 18，那么当它访问这一行数据时，就会从 V4 通过 U3 计算出 V3，所以在它看来，这一行的值是 11。</p><p>你看，有了这个声明后，系统里面随后发生的更新，是不是就跟这个事务看到的内容无关了呢？因为之后的更新，生成的版本一定属于上面的 2 或者 3(a) 的情况，而对它来说，这些新的数据版本是不存在的，所以这个事务的快照，就是“静态”的了。</p><p>所以你现在知道了，<strong>InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p><p>接下来，我们继续看一下图 1 中的三个事务，分析下事务 A 的语句返回的结果，为什么是 k=1。</p><p>这里，我们不妨做如下假设：</p><ol><li>事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；</li><li>事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；</li><li>三个事务开始前，(1,1）这一行数据的 <code>row trx_id</code> 是 <code>90</code>。</li></ol><p>这样，事务 A 的视图数组就是 [99,100], 事务 B 的视图数组是 [99,100,101], 事务 C 的视图数组是 [99,100,101,102]。</p><p>为了简化分析，我先把其他干扰语句去掉，只画出跟事务 A 查询逻辑有关的操作：</p><div style="text-align:center"><img src="../../images/mysql45/8/图%204%20事务%20A%20查询数据逻辑图.png"><p><font color="gray">图 4 事务 A 查询数据逻辑图</font></p></div><p>从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 <code>row trx_id</code> 是 <code>102</code>，而 90 这个版本已经成为了历史版本。</p><p>第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 <code>101</code>，而 102 又成为了历史版本。</p><p>你可能注意到了，在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。</p><p>好，现在事务 A 要来读数据了，它的视图数组是 [99,100]。当然了，读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的：</p><ul><li>找到 (1,3) 的时候，判断出 <code>row trx_id=101</code>，比高水位大，处于红色区域，不可见；</li><li>接着，找到上一个历史版本，一看 <code>row trx_id=102</code>，比高水位大，处于红色区域，不可见；</li><li>再往前找，终于找到了（1,1)，它的 <code>row trx_id=90</code>，比低水位小，处于绿色区域，可见。</li></ul><p>这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p><p>这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。</p><p>所以，我来给你翻译一下。一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p><ol><li>版本未提交，不可见；</li><li>版本已提交，但是是在视图创建后提交的，不可见；</li><li>版本已提交，而且是在视图创建前提交的，可见。</li></ol><p>现在，我们用这个规则来判断图 4 中的查询结果，事务 A 的查询语句的视图数组是在事务 A 启动的时候生成的，这时候：</p><ul><li>(1,3) 还没提交，属于情况 1，不可见；</li><li>(1,2) 虽然提交了，但是是在视图数组创建之后提交的，属于情况 2，不可见；</li><li>(1,1) 是在视图数组创建之前提交的，可见。</li></ul><p>你看，去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了。所以，后面我们就都用这个规则来分析。</p><h1 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h1><p>细心的同学可能有疑问了：<strong>事务 B 的 update 语句，如果按照一致性读，好像结果不对哦？</strong></p><p>你看图 5 中，事务 B 的视图数组是先生成的，之后事务 C 才提交，不是应该看不见 (1,2) 吗，怎么能算出 (1,3) 来？</p><div style="text-align:center"><img src="../../images/mysql45/8/图%205%20事务%20B%20更新逻辑图.png"><p><font color="gray">图 5 事务 B 更新逻辑图</font></p></div><p>是的，如果事务 B 在更新之前查询一次数据，这个查询返回的 k 的值确实是 1。</p><p>但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务 C 的更新就丢失了。因此，事务 B 此时的 <code>set k=k+1</code> 是在（1,2）的基础上进行的操作。</p><p>所以，这里就用到了这样一条规则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p><p>因此，在更新的时候，当前读拿到的数据是 (1,2)，更新后生成了新版本的数据 (1,3)，这个新版本的 <code>row trx_id</code> 是 <code>101</code>。</p><p>所以，在执行事务 B 查询语句的时候，一看自己的版本号是 101，最新数据的版本号也是 101，是自己的更新，可以直接使用，所以查询得到的 k 的值是 3。</p><p>这里我们提到了一个概念，叫作当前读。其实，除了 update 语句外，select 语句如果加锁，也是当前读。</p><p>所以，如果把事务 A 的查询语句 <code>select * from t where id=1</code> 修改一下，加上 <code>lock in share mode</code> 或 <code>for update</code>，也都可以读到版本号是 101 的数据，返回的 k 的值是 3。下面这两个 select 语句，就是分别加了读锁（S 锁，共享锁）和写锁（X 锁，排他锁）。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select k from t where id=1 lock in share mode;mysql&gt; select k from t where id=1 for update;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再往前一步，假设事务 C 不是马上提交的，而是变成了下面的事务 C’，会怎么样呢？</p><div style="text-align:center"><img src="../../images/mysql45/8/图%206%20事务%20A、B、C%27的执行流程.png"><p><font color="gray">图 6 事务 A、B、C'的执行流程</font></p></div><p>事务 C’的不同是，更新后并没有马上提交，在它提交前，事务 B 的更新语句先发起了。前面说过了，虽然事务 C’还没提交，但是 (1,2) 这个版本也已经生成了，并且是当前的最新版本。那么，事务 B 的更新语句会怎么处理呢？</p><p>这时候，我们在上一篇文章中提到的“两阶段锁协议”就要上场了。事务 C’没提交，也就是说 (1,2) 这个版本上的写锁还没释放。而事务 B 是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务 C’释放这个锁，才能继续它的当前读。</p><div style="text-align:center"><img src="../../images/mysql45/8/图%207%20事务%20B%20更新逻辑图（配合事务%20C%27）.png"><p><font color="gray">图 7 事务 B 更新逻辑图（配合事务 C'）</font></p></div><p>到这里，我们把一致性读、当前读和行锁就串起来了。</p><p>现在，我们再回到文章开头的问题：<strong>事务的可重复读的能力是怎么实现的？</strong></p><p>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p><p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li></ul><p>那么，我们再看一下，在读提交隔离级别下，事务 A 和事务 B 的查询语句查到的 k，分别应该是多少呢？</p><p>这里需要说明一下，“<code>start transaction with consistent snapshot; </code>”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的 <code>start transaction</code>。</p><p>下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组的时机发生了变化，就是图中的 read view 框。（注意：这里，我们用的还是事务 C 的逻辑直接提交，而不是事务 C’）</p><div style="text-align:center"><img src="../../images/mysql45/8/图%208%20读提交隔离级别下的事务状态图.jpg"><p><font color="gray">图 8 读提交隔离级别下的事务状态图</font></p></div><p>这时，事务 A 的查询语句的视图数组是在执行这个语句的时候创建的，时序上 (1,2)、(1,3) 的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：</p><ul><li>(1,3) 还没提交，属于情况 1，不可见；</li><li>(1,2) 提交了，属于情况 3，可见。</li></ul><p>所以，这时候事务 A 查询语句返回的是 k=2。</p><p>显然地，事务 B 查询结果 k=3。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>InnoDB 的行数据有多个版本，每个数据版本有自己的 <code>row trx_id</code>，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 <code>row trx_id</code> 和一致性视图确定数据版本的可见性。</p><ul><li>对于可重复读，查询只承认在事务启动前就已经提交完成的数据；</li><li>对于读提交，查询只承认在语句启动前就已经提交完成的数据；</li></ul><p>而当前读，总是读取已经提交完成的最新版本。</p><p>你也可以想一下，为什么表结构不支持“可重复读”？这是因为表结构没有对应的行数据，也没有 <code>row trx_id</code>，因此只能遵循当前读的逻辑。</p><p>当然，MySQL 8.0 已经可以把表结构放在 InnoDB 字典里了，也许以后会支持表结构的可重复读。</p><p>又到思考题时间了。我用下面的表结构和初始化语句作为试验环境，事务隔离级别是可重复读。现在，我要把所有“字段 c 和 id 值相等的行”的 c 值清零，但是却发现了一个“诡异”的、改不掉的情况。请你构造出这种情况，并说明其原理。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE `t` (  `id` int(11) NOT NULL,  `c` int(11) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB;insert into t(id, c) values(1,1),(2,2),(3,3),(4,4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="../../images/mysql45/8/%E5%9D%91.png"></p><p>复现出来以后，请你再思考一下，在实际的业务开发中有没有可能碰到这种情况？你的应用代码会不会掉进这个“坑”里，你又是怎么解决的呢？</p><p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我在上一篇文章最后，留给你的问题是：怎么删除表的前 <code>10000</code> 行。比较多的留言都选择了第二种方式，即：在一个连接中循环执行 <code>20</code> 次 <code>delete from T limit 500</code>。</p><p>确实是这样的，第二种方式是相对较好的。</p><p>第一种方式（即：直接执行 <code>delete from T limit 10000</code>）里面，单个语句占用时间长，锁的时间也比较长；而且大事务还会导致主从延迟。</p><p>第三种方式（即：在 <code>20</code> 个连接中同时执行 <code>delete from T limit 500</code>），会人为造成锁冲突。</p><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../7">上一篇</a>    07 | 行锁功过：怎么减少行锁对性能的影响？</p><p><a href="../9">下一篇</a>    09 | 普通索引和唯一索引，应该怎么选择？</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07 | 行锁功过：怎么减少行锁对性能的影响？</title>
      <link href="/mysql45/7/"/>
      <url>/mysql45/7/</url>
      
        <content type="html"><![CDATA[<h1 id="07-行锁功过：怎么减少行锁对性能的影响？"><a href="#07-行锁功过：怎么减少行锁对性能的影响？" class="headerlink" title="07 | 行锁功过：怎么减少行锁对性能的影响？"></a>07 | 行锁功过：怎么减少行锁对性能的影响？</h1><p><font color="gray">2018-11-28 林晓斌</font></p><p><img src="../../images/mysql45/7/7.jpg"></p><p>在上一篇文章中，我跟你介绍了 MySQL 的全局锁和表级锁，今天我们就来讲讲 MySQL 的行锁。</p><p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</p><p>我们今天就主要来聊聊 InnoDB 的行锁，以及如何通过减少锁冲突来提升业务并发度。</p><p>顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。</p><p>当然，数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导致程序出现非预期行为，比如两阶段锁。</p><h1 id="从两阶段锁说起"><a href="#从两阶段锁说起" class="headerlink" title="从两阶段锁说起"></a>从两阶段锁说起</h1><p>我先给你举个例子。在下面的操作序列中，事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键。</p><p><img src="../../images/mysql45/7/%E4%BA%8B%E5%8A%A1update.jpg"></p><p>这个问题的结论取决于事务 A 在执行完两条 update 语句后，持有哪些锁，以及在什么时候释放。你可以验证一下：实际上事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。</p><p>知道了这个答案，你一定知道了事务 A 持有的两个记录的行锁，都是在 commit 的时候才释放的。</p><p>也就是说，<strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p><p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，<font color="orange">如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</font>我给你举个例子。</p><p>假设你负责实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。我们简化一点，这个业务需要涉及到以下操作：</p><ol><li>从顾客 A 账户余额中扣除电影票价；</li><li>给影院 B 的账户余额增加这张电影票价；</li><li>记录一条交易日志。</li></ol><p>也就是说，要完成这个交易，我们需要 update 两条记录，并 insert 一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？</p><p>试想如果同时有另外一个顾客 C 要在影院 B 买票，那么这两个事务冲突的部分就是语句 2 了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。</p><p>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句 2 安排在最后，比如按照 3、1、2 这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。</p><p>好了，现在由于你的正确设计，影院余额这一行的行锁在一个事务中不会停留很长时间。但是，这并没有完全解决你的困扰。</p><p>如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的 MySQL 就挂了。你登上服务器一看，CPU 消耗接近 100%，但整个数据库每秒就执行不到 100 个事务。这是什么原因呢？</p><p>这里，我就要说到死锁和死锁检测了。</p><h1 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h1><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。</p><p><img src="../../images/mysql45/7/%E6%AD%BB%E9%94%81.jpg"></p><p>这时候，事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p><ul><li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。</li><li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 <code>on</code>，表示开启这个逻辑。</li></ul><p>在 InnoDB 中，<code>innodb_lock_wait_timeout</code> 的默认值是 <code>50s</code>，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p><p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p><p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 <code>innodb_deadlock_detect</code> 的默认值本身就是 <code>on</code>。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p><p>你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p><p>那如果是我们上面说到的所有事务都要更新同一行的场景呢？</p><p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</p><p>根据上面的分析，我们来讨论一下，<font color="orange">怎么解决由这种热点行更新导致的性能问题呢？</font>问题的症结在于，死锁检测要耗费大量的 CPU 资源。</p><p><strong>一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</strong>但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</p><p><strong>另一个思路是控制并发度。</strong>根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有 10 个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有 600 个客户端，这样即使每个客户端控制到只有 5 个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到 3000。</p><p>因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。</p><p>可能你会问，<strong>如果团队里暂时没有数据库方面的专家，不能实现这样的方案，能不能从设计上优化这个问题呢？</strong></p><p>你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。</p><p>这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成 0 的时候，代码要有特殊处理。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我和你介绍了 MySQL 的行锁，涉及了两阶段锁协议、死锁和死锁检测这两大部分内容。</p><p>其中，我以两阶段协议为起点，和你一起讨论了在开发的时候如何安排正确的事务语句。这里的原则 / 我给你的建议是：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放。</p><p>但是，调整语句顺序并不能完全避免死锁。所以我们引入了死锁和死锁检测的概念，以及提供了三个方案，来减少死锁对数据库的影响。减少死锁的主要方向，就是控制访问相同资源的并发事务量。</p><p>最后，我给你留下一个问题吧。如果你要删除一个表里面的前 10000 行数据，有以下三种方法可以做到：</p><ul><li>第一种，直接执行 <code>delete from T limit 10000</code>;</li><li>第二种，在一个连接中循环执行 <code>20</code> 次 <code>delete from T limit 500</code>;</li><li>第三种，在 <code>20</code> 个连接中同时执行 <code>delete from T limit 500</code>。</li></ul><p>你会选择哪一种方法呢？为什么呢？</p><p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期我给你留的问题是：当备库用<code>–single-transaction</code> 做逻辑备份的时候，如果从主库的 binlog 传来一个 DDL 语句会怎么样？</p><p>假设这个 DDL 是针对表 t1 的， 这里我把备份过程中几个关键的语句列出来：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT;/* other tables */Q3:SAVEPOINT sp;/* 时刻 1 */Q4:show create table `t1`;/* 时刻 2 */Q5:SELECT * FROM `t1`;/* 时刻 3 */Q6:ROLLBACK TO SAVEPOINT sp;/* 时刻 4 *//* other tables */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在备份开始的时候，为了确保 RR（可重复读）隔离级别，再设置一次 RR 隔离级别 (Q1);</p><p>启动事务，这里用 <code>WITH CONSISTENT SNAPSHOT</code> 确保这个语句执行完就可以得到一个一致性视图（Q2)；</p><p>设置一个保存点，这个很重要（Q3）；</p><p><code>show create</code> 是为了拿到表结构 (Q4)，然后正式导数据 （Q5），回滚到 <code>SAVEPOINT sp</code>，在这里的作用是释放 t1 的 MDL 锁 （Q6）。当然这部分属于“超纲”，上文正文里面都没提到。</p><p>DDL 从主库传过来的时间按照效果不同，我打了四个时刻。题目设定为小表，我们假定到达后，如果开始执行，则很快能够执行完成。</p><p>参考答案如下：</p><ol><li>如果在 Q4 语句执行之前到达，现象：没有影响，备份拿到的是 DDL 后的表结构。</li><li>如果在“时刻 2”到达，则表结构被改过，Q5 执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump 终止；</li><li>如果在“时刻 2”和“时刻 3”之间到达，mysqldump 占着 t1 的 MDL 读锁，binlog 被阻塞，现象：主从延迟，直到 Q6 执行完成。</li><li>从“时刻 4”开始，mysqldump 释放了 MDL 读锁，现象：没有影响，备份拿到的是 DDL 前的表结构。</li></ol><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../6">上一篇</a>    06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</p><p><a href="../8">下一篇</a>    08 | 事务到底是隔离的还是不隔离的？</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</title>
      <link href="/mysql45/6/"/>
      <url>/mysql45/6/</url>
      
        <content type="html"><![CDATA[<h1 id="06-全局锁和表锁-：给表加个字段怎么有这么多阻碍？"><a href="#06-全局锁和表锁-：给表加个字段怎么有这么多阻碍？" class="headerlink" title="06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？"></a>06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</h1><p><font color="gray">2018-11-26 林晓斌</font></p><p><img src="../../images/mysql45/6/6.png"></p><p>今天我要跟你聊聊 MySQL 的锁。数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p><p><strong>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类</strong>。今天这篇文章，我会和你分享全局锁和表级锁。而关于行锁的内容，我会留着在下一篇文章中再和你详细介绍。</p><p>这里需要说明的是，锁的设计比较复杂，这两篇文章不会涉及锁的具体实现细节，主要介绍的是碰到锁时的现象和其背后的原理。</p><h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 <code>Flush tables with read lock (FTWRL)</code>。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p><p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong>也就是把整库每个表都 select 出来存成文本。</p><p>以前有一种做法，是通过 FTWRL 确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。</p><p>但是让整库都只读，听上去就很危险：</p><ul><li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li><li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。</li></ul><p>看来加全局锁不太好。但是细想一下，备份为什么要加锁呢？我们来看一下不加锁会有什么问题。</p><p>假设你现在要维护“极客时间”的购买系统，关注的是用户账户余额表和用户课程表。</p><p>现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉他的余额，然后往已购课程里面加上一门课。</p><p>如果时间顺序上是先备份账户余额表 (u_account)，然后用户购买，然后备份用户课程表 (u_course)，会怎么样呢？你可以看一下这个图：</p><div style="text-align:center"><img src="../../images/mysql45/6/图%201%20业务和备份状态图.png"><p><font color="gray">图 1 业务和备份状态图</font></p></div><p>可以看到，这个备份结果里，用户 A 的数据状态是“账户余额没扣，但是用户课程表里面已经多了一门课”。如果后面用这个备份来恢复数据的话，用户 A 就发现，自己赚了。</p><p>作为用户可别觉得这样可真好啊，你可以试想一下：如果备份表的顺序反过来，先备份用户课程表再备份账户余额表，又可能会出现什么结果？</p><p>也就是说，不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。</p><p>说到视图你肯定想起来了，我们在前面讲事务隔离的时候，其实是有一个方法能够拿到一致性视图的，对吧？</p><p>是的，就是在可重复读隔离级别下开启一个事务。</p><blockquote><p>备注：如果你对事务隔离级别的概念不是很清晰的话，可以再回顾一下第 3 篇文章<a href="../3">《事务隔离：为什么你改了我还看不见？》</a>中的相关内容。</p></blockquote><p>官方自带的逻辑备份工具是 mysqldump。当 <code>mysqldump</code> 使用参数<code>–single-transaction</code> 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p><p>你一定在疑惑，有了这个功能，为什么还需要 FTWRL 呢？<strong>一致性读是好，但前提是引擎要支持这个隔离级别。</strong>比如，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。</p><p>所以，<strong>single-transaction 方法只适用于所有的表使用事务引擎的库。</strong>如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。这往往是 DBA 要求业务开发人员使用 InnoDB 替代 MyISAM 的原因之一。</p><p>你也许会问，<strong>既然要全库只读，为什么不使用 set global readonly=true 的方式呢</strong>？确实 readonly 方式也可以让全库进入只读状态，但我还是会建议你用 FTWRL 方式，主要有两个原因：</p><ul><li>一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。</li><li>二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li></ul><p>业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</p><p>但是，即使没有被全局锁住，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们要介绍的表级锁。</p><h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><p><strong>表锁的语法是 lock tables … read/write。</strong>与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p><p>举个例子, 如果在某个线程 A 中执行 <code>lock tables t1 read, t2 write;</code> 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 <code>unlock tables</code> 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p><p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p><p><strong>另一类表级的锁是 MDL（metadata lock)。</strong>MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p><ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul><p>虽然 MDL 锁是系统默认会加的，但却是你不能忽略的一个机制。比如下面这个例子，我经常看到有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。</p><p>你肯定知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。我们来看一下下面的操作序列，假设表 t 是一个小表。</p><blockquote><p>备注：这里的实验环境是 MySQL 5.6。</p></blockquote><p><img src="../../images/mysql45/6/session.jpg"></p><p>我们可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行。</p><p>之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。</p><p>如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。前面我们说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。</p><p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。</p><p>你现在应该知道了，事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p><p>基于上面的分析，我们来讨论一个问题，<strong>如何安全地给小表加字段？</strong></p><p>首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 <code>information_schema</code> 库的 <code>innodb_trx</code> 表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 <code>kill</code> 掉这个长事务。</p><p>但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</p><p>这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</p><p>MariaDB 已经合并了 AliSQL 的这个功能，所以这两个开源分支目前都支持 <code>DDL NOWAIT/WAIT n</code> 这个语法。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE tbl_name NOWAIT add column ...ALTER TABLE tbl_name WAIT N add column ... <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我跟你介绍了 MySQL 的全局锁和表级锁。</p><p>全局锁主要用在逻辑备份过程中。对于全部是 InnoDB 引擎的库，我建议你选择使用<code>–single-transaction</code> 参数，对应用会更友好。</p><p>表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有 <code>lock tables</code> 这样的语句，你需要追查一下，比较可能的情况是：</p><ul><li>要么是你的系统现在还在用 MyISAM 这类不支持事务的引擎，那要安排升级换引擎；</li><li>要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，最后业务开发就是把 <code>lock tables</code> 和 <code>unlock tables</code> 改成 <code>begin</code> 和 <code>commit</code>，问题就解决了。</li></ul><p>MDL 会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。</p><p>最后，我给你留一个问题吧。备份一般都会在备库上执行，你在用<code>–single-transaction</code> 方法做逻辑备份的过程中，如果主库上的一个小表做了一个 DDL，比如给一个表上加了一列。这时候，从备库上会看到什么现象呢？</p><p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><p>说明：这篇文章没有介绍到物理备份，物理备份会有一篇单独的文章。</p><h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是关于对联合主键索引和 InnoDB 索引组织表的理解。</p><p>我直接贴 @老杨同志 的回复略作修改如下（我修改的部分用<font color="orange">橙色</font>标出）：</p><p>表记录<br>–a–|–b–|–c–|–d–<br>&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;d<br>&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;d<br>&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;d<br>&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;d<br>&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;d<br>&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;d<br>主键 a，b 的聚簇索引组织顺序相当于 order by a,b ，也就是先按 a 排序，再按 b 排序，c 无序。</p><p>索引 ca 的组织是先按 c 排序，再按 a 排序，同时记录主键<br>–c–|–a–|–主键部分<font color="orange">b</font>– <font color="orange">（注意，这里不是 ab，而是只有 b）</font><br>&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<br>&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4<br>&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<br><font color="orange">这个跟索引 c 的数据是一模一样的。</font></p><p>索引 cb 的组织是先按 c 排序，在按 b 排序，同时记录主键<br>–c–|–b–|–主键部分<font color="orange">a</font>– <font color="orange">（同上）</font><br>&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2</p><p>所以，结论是 ca 可以去掉，cb 需要保留。</p><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../5">上一篇</a>    05 | 深入浅出索引（下）</p><p><a href="../7">下一篇</a>    07 | 行锁功过：怎么减少行锁对性能的影响？</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05 | 深入浅出索引（下）</title>
      <link href="/mysql45/5/"/>
      <url>/mysql45/5/</url>
      
        <content type="html"><![CDATA[<h1 id="05-深入浅出索引（下）"><a href="#05-深入浅出索引（下）" class="headerlink" title="05 | 深入浅出索引（下）"></a>05 | 深入浅出索引（下）</h1><p><font color="gray">2018-11-23 林晓斌</font></p><p><img src="../../images/mysql45/5/5.jpg"></p><p>在上一篇文章中，我和你介绍了 InnoDB 索引的数据结构模型，今天我们再继续聊聊跟 MySQL 索引有关的概念。</p><p>在开始这篇文章之前，我们先来看一下这个问题：</p><p>在下面这个表 T 中，如果我执行 <code>select * from T where k between 3 and 5</code>，需要执行几次树的搜索操作，会扫描多少行？</p><p>下面是这个表的初始化语句。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create table T (  ID int primary key,  k int NOT NULL DEFAULT 0,   s varchar(16) NOT NULL DEFAULT '',  index k(k)) engine=InnoDB; insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div style="text-align:center"><img src="../../images/mysql45/5/图%201%20InnoDB%20的索引组织结构.png"><p><font color="gray">图 1 InnoDB 的索引组织结构</font></p></div><p>现在，我们一起来看看这条 SQL 查询语句的执行流程：</p><ol><li>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</li><li>再到 ID 索引树查到 ID=300 对应的 R3；</li><li>在 k 索引树取下一个值 k=5，取得 ID=500；</li><li>再回到 ID 索引树查到 ID=500 对应的 R4；</li><li>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</li></ol><p>在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表</strong>。可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。</p><p>在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？</p><h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>如果执行的语句是 <code>select ID from T where k between 3 and 5</code>，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p><p>需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项），但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2。</p><blockquote><p>备注：关于如何查看扫描行数的问题，我将会在第 16 文章《如何正确地显示随机消息？》中，和你详细讨论。</p></blockquote><p>基于上面覆盖索引的说明，我们来讨论一个问题：<strong>在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？</strong></p><p>假设这个市民表的定义是这样的：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE `tuser` (  `id` int(11) NOT NULL,  `id_card` varchar(32) DEFAULT NULL,  `name` varchar(32) DEFAULT NULL,  `age` int(11) DEFAULT NULL,  `ismale` tinyint(1) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `id_card` (`id_card`),  KEY `name_age` (`name`,`age`)) ENGINE=InnoDB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p><p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p><p>当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务 DBA，或者称为业务数据架构师的工作。</p><h1 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h1><p>看到这里你一定有一个疑问，如果为每一种查询都设计一个索引，索引是不是太多了。如果我现在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？</p><p>这里，我先和你说结论吧。<strong>B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</strong></p><p>为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。</p><div style="text-align:center"><img src="../../images/mysql45/5/图%202%20（name，age）索引示意图.jpg"><p><font color="gray">图 2 （name，age）索引示意图</font></p></div><p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p><p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。</p><p>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”<code>where name like '张%'</code>“。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</p><p>可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p><p>基于上面对最左前缀索引的说明，我们来讨论一个问题：<strong>在建立联合索引的时候，如何安排索引内的字段顺序。</strong></p><p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，<strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong></p><p>所以现在你知道了，这段开头的问题里，我们要为高频请求创建 (身份证号，姓名）这个联合索引，并用这个索引支持“根据身份证号查询地址”的需求。</p><p>那么，如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。</p><p>这时候，我们要<strong>考虑的原则就是空间</strong>了。比如上面这个市民表的情况，name 字段是比 age 字段大的 ，那我就建议你创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。</p><h1 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h1><p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？</p><p>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from tuser where name like '张%' and age=10 and ismale=1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。</p><p>然后呢？</p><p>当然是判断其他条件是否满足。</p><p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</p><p>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><p>图 3 和图 4，是这两个过程的执行流程图。</p><div style="text-align:center"><img src="../../images/mysql45/5/图%203%20无索引下推执行流程.jpg"><p><font color="gray">图 3 无索引下推执行流程</font></p></div><div style="text-align:center"><img src="../../images/mysql45/5/图%204%20索引下推执行流程.jpg"><p><font color="gray">图 4 索引下推执行流程</font></p></div><p>在图 3 和 4 这两个图里面，每一个虚线箭头表示回表一次。</p><p>图 3 中，在 (name,age) 索引里面我特意去掉了 age 的值，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次。</p><p>图 4 跟图 3 的区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我和你继续讨论了数据库索引的概念，包括了覆盖索引、前缀索引、索引下推。你可以看到，在满足语句需求的情况下， 尽量少地访问资源是数据库设计的重要原则之一。我们在使用数据库的时候，尤其是在设计表结构时，也要以减少资源消耗作为目标。</p><p>接下来我给你留下一个问题吧。</p><p>实际上主键索引也是可以使用多个字段的。DBA 小吕在入职新公司的时候，就发现自己接手维护的库里面，有这么一个表，表结构定义类似这样的：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE `geek` (  `a` int(11) NOT NULL,  `b` int(11) NOT NULL,  `c` int(11) NOT NULL,  `d` int(11) NOT NULL,  PRIMARY KEY (`a`,`b`),  KEY `c` (`c`),  KEY `ca` (`c`,`a`),  KEY `cb` (`c`,`b`)) ENGINE=InnoDB;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>公司的同事告诉他说，由于历史原因，这个表需要 a、b 做联合主键，这个小吕理解了。</p><p>但是，学过本章内容的小吕又纳闷了，既然主键包含了 a、b 这两个字段，那意味着单独在字段 c 上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？</p><p>同事告诉他，是因为他们的业务里面有这样的两种语句：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select * from geek where c=N order by a limit 1;select * from geek where c=N order by b limit 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我给你的问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？</p><p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是，通过两个 alter 语句重建索引 k，以及通过两个 alter 语句重建主键索引是否合理。</p><p>在评论区，有同学问到为什么要重建索引。我们文章里面有提到，索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。</p><p>这道题目，我给你的“参考答案”是：</p><p>重建索引 k 的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： <code>alter table T engine=InnoDB</code>。在专栏的第 12 篇文章《为什么表数据删掉一半，表文件大小不变？》中，我会和你分析这条语句的执行流程。</p><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../4">上一篇</a>    04 | 深入浅出索引（上）</p><p><a href="../6">下一篇</a>    06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04 | 深入浅出索引（上）</title>
      <link href="/mysql45/4/"/>
      <url>/mysql45/4/</url>
      
        <content type="html"><![CDATA[<h1 id="04-深入浅出索引（上）"><a href="#04-深入浅出索引（上）" class="headerlink" title="04 | 深入浅出索引（上）"></a>04 | 深入浅出索引（上）</h1><p><font color="gray">2018-11-21 林晓斌</font></p><p><img src="../../images/mysql45/4/4.jpg"></p><p>提到数据库索引，我想你并不陌生，在日常工作中会经常接触到。比如某一个 SQL 查询比较慢，分析完原因之后，你可能就会说“给某个字段加个索引吧”之类的解决方案。但到底什么是索引，索引又是如何工作的呢？今天就让我们一起来聊聊这个话题吧。</p><p>数据库索引的内容比较多，我分成了上下两篇文章。索引是数据库系统里面最重要的概念之一，所以我希望你能够耐心看完。在后面的实战文章中，我也会经常引用这两篇文章中提到的知识点，加深你对数据库索引的理解。</p><p>一句话简单来说，<font color="#fa8919">索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。</font>一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p><h1 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h1><p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。</p><p>下面我主要从使用的角度，为你简单分析一下这三种模型的区别。</p><p>哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p><p>不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</p><p>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p><div style="text-align:center"><img src="../../images/mysql45/4/图%201%20哈希表示意图.png"><p><font color="gray">图 1 哈希表示意图</font></p></div><p>图中，User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。</p><p>需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。</p><p>你可以设想下，如果你现在要找身份证号在 [ID_card_X, ID_card_Y] 这个区间的所有用户，就必须全部扫描一遍了。</p><p>所以，<strong>哈希表这种结构适用于只有等值查询的场景</strong>，比如 Memcached 及其他一些 NoSQL 引擎。</p><p>而<strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p><div style="text-align:center"><img src="../../images/mysql45/4/图%202%20有序数组示意图.png"><p><font color="gray">图 2 有序数组示意图</font></p></div><p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到，这个时间复杂度是 O(log(N))。</p><p>同时很显然，这个索引结构支持范围查询。你要查身份证号在 [ID_card_X, ID_card_Y] 区间的 User，可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。</p><p>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p><p>所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。</p><p>二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示：</p><div style="text-align:center"><img src="../../images/mysql45/4/图%203%20二叉搜索树示意图.png"><p><font color="gray">图 3 二叉搜索树示意图</font></p></div><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。这个时间复杂度是 O(log(N))。</p><p>当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。</p><p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p><p>你可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。</p><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。</p><p>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><p>N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。</p><p>不管是哈希还是有序数组，或者 N 叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM 树等数据结构也被用于引擎设计中，这里我就不再一一展开了。</p><p>你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。</p><p>截止到这里，我用了半篇文章的篇幅和你介绍了不同的数据结构，以及它们的适用场景，你可能会觉得有些枯燥。但是，我建议你还是要多花一些时间来理解这部分内容，毕竟这是数据库处理数据的核心概念之一，在分析问题的时候会经常用到。当你理解了索引的模型后，就会发现在分析问题的时候会有一个更清晰的视角，体会到引擎设计的精妙之处。</p><p>现在，我们一起进入相对偏实战的内容吧。</p><p>在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。由于 InnoDB 存储引擎在 MySQL 数据库中使用最为广泛，所以下面我就以 InnoDB 为例，和你分析一下其中的索引模型。</p><h1 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h1><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p><p>每一个索引在 InnoDB 里面对应一棵 B+ 树。</p><p>假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。</p><p>这个表的建表语句是：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create table T(  id int primary key,   k int not null,   name varchar(16),  index (k)) engine=InnoDB;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。</p><div style="text-align:center"><img src="../../images/mysql45/4/图%204%20InnoDB%20的索引组织结构.png"><p><font color="gray">图 4 InnoDB 的索引组织结构</font></p></div><p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</p><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</p><p>根据上面的索引结构说明，我们来讨论一个问题：<strong>基于主键索引和普通索引的查询有什么区别？</strong></p><ul><li>如果语句是 <code>select * from T where ID=500</code>，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</li><li>如果语句是 <code>select * from T where k=5</code>，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p><p>而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p><p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</p><p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p><p>基于上面的索引维护过程说明，我们来讨论一个案例：</p><blockquote><p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p></blockquote><p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： <code>NOT NULL PRIMARY KEY AUTO_INCREMENT</code>。</p><p>插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。</p><p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p><p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p><p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p><p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。</p><p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p><p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p><p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p><ol><li>只有一个索引；</li><li>该索引必须是唯一索引。</li></ol><p>你一定看出来了，这就是典型的 KV 场景。</p><p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p><p>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我跟你分析了数据库引擎可用的数据结构，介绍了 InnoDB 采用的 B+ 树结构，以及为什么 InnoDB 要这么选择。B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。</p><p>由于 InnoDB 是索引组织表，一般情况下我会建议你创建一个自增主键，这样非主键索引占用的空间最小。但事无绝对，我也跟你讨论了使用业务逻辑字段做主键的应用场景。</p><p>最后，我给你留下一个问题吧。对于上面例子中的 InnoDB 表 T，如果你要重建索引 k，你的两个 SQL 语句可以这么写：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">alter table T drop index k;alter table T add index(k);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你要重建主键索引，也可以这么写：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">alter table T drop primary key;alter table T add primary key(id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我的问题是，对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好的方法是什么？</p><p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾给出我的参考答案。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我在上一篇文章末尾给你留下的问题是：如何避免长事务对业务的影响？</p><p>这个问题，我们可以从应用开发端和数据库端来看。</p><p><strong>首先，从应用开发端来看：</strong></p><ol><li>确认是否使用了 <code>set autocommit=0</code>。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 <code>1</code>。</li><li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。</li><li>业务连接数据库的时候，根据业务本身的预估，通过 <code>SET MAX_EXECUTION_TIME</code> 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。（为什么会意外？在后续的文章中会提到这类案例）</li></ol><p><strong>其次，从数据库端来看：</strong></p><ol><li>监控 <code>information_schema.Innodb_trx</code> 表，设置长事务阈值，超过就报警 / 或者 <code>kill</code>；</li><li>Percona 的 pt-kill 这个工具不错，推荐使用；</li><li>在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题；</li><li>如果使用的是 MySQL 5.6 或者更新版本，把 <code>innodb_undo_tablespaces</code> 设置成 <code>2</code>（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li></ol><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../3">上一篇</a>    03 | 事务隔离：为什么你改了我还看不见？</p><p><a href="../5">下一篇</a>    05 | 深入浅出索引（下）</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03 | 事务隔离：为什么你改了我还看不见？</title>
      <link href="/mysql45/3/"/>
      <url>/mysql45/3/</url>
      
        <content type="html"><![CDATA[<h1 id="03-事务隔离：为什么你改了我还看不见？"><a href="#03-事务隔离：为什么你改了我还看不见？" class="headerlink" title="03 | 事务隔离：为什么你改了我还看不见？"></a>03 | 事务隔离：为什么你改了我还看不见？</h1><p><font color="gray">2018-11-19 林晓斌</font></p><p><img src="../../images/mysql45/3/3.jpg"></p><p>提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友小王转 100 块钱，而此时你的银行卡只有 100 块钱。</p><p>转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这 100 块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。</p><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。</p><p>今天的文章里，我将会以 InnoDB 为例，剖析 MySQL 在事务支持方面的特定实现，并基于原理给出相应的实践建议，希望这些案例能加深你对 MySQL 事务原理的理解。</p><h1 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h1><p>提到事务，你肯定会想到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中 I，也就是“隔离性”。</p><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p><p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>其中“读提交”和“可重复读”比较难理解，所以我用一个例子说明这几种隔离级别。假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create table T(c int) engine=InnoDB;insert into T(c) values(1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="../../images/mysql45/3/%E4%BA%8B%E5%8A%A1.png"></p><p>我们来看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2、V3 的返回值分别是什么。</p><ul><li>若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。</li><li>若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。</li><li>若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li><li>若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。</li></ul><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p><p>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle 数据库的默认隔离级别其实就是“读提交”，因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”。</p><p>配置的方式是，将启动参数 <code>transaction-isolation</code> 的值设置成 <code>READ-COMMITTED</code>。你可以用<code> show variables</code> 来查看当前的值。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; show variables like 'transaction_isolation'; +-----------------------+----------------+| Variable_name         | Value          |+-----------------------+----------------+| transaction_isolation | READ-COMMITTED |+-----------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。我想<strong>你可能会问那什么时候需要“可重复读”的场景呢</strong>？我们来看一个数据校对逻辑的案例。</p><p>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p><h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。</p><p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志<del><font color="red">undo log</font></del>里面就会有类似下面的记录。</p><p><img src="../../images/mysql45/3/%E5%9B%9E%E6%BB%9A.png"></p><p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 <code>read-view</code>。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。</p><p>同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。</p><p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p><p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。</p><p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><p>在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。</p><p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p><h1 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h1><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL 的事务启动方式有以下几种：</p><ol><li>显式启动事务语句， <code>begin</code> 或 <code>start transaction</code>。配套的提交语句是 <code>commit</code>，回滚语句是 <code>rollback</code>。</li><li><code>set autocommit=0</code>，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 <code>commit</code> 或 <code>rollback</code> 语句，或者断开连接。</li></ol><p>有些客户端连接框架会默认连接成功后先执行一个 <code>set autocommit=0</code> 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p><p>因此，我会建议你总是使用 <code>set autocommit=1</code>, 通过显式语句的方式来启动事务。</p><p>但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用 commit work and chain 语法。</p><p>在 autocommit 为 1 的情况下，用 <code>begin</code> 显式启动的事务，如果执行 <code>commit</code> 则提交事务。如果执行 <code>commit work and chain</code>，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p><p>你可以在 <code>information_schema</code> 库的 <code>innodb_trx</code> 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这篇文章里面，我介绍了 MySQL 的事务隔离级别的现象和实现，根据实现原理分析了长事务存在的风险，以及如何用正确的方式避免长事务。希望我举的例子能够帮助你理解事务，并更好地使用 MySQL 的事务特性。</p><p>我给你留一个问题吧。你现在知道了系统里面应该避免长事务，如果你是业务开发负责人同时也是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢？</p><p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>在上期文章的最后，我给你留下的问题是一天一备跟一周一备的对比。</p><p>好处是“最长恢复时间”更短。</p><p>在一天一备的模式里，最坏情况下需要应用一天的 binlog。比如，你每天 0 点做一次全量备份，而要恢复出一个到昨天晚上 23 点的备份。</p><p>一周一备最坏情况就要应用一周的 binlog 了。</p><p>系统的对应指标就是 RTO（恢复目标时间）。</p><p>当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个 RTO 是成本换来的，就需要你根据业务重要性来评估了。</p><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../2">上一篇</a>    02 | 日志系统：一条SQL更新语句是如何执行的？</p><p><a href="../4">下一篇</a>    04 | 深入浅出索引（上）</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02 | 日志系统：一条SQL更新语句是如何执行的？</title>
      <link href="/mysql45/2/"/>
      <url>/mysql45/2/</url>
      
        <content type="html"><![CDATA[<h1 id="02-日志系统：一条SQL更新语句是如何执行的？"><a href="#02-日志系统：一条SQL更新语句是如何执行的？" class="headerlink" title="02 | 日志系统：一条SQL更新语句是如何执行的？"></a>02 | 日志系统：一条SQL更新语句是如何执行的？</h1><p><font color="gray">2018-11-16 林晓斌</font></p><p><img src="../../images/mysql45/2/2.jpg"></p><p>前面我们系统了解了一个查询语句的执行流程，并介绍了执行过程中涉及的处理模块。相信你还记得，一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。</p><p>那么，一条更新语句的执行流程又是怎样的呢？</p><p>之前你可能经常听 DBA 同事说，MySQL 可以恢复到半个月内任意一秒的状态，惊叹的同时，你是不是心中也会不免会好奇，这是怎样做到的呢？</p><p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 c：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; create table T(ID int primary key, c int);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; update T set c=c+1 where ID=2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前面我有跟你介绍过 SQL 语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p><div style="text-align:center"><img src="../../images/mysql45/1/MySQL%20的逻辑架构图.png"><p><font color="gray">MySQL 的逻辑架构图</font></p></div><p>你执行语句前要先连接数据库，这是连接器的工作。</p><p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p><p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。如果接触 MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log 和 binlog 在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。</p><h1 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h1><p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p><p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p><ul><li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li><li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li></ul><p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p><p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p><p>同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p>而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p><p>具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。</p><p>与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p><p><img src="../../images/mysql45/2/redolog.png"></p><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p><p>要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p><h1 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h1><p>前面我们讲过，MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p><p>我想你肯定会问，为什么会有两份日志呢？</p><p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p><p>这两种日志有以下三点不同。</p><ol><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><p>有了对这两个日志的概念性理解，我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。</p><ol><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ol><p>这里我给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p><div style="text-align:center"><img src="../../images/mysql45/2/update%20语句执行流程.png"><p><font color="gray">update 语句执行流程</font></p></div><p>你可能注意到了，最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是”两阶段提交”。</p><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：<strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p><p>前面我们说过了，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p><p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p><ul><li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li><li>然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。</li></ul><p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p><p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p><p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><p>仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p><ol><li><strong>先写 redo log 后写 binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。<br>但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。<br>然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。<del><font color="red">redo log提交后，事务是无法回滚的</font></del></li><li><strong>先写 binlog 后写 redo log</strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li></ol><p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p><p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？</p><p>其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 binlog 来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p><p>简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我介绍了 MySQL 里面最重要的两个日志，即物理日志 redo log 和逻辑日志 binlog。</p><p>redo log 用于保证 crash-safe 能力。<code>innodb_flush_log_at_trx_commit</code> 这个参数设置成 <code>1</code> 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。</p><p><code>sync_binlog</code> 这个参数设置成 <code>1</code> 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</p><p>我还跟你介绍了与 MySQL 日志系统密切相关的“两阶段提交”。两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到。</p><p>文章的最后，我给你留一个思考题吧。前面我说到定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？</p><p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾给出我的答案。</p><p>感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../1">上一篇</a>    01 | 基础架构：一条SQL查询语句是如何执行的？</p><p><a href="../3">下一篇</a>    03 | 事务隔离：为什么你改了我还看不见？</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01 | 基础架构：一条SQL查询语句是如何执行的？</title>
      <link href="/mysql45/1/"/>
      <url>/mysql45/1/</url>
      
        <content type="html"><![CDATA[<h1 id="01-基础架构：一条SQL查询语句是如何执行的？"><a href="#01-基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="01 | 基础架构：一条SQL查询语句是如何执行的？"></a>01 | 基础架构：一条SQL查询语句是如何执行的？</h1><p><font color="gray">2018-11-14 林晓斌</font></p><p><img src="../../images/mysql45/1/1.jpg"></p><p>你好，我是林晓斌。</p><p>这是专栏的第一篇文章，我想来跟你聊聊 MySQL 的基础架构。我们经常说，看一个事儿千万不要直接陷入细节里，你应该先鸟瞰其全貌，这样能够帮助你从高维度理解问题。同样，对于 MySQL 的学习也是这样。平时我们使用数据库，看到的通常都是一个整体。比如，你有个最简单的表，表里只有一个 ID 字段，在执行下面这个查询语句时：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from T where ID=10；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。</p><p>所以今天我想和你一起把 MySQL 拆解一下，看看里面都有哪些“零件”，希望借由这个拆解过程，让你对 MySQL 有更深入的理解。这样当我们碰到 MySQL 的一些异常或者问题时，就能够直戳本质，更为快速地定位并解决问题。</p><p>下面我给出的是 MySQL 的基本架构示意图，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。</p><div style="text-align:center"><img src="../../images/mysql45/1/MySQL%20的逻辑架构图.png"><p><font color="gray">MySQL 的逻辑架构图</font></p></div><p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。</p><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p><p>也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 <code>create table</code> 语句中使用 <code>engine=memory</code>, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。</p><p>从图中不难看出，不同的存储引擎共用一个<strong>Server 层</strong>，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。</p><h1 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h1><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -h<span class="token variable">$ip</span> -P<span class="token variable">$port</span> -u<span class="token variable">$user</span> -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在 <code>-p</code> 后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p><p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 <code>show processlist</code> 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p><img src="../../images/mysql45/1/processlist.png"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <code>wait_timeout</code> 控制的，默认值是 <code>8</code> 小时。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection</code> 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><p>连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句<del><font color="red">关键字大小写以及空格数不一样，键都不一致</font></del>，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 <code>query_cache_type</code> 设置成 <code>DEMAND</code>，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 <code>SQL_CACHE</code> 显式指定，像下面这个语句一样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> SQL_CACHE * from T where <span class="token assign-left variable">ID</span><span class="token operator">=</span><span class="token number">10</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</p><h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h1><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</p><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</p><p>MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; elect * from t where ID=1; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p><h1 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h1><p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li><li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。</p><h1 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h1><p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from T where ID=10; ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个 <code>rows_examined</code> 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟 rows_examined 并不是完全相同的。</strong>我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天我给你介绍了 MySQL 的逻辑架构，希望你对一个 SQL 语句完整执行流程的各个阶段有了一个初步的印象。由于篇幅的限制，我只是用一个查询的例子将各个环节过了一遍。如果你还对每个环节的展开细节存有疑问，也不用担心，后续在实战章节中我还会再提到它们。</p><p>我给你留一个问题吧，如果表 T 中没有字段 k，而你执行了这个语句 <code>select * from T where k=1</code>, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？<del><font color="red">分析器</font></del></p><p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。</p><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../0">上一篇</a>    开篇词 | 这一次，让我们一起来搞懂MySQL</p><p><a href="../2">下一篇</a>    02 | 日志系统：一条SQL更新语句是如何执行的？</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开篇词 | 这一次，让我们一起来搞懂MySQL</title>
      <link href="/mysql45/0/"/>
      <url>/mysql45/0/</url>
      
        <content type="html"><![CDATA[<h1 id="开篇词-这一次，让我们一起来搞懂MySQL"><a href="#开篇词-这一次，让我们一起来搞懂MySQL" class="headerlink" title="开篇词 | 这一次，让我们一起来搞懂MySQL"></a>开篇词 | 这一次，让我们一起来搞懂MySQL</h1><p><font color="gray">2018-11-12 林晓斌</font></p><p><img src="../../images/mysql45/0/0.jpg"></p><p>你好，我是林晓斌，网名“丁奇”，欢迎加入我的专栏，和我一起开始 <code>MySQL</code> 学习之旅。我曾先后在百度和阿里任职，从事 <code>MySQL</code> 数据库方面的工作，一步步地从一个数据库小白成为 <code>MySQL</code> 内核开发人员。回想起来，从我第一次带着疑问翻 <code>MySQL</code> 的源码查到答案至今，已经有十个年头了。在这个过程中，走了不少弯路，但同时也收获了很多的知识和思考，希望能在这个专栏里分享给你。</p><p>记得刚开始接触 <code>MySQL</code>，是我在百度贴吧做权限系统的时候。我们遇到了一个奇怪的问题，一个正常 <code>10</code> 毫秒就能完成的 <code>SQL</code> 查询请求偶尔要执行 <code>100</code> 多毫秒才结束。当时主管问我是什么原因，我其实也搞不清楚，就上网查答案，但怎么找都找不到，又脸皮薄不想说自己不知道，只好硬着头皮翻源码。后来遇到了越来越多的问题，也是类似的情景，所以我逐步养成了通过分析源码理解原理的习惯。</p><p>当时，我自己的感觉是，即使我只是一个开发工程师，只是 <code>MySQL</code> 的用户，在了解了一个个系统模块的原理后，再来使用它，感觉是完全不一样的。当在代码里写下一行数据库命令的时候，我就能想到它在数据库端将怎么执行，它的性能是怎么样的，怎样写能让我的应用程序访问数据库的性能最高。进一步，哪些数据处理让数据库系统来做性能会更好，哪些数据处理在缓存里做性能会更好，我心里也会更清楚。在建表和建索引的时候，我也会更有意识地为将来的查询优化做综合考虑，比如确定是否使用递增主键、主键的列怎样选择，等等。</p><p>但随后我又有了一个新的困惑，我觉得自己了解的 <code>MySQL</code> 知识点是零散的，没有形成网络。于是解决完一个问题后，很容易忘记。再碰到类似的问题，我又得再翻一次代码。</p><p>所幸在阿里工作的时候，我参与了阿里云关系型数据库服务内核的开发，并且负责开发开源分支 <code>AliSQL</code>，让我对 <code>MySQL</code> 内核和源码有了更深层次的研究和理解。在服务内部客户和公有云客户的过程中，我有机会面对和解决足够多的问题，再通过手册进行系统的学习，算是比较坎坷地将 <code>MySQL</code> 的知识网络补了起来。</p><p>所以，在回顾这个过程的时候，我的第一个感受是，如果一开始就有一些从理论到实战的系统性指导，那该多好啊，也许我可以学习得更快些。</p><p>在极客时间团队跟我联系策划这个专栏的时候，我还是持怀疑态度的。为什么呢？现在不比当年了，犹记得十余年前，你使用 <code>MySQL</code> 的过程中碰到问题的话，基本上都只能到代码里去找答案，因为那时网上的资料太少了。</p><p>而近十年来，<code>MySQL</code> 在中国广泛普及，技术分享文章可以说是浩如烟海。所以，现在要系统地介绍一遍 <code>MySQL</code> 的话，恐怕里面提及的大多数知识点，都可以在社区文章中找到。那么我们做这个专栏的意义在哪里，而它又凭什么可以收费呢？</p><p>直到收到极客时间团队的答复，我才开始对这个专栏“想做和可以做”的事情感觉清晰起来。数据库是一个综合系统，其背后是发展了几十年的数据库理论。同时，数据库系统也是一个应用系统，可能一个业务开发人员用了两三年 <code>MySQL</code>，还未必清楚那些自己一直在用的“最佳实践”为什么是最佳的。</p><p>于是，我希望这个专栏能够帮助这样的一些开发者：他们正在使用 <code>MySQL</code>，知道如何写出逻辑正确的 <code>SQL</code> 语句来实现业务目标，却不确定这个语句是不是最优的；他们听说了一些使用数据库的最佳实践，但是更想了解为什么这么做；他们使用的数据库偶尔会出问题，亟需了解如何更快速、更准确地定位问题，甚至自己解决问题……</p><p>在过去的七年里，我带过十几个应届毕业生，看着他们成长，要求他们原理先行，再实践验证。几年下来，他们的成长速度都很快，其中好几个毕业没两年就成为团队的骨干力量了。我也在社招的时候面试过很多有着不错的运维实践经验和能力的候选人，但都因为对数据库原理仅有一知半解的了解，而最终遗憾地没有通过面试。</p><p>因此，我希望这个专栏能够激发开发者对数据库原理的探索欲，从而更好地理解工作中遇到的问题，更能知道背后的为什么。所以<strong>我会选那些平时使用数据库时高频出现的知识，如事务、索引、锁等内容构成专栏的主线</strong>。这些主线上是一个个的知识点。每个点就是一个概念、一个机制或者一个原理说明。在每个说明之后，我会和你讨论一个实践相关的问题。</p><p>希望能以这样的方式，让你对 <code>MySQL</code> 的几条主线有一个整体的认识，并且了解基本概念。在之后的实践篇中，我会引用到这些主线的知识背景，并着力说明它们是怎样指导实践的。这样，<strong>你可以从点到线，再到面，形成自己的 <code>MySQL</code> 知识网络。</strong></p><p>在这里，有一份目录，你也可以先了解下整个专栏的知识结构。</p><p><img src="../../images/mysql45/0/outline.jpg"></p><p>如前面说的，这几条主线上的每个知识点几乎都不是最新的，有些甚至十年前就这样，并没有改过。但我希望针对这些点的说明，可以让你在使用 <code>MySQL</code> 时心里更有底，知道怎么做选择，并且明白为什么。了解了原理，才能在实践中不断创新，提升个人的价值和工作输出。</p><p>从这里开始，跟我一起搞懂 <code>MySQL</code>!</p><p><img src="../../images/mysql45/%E4%B8%81%E5%A5%87.jpg"></p><hr><p><a href="../1">下一篇</a>    01 | 基础架构：一条SQL查询语句是如何执行的？</p>]]></content>
      
      
      <categories>
          
          <category> MySQL实战45讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 739 题：每日温度（中等）</title>
      <link href="/leetcode/739/"/>
      <url>/leetcode/739/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-739-题：每日温度"><a href="#「力扣」第-739-题：每日温度" class="headerlink" title="「力扣」第 739 题：每日温度"></a>「力扣」第 739 题：每日温度</h2><ul><li><a href="https://leetcode.cn/problems/daily-temperatures/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组&nbsp;<code>temperatures</code>&nbsp;，表示每天的温度，返回一个数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>&nbsp;是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用&nbsp;<code>0</code> 来代替。</p><p>&nbsp;</p><pre><strong>示例 1:</strong><strong>输入:</strong> <span>temperatures</span> = [73,74,75,71,69,72,76,73]<strong>输出:</strong>&nbsp;[1,1,4,2,1,1,0,0]</pre><pre><strong>示例 2:</strong><strong>输入:</strong> temperatures = [30,40,50,60]<strong>输出:</strong>&nbsp;[1,1,1,0]</pre><pre><strong>示例 3:</strong><strong>输入:</strong> temperatures = [30,60,90]<strong>输出: </strong>[1,1,0]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;=&nbsp;temperatures.length &lt;= 10<sup>5</sup></code></li>  <li><code>30 &lt;=&nbsp;temperatures[i]&nbsp;&lt;= 100</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：单调栈"><a href="#参考代码：单调栈" class="headerlink" title="参考代码：单调栈"></a>参考代码：单调栈</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temperatures<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>temperatures<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次严格递减。</span>        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> temperatures<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> temperatures<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> temperatures<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> index <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> index<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 647 题：回文子串（中等）</title>
      <link href="/leetcode/647/"/>
      <url>/leetcode/647/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-647-题：回文子串"><a href="#「力扣」第-647-题：回文子串" class="headerlink" title="「力扣」第 647 题：回文子串"></a>「力扣」第 647 题：回文子串</h2><ul><li><a href="https://leetcode.cn/problems/palindromic-substrings/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/5/">「力扣」第 5 题：最长回文子串</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>s = "abc"<strong>输出：</strong>3<strong>解释：</strong>三个回文子串: "a", "b", "c"</pre><pre><strong>示例 2：</strong><strong>输入：</strong>s = "aaa"<strong>输出：</strong>6<strong>解释：</strong>6个回文子串: "a", "a", "a", "aa", "aa", "aaa"</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= s.length &lt;= 1000</code></li>    <li><code>s</code> 由小写英文字母组成</li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：Manacher-算法"><a href="#参考代码：Manacher-算法" class="headerlink" title="参考代码：Manacher 算法"></a>参考代码：Manacher 算法</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countSubstrings</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 添加特殊字符 '#' 的字符数组（该字符可以与原字符串中字符一样）</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> wrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> wrap<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            wrap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token char">'#'</span> <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// p[i] 表示以 wrap[i] 为中心最长回文串的回文半径</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>wrap<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 已经遍历的所有回文子串的最右边下标，其对应的最左下标为 left</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// right 所属回文子串中心下标</span>        <span class="token keyword">int</span> center <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> wrap<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 子串 [left, right] 中 i 关于其中心的对称位置</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>center <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> i<span class="token punctuation">;</span>                <span class="token comment">// 定义一个临时变量，避免多次计算其值</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> right <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 情况一：j 为中心的最长回文串没有超出范围 (left, right)</span>                    <span class="token comment">// 情况二：j 为中心的最长回文串已经超出了范围 [left, right]</span>                    p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">)</span> <span class="token operator">?</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">:</span> temp<span class="token punctuation">;</span>                    res <span class="token operator">+=</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment">// 情况三：j 为中心的最长回文串左边界刚好是 left</span>                    p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">expand</span><span class="token punctuation">(</span>wrap<span class="token punctuation">,</span> i <span class="token operator">-</span> temp<span class="token punctuation">,</span> i <span class="token operator">+</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">// 情况四：i &gt;= right</span>                p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">expand</span><span class="token punctuation">(</span>wrap<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res <span class="token operator">+=</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 执行到此，i 为中心的最长回文串右边界必然不会小于 right。更新最右边界。</span>            right <span class="token operator">=</span> i <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            center <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">expand</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> wrap<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">&lt;</span> wrap<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> wrap<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> wrap<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            left<span class="token operator">--</span><span class="token punctuation">;</span>            right<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 回文直径为 (right - left - 2) + 1</span>        <span class="token comment">// 因此回文半径 = (right - left) &gt;&gt; 1</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Manacher 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 621 题：任务调度器（中等）</title>
      <link href="/leetcode/621/"/>
      <url>/leetcode/621/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-621-题：任务调度器"><a href="#「力扣」第-621-题：任务调度器" class="headerlink" title="「力扣」第 621 题：任务调度器"></a>「力扣」第 621 题：任务调度器</h2><ul><li><a href="https://leetcode.cn/problems/task-scheduler/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个用字符数组&nbsp;<code>tasks</code> 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p><p>然而，两个<strong> 相同种类</strong> 的任务之间必须有长度为整数<strong> </strong><code>n</code><strong> </strong>的冷却时间，因此至少有连续 <code>n</code> 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的<strong> 最短时间</strong> 。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>tasks = ["A","A","A","B","B","B"], n = 2<strong>输出：</strong>8<strong>解释：</strong>A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 </pre><pre><strong>示例 2：</strong><strong>输入：</strong>tasks = ["A","A","A","B","B","B"], n = 0<strong>输出：</strong>6<strong>解释：</strong>在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0["A","A","A","B","B","B"]["A","B","A","B","A","B"]["B","B","B","A","A","A"]...诸如此类</pre><pre><strong>示例 3：</strong><strong>输入：</strong>tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2<strong>输出：</strong>16<strong>解释：</strong>一种可能的解决方案是：     A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= task.length &lt;= 10<sup>4</sup></code></li>  <li><code>tasks[i]</code> 是大写英文字母</li>  <li><code>n</code> 的取值范围为 <code>[0, 100]</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：贪心"><a href="#参考代码：贪心" class="headerlink" title="参考代码：贪心"></a>参考代码：贪心</h3><p>所有任务种类中执行次数最多的那一种的执行次数为 <code>maxExec</code> ，如果需要执行 <code>maxExec</code> 次的任务的数量为 <code>maxCount</code> ，需要的最少时间就是 <code>(maxExec − 1) * (n + 1) + maxCount</code> 和 <code>∣task∣</code> 中的较大值。</p><blockquote><p>时间复杂度：$O(target + 26)$</p><p>空间复杂度：$O(26)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">leastInterval</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tasks<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 键存储任务种类名，值存储该任务种类在任务列表中出现的次数</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> freq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 最多的执行次数</span>        <span class="token keyword">int</span> maxExec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> task <span class="token operator">:</span> tasks<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Integer</span> exec <span class="token operator">=</span> freq<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            freq<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> exec<span class="token punctuation">)</span><span class="token punctuation">;</span>            maxExec <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxExec<span class="token punctuation">,</span> exec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 具有最多执行次数的任务数量</span>        <span class="token keyword">int</span> maxCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> freq<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> maxExec<span class="token punctuation">)</span> <span class="token punctuation">{</span>                maxCount<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxExec <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> maxCount<span class="token punctuation">,</span> tasks<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 617 题：合并二叉树（简单）</title>
      <link href="/leetcode/617/"/>
      <url>/leetcode/617/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-617-题：合并二叉树"><a href="#「力扣」第-617-题：合并二叉树" class="headerlink" title="「力扣」第 617 题：合并二叉树"></a>「力扣」第 617 题：合并二叉树</h2><ul><li><a href="https://leetcode.cn/problems/merge-two-binary-trees/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p>&nbsp;</p><pre><strong>示例 1：</strong> <img alt="" src="../../images/leetcode/617/merge.jpg" style="height: 163px; width: 600px;"> <strong>输入：</strong>root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]<strong>输出：</strong>[3,4,5,5,4,null,7]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>root1 = [1], root2 = [1,2]<strong>输出：</strong>[2,2]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li>  <li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li> </ul><p></p><p>&nbsp;</p><p><strong>二叉树结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：深度优先搜索"><a href="#参考代码：深度优先搜索" class="headerlink" title="参考代码：深度优先搜索"></a>参考代码：深度优先搜索</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root1<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> root2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> root2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> root1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">TreeNode</span> merged <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>val <span class="token operator">+</span> root2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        merged<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        merged<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> merged<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 581 题：最短无序连续子数组（中等）</title>
      <link href="/leetcode/581/"/>
      <url>/leetcode/581/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-581-题：最短无序连续子数组"><a href="#「力扣」第-581-题：最短无序连续子数组" class="headerlink" title="「力扣」第 581 题：最短无序连续子数组"></a>「力扣」第 581 题：最短无序连续子数组</h2><ul><li><a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/300/">「力扣」第 300 题：最长递增子序列</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> ，你需要找出一个 <strong>连续子数组</strong> ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 <strong>最短</strong> 子数组，并输出它的长度。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [2,6,4,8,10,9,15]<strong>输出：</strong>5<strong>解释：</strong>你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums = [1,2,3,4]<strong>输出：</strong>0</pre><pre><strong>示例 3：</strong><strong>输入：</strong>nums = [1]<strong>输出：</strong>0</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>  <li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li> </ul><p></p><p>&nbsp;</p><p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(n)</code> 的解决方案吗？</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：贪心"><a href="#参考代码：贪心" class="headerlink" title="参考代码：贪心"></a>参考代码：贪心</h3><p><img src="F:\blog\iiifox\source\images\leetcode\581\题解.png"></p><p><code>nums[0, left-1]</code> 是 <code>nums</code> 左端最长递增子数组；<code>nums[right+1, N)</code> 是 <code>nums</code> 右端最长递增子数组。</p><p><strong>贪心策略如下：</strong></p><ul><li>从左到右维护一个递增的子序列，如果遇到数 <code>num</code> 不在递增子序列中，则记录下标。最后一个被记录下来的下标即 <code>right</code>；</li><li>从右到左维护一个递减的子序列，如果遇到数 <code>num</code> 不在递减子序列中，则记录下标。最后一个被记录下来的下标即 <code>left</code>；</li></ul><p>我们可以用变量 <code>leftToRightMax</code> 来标识递增子序列，用变量 <code>rightToLeftMin</code> 来标识递减子序列。</p><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findUnsortedSubarray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 恒有 nums[0, left-1] &lt;= nums[left, right] &lt;= nums[right+1, N)</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rightToLeftMin <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> leftToRightMax <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 从左往右维护数组最大值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>leftToRightMax <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                leftToRightMax <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 从右往左维护数组最小值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rightToLeftMin <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span><span class="token class-name">N</span> <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> <span class="token class-name">N</span> <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                rightToLeftMin <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token class-name">N</span> <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>right <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 560 题：和为 K 的子数组（中等）</title>
      <link href="/leetcode/560/"/>
      <url>/leetcode/560/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-560-题：和为-K-的子数组"><a href="#「力扣」第-560-题：和为-K-的子数组" class="headerlink" title="「力扣」第 560 题：和为 K 的子数组"></a>「力扣」第 560 题：和为 K 的子数组</h2><ul><li><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/1/">「力扣」第 1 题：两数之和</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> 和一个整数&nbsp;<code>k</code> ，请你统计并返回该数组中和为&nbsp;<code>k</code><strong>&nbsp;</strong>的连续子数组的个数&nbsp;。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [1,1,1], k = 2<strong>输出：</strong>2</pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums = [1,2,3], k = 3<strong>输出：</strong>2</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>  <li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>  <li><code>-10<sup>7</sup> &lt;= k &lt;= 10<sup>7</sup></code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：前缀和"><a href="#参考代码：前缀和" class="headerlink" title="参考代码：前缀和"></a>参考代码：前缀和</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">subarraySum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 以前缀和为键，出现次数为对应的值</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> prefixSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            prefixSum <span class="token operator">+=</span> num<span class="token punctuation">;</span>            <span class="token comment">// 以当前数结尾的和为 k 的连续子数组个数</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>prefixSum <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">+=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>prefixSum <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>prefixSum<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>prefixSum<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 543 题：二叉树的直径（简单）</title>
      <link href="/leetcode/543/"/>
      <url>/leetcode/543/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-543-题：二叉树的直径"><a href="#「力扣」第-543-题：二叉树的直径" class="headerlink" title="「力扣」第 543 题：二叉树的直径"></a>「力扣」第 543 题：二叉树的直径</h2><ul><li><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/104/">「力扣」第 104 题：二叉树的最大深度</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>&nbsp;</p><pre><strong>示例 :</strong><br> 给定二叉树<br>          1         / \        2   3       / \           4   5    </pre><p>返回&nbsp;<strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者&nbsp;[5,2,1,3]。</p><p>&nbsp;</p><p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p><p>&nbsp;</p><p><strong>二叉树结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：深度优先搜索"><a href="#参考代码：深度优先搜索" class="headerlink" title="参考代码：深度优先搜索"></a>参考代码：深度优先搜索</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(height)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">diameterOfBinaryTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 以 root 为根节点的子树的深度     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">depth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> leftDepth <span class="token operator">=</span> <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rightDepth <span class="token operator">=</span> <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> leftDepth <span class="token operator">+</span> rightDepth<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftDepth<span class="token punctuation">,</span> rightDepth<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 538 题：把二叉搜索树转换为累加树（中等）</title>
      <link href="/leetcode/538/"/>
      <url>/leetcode/538/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-538-题：把二叉搜索树转换为累加树"><a href="#「力扣」第-538-题：把二叉搜索树转换为累加树" class="headerlink" title="「力扣」第 538 题：把二叉搜索树转换为累加树"></a>「力扣」第 538 题：把二叉搜索树转换为累加树</h2><ul><li><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出二叉<strong> 搜索 </strong>树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code>&nbsp;的新值等于原树中大于或等于&nbsp;<code>node.val</code>&nbsp;的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul>  <li>节点的左子树仅包含键<strong> 小于 </strong>节点键的节点。</li>  <li>节点的右子树仅包含键<strong> 大于</strong> 节点键的节点。</li>  <li>左右子树也必须是二叉搜索树。</li> </ul><p><strong>注意：</strong>本题和 1038:&nbsp;<a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><p><strong><img alt="" src="../../images/leetcode/538/tree.png" style="height: 364px; width: 534px;"></strong></p><pre><strong>输入：</strong>[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<strong>输出：</strong>[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>root = [0,null,1]<strong>输出：</strong>[1,null,1]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>root = [1,0,2]<strong>输出：</strong>[3,3,2]</pre><pre><strong>示例 4：</strong><strong>输入：</strong>root = [3,2,4,1]<strong>输出：</strong>[7,9,4,10]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li>树中的节点数介于 <code>0</code>&nbsp;和 <code>10<sup>4</sup></code><sup>&nbsp;</sup>之间。</li>  <li>每个节点的值介于 <code>-10<sup>4</sup></code>&nbsp;和&nbsp;<code>10<sup>4</sup></code>&nbsp;之间。</li>  <li>树中的所有值 <strong>互不相同</strong> 。</li>  <li>给定的树为二叉搜索树。</li> </ul><p></p><p>&nbsp;</p><p><strong>二叉树结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：深度优先搜索"><a href="#参考代码：深度优先搜索" class="headerlink" title="参考代码：深度优先搜索"></a>参考代码：深度优先搜索</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">convertBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">convertBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            sum <span class="token operator">+=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>            root<span class="token punctuation">.</span>val <span class="token operator">=</span> sum<span class="token punctuation">;</span>            <span class="token function">convertBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 494 题：目标和（中等）</title>
      <link href="/leetcode/494/"/>
      <url>/leetcode/494/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-494-题：目标和"><a href="#「力扣」第-494-题：目标和" class="headerlink" title="「力扣」第 494 题：目标和"></a>「力扣」第 494 题：目标和</h2><ul><li><a href="https://leetcode.cn/problems/target-sum/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/416/">「力扣」第 416 题：分割等和子集</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加&nbsp;<code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul>  <li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>"+2-1"</code> 。</li> </ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [1,1,1,1,1], target = 3<strong>输出：</strong>5<strong>解释：</strong>一共有 5 种方法让最终目标和为 3 。-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3</pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums = [1], target = 1<strong>输出：</strong>1</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= nums.length &lt;= 20</code></li>  <li><code>0 &lt;= nums[i] &lt;= 1000</code></li>  <li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li>  <li><code>-1000 &lt;= target &lt;= 1000</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：动态规划"><a href="#参考代码：动态规划" class="headerlink" title="参考代码：动态规划"></a>参考代码：动态规划</h3><blockquote><p>时间复杂度：$O(n \times (sum-target))$</p><p>空间复杂度：$O(sum - target)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 记数组的元素和为 sum ，添加负号的元素之和为 neg 。有 target=(sum-neg)-neg</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> differ <span class="token operator">=</span> sum <span class="token operator">-</span> target<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>differ <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>differ <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> neg <span class="token operator">=</span> differ <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// dp[i] 表示在数组中选取元素，使得这些元素之和等于 j 的方案数。</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>neg <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> neg<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> num<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> num<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>neg<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 461 题：汉明距离（简单）</title>
      <link href="/leetcode/461/"/>
      <url>/leetcode/461/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-461-题：汉明距离"><a href="#「力扣」第-461-题：汉明距离" class="headerlink" title="「力扣」第 461 题：汉明距离"></a>「力扣」第 461 题：汉明距离</h2><ul><li><a href="https://leetcode.cn/problems/hamming-distance/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>两个整数之间的 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p><p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>x = 1, y = 4<strong>输出：</strong>2<strong>解释：</strong>1   (0 0 0 1)4   (0 1 0 0)       ↑   ↑上面的箭头指出了对应二进制位不同的位置。</pre><pre><strong>示例 2：</strong><strong>输入：</strong>x = 3, y = 1<strong>输出：</strong>1</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>0 &lt;=&nbsp;x, y &lt;= 2<sup>31</sup> - 1</code></li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：位运算"><a href="#参考代码：位运算" class="headerlink" title="参考代码：位运算"></a>参考代码：位运算</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> z <span class="token operator">=</span> x <span class="token operator">^</span> y<span class="token punctuation">;</span> z <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> z <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">+=</span> z <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 448 题：找到所有数组中消失的数字（简单）</title>
      <link href="/leetcode/448/"/>
      <url>/leetcode/448/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-448-题：找到所有数组中消失的数字"><a href="#「力扣」第-448-题：找到所有数组中消失的数字" class="headerlink" title="「力扣」第 448 题：找到所有数组中消失的数字"></a>「力扣」第 448 题：找到所有数组中消失的数字</h2><ul><li><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [4,3,2,7,8,2,3,1]<strong>输出：</strong>[5,6]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums = [1,1]<strong>输出：</strong>[2]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>n == nums.length</code></li>    <li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>    <li><code>1 &lt;= nums[i] &lt;= n</code></li></ul><p></p><p><strong>进阶：</strong>你能在不使用额外空间且时间复杂度为<em> </em><code>O(n)</code><em> </em>的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：哈希表"><a href="#参考代码：哈希表" class="headerlink" title="参考代码：哈希表"></a>参考代码：哈希表</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$  <code>返回数组不计入额外空间</code></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">findDisappearedNumbers</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">+=</span> n<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 438 题：找到字符串中所有字母异位词（中等）</title>
      <link href="/leetcode/438/"/>
      <url>/leetcode/438/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-438-题：找到字符串中所有字母异位词"><a href="#「力扣」第-438-题：找到字符串中所有字母异位词" class="headerlink" title="「力扣」第 438 题：找到字符串中所有字母异位词"></a>「力扣」第 438 题：找到字符串中所有字母异位词</h2><ul><li><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/76/">「力扣」第 76 题：最小覆盖子串</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串&nbsp;<code>s</code>&nbsp;和 <code>p</code>，找到&nbsp;<code>s</code><strong>&nbsp;</strong>中所有&nbsp;<code>p</code><strong>&nbsp;</strong>的&nbsp;<strong>异位词&nbsp;</strong>的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>异位词 </strong>指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p>&nbsp;</p><pre><strong>示例&nbsp;1:</strong><strong>输入: </strong>s = "cbaebabacd", p = "abc"<strong>输出: </strong>[0,6]<strong>解释:</strong>起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。</pre><pre><strong>&nbsp;示例 2:</strong><strong>输入: </strong>s = "abab", p = "ab"<strong>输出: </strong>[0,1,2]<strong>解释:</strong>起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。</pre><p>&nbsp;</p><p><strong>提示:</strong></p><ul>  <li><code>1 &lt;= s.length, p.length &lt;= 3 * 10<sup>4</sup></code></li>  <li><code>s</code>&nbsp;和&nbsp;<code>p</code>&nbsp;仅包含小写字母</li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：滑动窗口"><a href="#参考代码：滑动窗口" class="headerlink" title="参考代码：滑动窗口"></a>参考代码：滑动窗口</h3><blockquote><p>时间复杂度：$O(m+n+26)$</p><p>空间复杂度：$O(m+n+26)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">findAnagrams</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">String</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// s 和 p 仅包含小写字母</span>        <span class="token comment">// 窗口数组，统计当前窗口内 p 中存在的字符出现的次数</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> window <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 统计字符串 p 中每个字符出现的次数</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pattern <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> p<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pattern<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 统计字符串 p 中不同字符数。differ 记录窗口内未完全匹配的字符数</span>        <span class="token keyword">int</span> differ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                differ<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> right <span class="token operator">&lt;</span> chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span> right<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> curChar <span class="token operator">=</span> chars<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 该字符在 p 中是存在的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pattern<span class="token punctuation">[</span>curChar <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                window<span class="token punctuation">[</span>curChar <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token comment">// 窗口内该字符出现的次数等于 p 中该字符的次数了</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">[</span>curChar <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>curChar <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    differ<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">// 当前窗口内已经涵盖 p 所有字符，此时左指针可以考虑右移了</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>differ <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 考虑左边界向右边走</span>                <span class="token keyword">char</span> leftChar <span class="token operator">=</span> chars<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// 即将出窗口的字符在 p 中是存在的</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pattern<span class="token punctuation">[</span>leftChar <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    window<span class="token punctuation">[</span>leftChar <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token comment">// 窗口内 leftChar 字符数已经少于 p 中的 leftChar 字符数了</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">[</span>leftChar <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> pattern<span class="token punctuation">[</span>leftChar <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        differ<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 437 题：路径总和 III（中等）</title>
      <link href="/leetcode/437/"/>
      <url>/leetcode/437/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-437-题：路径总和-III"><a href="#「力扣」第-437-题：路径总和-III" class="headerlink" title="「力扣」第 437 题：路径总和 III"></a>「力扣」第 437 题：路径总和 III</h2><ul><li><a href="https://leetcode.cn/problems/path-sum-iii/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树的根节点 <code>root</code>&nbsp;，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p><p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img src="../../images/leetcode/437/pathsum3-1-tree.jpg" style="width: 452px; "><strong>输入：</strong>root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8<strong>输出：</strong>3<strong>解释：</strong>和等于 8 的路径有 3 条，如图所示。</pre><pre><strong>示例 2：</strong><strong>输入：</strong>root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<strong>输出：</strong>3</pre><p>&nbsp;</p><p><strong>提示:</strong></p><ul>  <li>二叉树的节点个数的范围是 <code>[0,1000]</code></li>  <li>  <meta charset="UTF-8"><code>-10<sup>9</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>9</sup></code>&nbsp;</li>  <li><code>-1000&nbsp;&lt;= targetSum&nbsp;&lt;= 1000</code>&nbsp;</li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：回溯"><a href="#参考代码：回溯" class="headerlink" title="参考代码：回溯"></a>参考代码：回溯</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pathSum</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 前缀和表。以前缀和为键，值是键所对应的前缀和所出现的次数</span>        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 前缀和首部标兵 0</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">0L</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> root<span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">,</span> targetSum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span>                          <span class="token class-name">Long</span> currSum<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        currSum <span class="token operator">+=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token comment">// 以当前节点为目标路径的终点向上进行搜索，路径和为 targetSum 的路径数目</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>currSum <span class="token operator">-</span> targetSum<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 在前缀和表中更新当前结点对应的节点和</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>currSum<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>currSum<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 路径的下一个结点选择</span>        res <span class="token operator">+=</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> currSum<span class="token punctuation">,</span> targetSum<span class="token punctuation">)</span><span class="token punctuation">;</span>        res <span class="token operator">+=</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> currSum<span class="token punctuation">,</span> targetSum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 回溯。状态重置</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>currSum<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>currSum<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 416 题：分割等和子集（中等）</title>
      <link href="/leetcode/416/"/>
      <url>/leetcode/416/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-416-题：分割等和子集"><a href="#「力扣」第-416-题：分割等和子集" class="headerlink" title="「力扣」第 416 题：分割等和子集"></a>「力扣」第 416 题：分割等和子集</h2><ul><li><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/4/">「力扣」第 494 题：目标和</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个 <strong>只包含正整数 </strong>的 <strong>非空 </strong>数组&nbsp;<code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [1,5,11,5]<strong>输出：</strong>true<strong>解释：</strong>数组可以分割成 [1, 5, 5] 和 [11] 。</pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums = [1,2,3,5]<strong>输出：</strong>false<strong>解释：</strong>数组不能分割成两个元素和相等的子集。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= nums.length &lt;= 200</code></li>  <li><code>1 &lt;= nums[i] &lt;= 100</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：动态规划"><a href="#参考代码：动态规划" class="headerlink" title="参考代码：动态规划"></a>参考代码：动态规划</h3><p><strong><font color="red">方法一：未优化空间</font></strong></p><p><code>dp[i][j]</code> 表示从数组的 <code>[0,i]</code> 下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于 <code>j</code> 。</p><p><strong>状态转义方程：</strong></p><ul><li><code>dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]</code></li></ul><blockquote><p>时间复杂度：$O(n \times target)$</p><p>空间复杂度：$O(n \times target)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canPartition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 1 &lt;= nums[i] &lt;= 100</span>        <span class="token keyword">int</span> maxNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+=</span> num<span class="token punctuation">;</span>            maxNum <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxNum<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> target <span class="token operator">=</span> sum <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 如果和为奇数。或者最大数大于总和的一半。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sum <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token punctuation">(</span>maxNum <span class="token operator">&gt;</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// dp[i][j] 表示从数组的 [0,i] 下标范围内选取若干个正整数（可以是 0 个），</span>        <span class="token comment">// 是否存在一种选取方案使得被选取的正整数的和等于 j 。</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>target <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 当 i == 0 时，只有一个正整数 nums[0] 可以被选取</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// 如果不选取任何正整数，则被选取的正整数等于 0。</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 对于当前的数字 nums[i]，可以不选取也可以选取</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">||</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p><strong><font color="red">方法二：优化空间</font></strong></p><p>上述代码的空间复杂度是 <code>O(n×target)</code> 。但是可以发现在计算 <code>dp</code> 的过程中，每一行的 <code>dp</code> 值都只与上一行的 <code>dp</code> 值有关，因此只需要一个一维数组即可将空间复杂度降到 <code>O(target)</code> 。</p><p><strong>此时的转移方程为：</strong> </p><ul><li><code>dp[j] = dp[j] || dp[j-nums[i]]</code></li></ul><p><strong>需要注意的是</strong> 第二层的循环我们需要从大到小计算，因为如果我们从小到大更新 <code>dp</code> 值，那么在计算 <code>dp[j]</code> 值的时候，<code>dp[j−nums[i]]</code> 已经是被更新过的状态，不再是上一行的 <code>dp</code> 值。</p><p>即实际上使用的是 <code>dp[i][j-num[i]]</code> 而非 <code>dp[i-1][j-num[i]]</code> （因为从小到大计算的话，每一行的 <code>j - nums[i]</code> 会先于 <code>j</code> 更新）。</p><blockquote><p>时间复杂度：$O(n \times target)$</p><p>空间复杂度：$O(target)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canPartition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 1 &lt;= nums[i] &lt;= 100</span>        <span class="token keyword">int</span> maxNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+=</span> num<span class="token punctuation">;</span>            maxNum <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxNum<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> target <span class="token operator">=</span> sum <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 如果和为奇数。或者最大数大于总和的一半。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sum <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token punctuation">(</span>maxNum <span class="token operator">&gt;</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// dp[i] 表示是否存在一种选取方案使得被选取的正整数的和等于 i</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>target <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 当前数不大于目标值 j ，才会考虑添加。</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> target<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> num<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 对于当前的数字 nums[i]，可以不选取也可以选取</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">||</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> num<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 406 题：根据身高重建队列（中等）</title>
      <link href="/leetcode/406/"/>
      <url>/leetcode/406/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-406-题：根据身高重建队列"><a href="#「力扣」第-406-题：根据身高重建队列" class="headerlink" title="「力扣」第 406 题：根据身高重建队列"></a>「力扣」第 406 题：根据身高重建队列</h2><ul><li><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [h<sub>i</sub>, k<sub>i</sub>]</code> 表示第 <code>i</code> 个人的身高为 <code>h<sub>i</sub></code> ，前面 <strong>正好</strong> 有 <code>k<sub>i</sub></code><sub> </sub>个身高大于或等于 <code>h<sub>i</sub></code> 的人。</p><p>请你重新构造并返回输入数组&nbsp;<code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [h<sub>j</sub>, k<sub>j</sub>]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<strong>输出：</strong>[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]<strong>解释：</strong>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</pre><pre><strong>示例 2：</strong><strong>输入：</strong>people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]<strong>输出：</strong>[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= people.length &lt;= 2000</code></li>  <li><code>0 &lt;= h<sub>i</sub> &lt;= 10<sup>6</sup></code></li>  <li><code>0 &lt;= k<sub>i</sub> &lt; people.length</code></li>  <li>题目数据确保队列可以被重建</li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：排序"><a href="#参考代码：排序" class="headerlink" title="参考代码：排序"></a>参考代码：排序</h3><blockquote><p>时间复杂度：$O(n^2)$</p><p>空间复杂度：$O(logn)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">reconstructQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> people<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 按照身高从矮到高排序。身高一样，前面不矮于自己的人数多的排前面。</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>people<span class="token punctuation">,</span> <span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>                <span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> p1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>people<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 后添加的 person 会影响到前面添加的 person</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> person <span class="token operator">:</span> people<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 需要在未添加的位置处从左至右预留 person[1] 个位置给后面的 person</span>            <span class="token keyword">int</span> spaces <span class="token operator">=</span> person<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> res<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                spaces<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>spaces <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> person<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 399 题：除法求值（中等</title>
      <link href="/leetcode/399/"/>
      <url>/leetcode/399/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-399-题：除法求值"><a href="#「力扣」第-399-题：除法求值" class="headerlink" title="「力扣」第 399 题：除法求值"></a>「力扣」第 399 题：除法求值</h2><ul><li><a href="https://leetcode.cn/problems/evaluate-division/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [A<sub>i</sub>, B<sub>i</sub>]</code> 和 <code>values[i]</code> 共同表示等式 <code>A<sub>i</sub> / B<sub>i</sub> = values[i]</code> 。每个 <code>A<sub>i</sub></code> 或 <code>B<sub>i</sub></code> 是一个表示单个变量的字符串。</p><p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [C<sub>j</sub>, D<sub>j</sub>]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>C<sub>j</sub> / D<sub>j</sub> = ?</code> 的结果作为答案。</p><p>返回 <strong>所有问题的答案</strong> 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 <code>-1.0</code> 替代这个答案。</p><p><strong>注意：</strong>输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>equations = [["a","b"],["b","c"]], values = [2.0,3.0],     queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]<strong>输出：</strong>[6.00000,0.50000,-1.00000,1.00000,-1.00000]<strong>解释：</strong>条件：a / b = 2.0, b / c = 3.0问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0],    queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]<strong>输出：</strong>[3.75000,0.40000,5.00000,0.20000]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>equations = [["a","b"]], values = [0.5],     queries = [["a","b"],["b","a"],["a","c"],["x","y"]]<strong>输出：</strong>[0.50000,2.00000,-1.00000,-1.00000]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= equations.length &lt;= 20</code></li>  <li><code>equations[i].length == 2</code></li>  <li><code>1 &lt;= A<sub>i</sub>.length, B<sub>i</sub>.length &lt;= 5</code></li>  <li><code>values.length == equations.length</code></li>  <li><code>0.0 &lt; values[i] &lt;= 20.0</code></li>  <li><code>1 &lt;= queries.length &lt;= 20</code></li>  <li><code>queries[i].length == 2</code></li>  <li><code>1 &lt;= C<sub>j</sub>.length, D<sub>j</sub>.length &lt;= 5</code></li>  <li><code>A<sub>i</sub>, B<sub>i</sub>, C<sub>j</sub>, D<sub>j</sub></code> 由小写英文字母与数字组成</li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：并查集"><a href="#参考代码：并查集" class="headerlink" title="参考代码：并查集"></a>参考代码：并查集</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 父节点表。parent[i] 表示 i 的父亲结点     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parent<span class="token punctuation">;</span>    <span class="token comment">/**     * 权值表。weight[i] = (变量 i) / (变量 parent[i])     */</span>    <span class="token keyword">private</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> weight<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">calcEquation</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> equations<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values<span class="token punctuation">,</span>                                 <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> queries<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 已知条件中的变量名个数</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 通过哈希表将已知条件中的变量名映射成数组下标 count</span>        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> equations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>equations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>equations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> count<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>equations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>equations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> count<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">// 将每个变量结点的父亲结点设置为自身</span>        parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> parent<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 相对应的权值表此时也都为 1</span>        weight <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>weight<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将已知条件中每个条件中分子父亲节点的父节点都设置为分母的父亲节点，此时树最多三层</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> equations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">union</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>equations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>equations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 存放结果集的数组，其元素均被初始化为 -1.0</span>        <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">[</span>queries<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> res<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> query <span class="token operator">=</span> queries<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Integer</span> a <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>query<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Integer</span> b <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>query<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 分子与分母都是已知变量并且其可以求值（顶级父节点是同一个）</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> b <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">findParent</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">findParent</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> weight<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">/</span> weight<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 将分子 x 的父亲结点的父节点设置为分母的父节点     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">double</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 查找分子 x 的父亲结点</span>        <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">findParent</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将分子父亲节点 rootX 的父节点设置为分母 y 的父亲节点</span>        parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">findParent</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 修改相对应的权值表。 weight[x] * weight[rootX] = value * weight[y]</span>        weight<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> value <span class="token operator">*</span> weight<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">/</span> weight<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 查找 x 最顶层的父亲结点，并将向上查询路径上所有结点的父节点都设置为该顶级父节点     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findParent</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> origin <span class="token operator">=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 将 x 的父亲节点设置为其父节点的父节点</span>            parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">findParent</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 修改相对应的权值表</span>            weight<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> weight<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">*</span> weight<span class="token punctuation">[</span>origin<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 394 题：字符串解码（中等）</title>
      <link href="/leetcode/394/"/>
      <url>/leetcode/394/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-394-题：字符串解码"><a href="#「力扣」第-394-题：字符串解码" class="headerlink" title="「力扣」第 394 题：字符串解码"></a>「力扣」第 394 题：字符串解码</h2><ul><li><a href="https://leetcode.cn/problems/decode-string/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像&nbsp;<code>3a</code>&nbsp;或&nbsp;<code>2[4]</code>&nbsp;的输入。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>s = "3[a]2[bc]"<strong>输出：</strong>"aaabcbc"</pre><pre><strong>示例 2：</strong><strong>输入：</strong>s = "3[a2[c]]"<strong>输出：</strong>"accaccacc"</pre><pre><strong>示例 3：</strong><strong>输入：</strong>s = "2[abc]3[cd]ef"<strong>输出：</strong>"abcabccdcdcdef"</pre><pre><strong>示例 4：</strong><strong>输入：</strong>s = "abc3[cd]xyz"<strong>输出：</strong>"abccdcdcdxyz"</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= s.length &lt;= 30</code></li>  <li>  <meta charset="UTF-8"><code>s</code>&nbsp;由小写英文字母、数字和方括号  <meta charset="UTF-8">&nbsp;<code>'[]'</code> 组成</li>  <li><code>s</code>&nbsp;保证是一个&nbsp;<strong>有效</strong>&nbsp;的输入。</li>  <li><code>s</code>&nbsp;中所有整数的取值范围为  <meta charset="UTF-8">&nbsp;<code>[1, 300]</code>&nbsp;</li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：栈"><a href="#参考代码：栈" class="headerlink" title="参考代码：栈"></a>参考代码：栈</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">decodeString</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 数字栈</span>        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> digitStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 字符串栈</span>        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">StringBuilder</span><span class="token punctuation">&gt;</span></span> strStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token class-name">StringBuilder</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isDigit</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 数字，注意可能不止一位。</span>                number <span class="token operator">=</span> number <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'['</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 左方括号前面一定是数字，将其压入数字栈，并置零</span>                digitStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>                number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">// 将数字与上一个左方括号之间的字符串压入字符串栈中</span>                strStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">']'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 与其对应的左方括号之间的字符串即 res，出现的次数即数字栈栈顶元素</span>                <span class="token comment">// 字符串栈弹出栈顶字符串，并在其后将 res 拼接出现的次数</span>                <span class="token class-name">StringBuilder</span> temp <span class="token operator">=</span> strStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> count <span class="token operator">=</span> digitStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    temp<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                res <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">// 字符属于左方括号与数字之间，直接拼接在字符串 res 中</span>                res<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 347 题：前 K 个高频元素（中等）</title>
      <link href="/leetcode/347/"/>
      <url>/leetcode/347/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-347-题：前-K-个高频元素"><a href="#「力扣」第-347-题：前-K-个高频元素" class="headerlink" title="「力扣」第 347 题：前 K 个高频元素"></a>「力扣」第 347 题：前 K 个高频元素</h2><ul><li><a href="https://leetcode.cn/problems/top-k-frequent-elements/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/215">「力扣」第 215 题：数组中的第K个最大元素</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>&nbsp;</p><pre><strong>示例 1:</strong><strong>输入: </strong>nums = [1,1,1,2,2,3], k = 2<strong>输出: </strong>[1,2]</pre><pre><strong>示例 2:</strong><strong>输入: </strong>nums = [1], k = 1<strong>输出: </strong>[1]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li>  <li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li> </ul><p></p><p>&nbsp;</p><p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code><em>&nbsp;</em>是数组大小。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：优先队列"><a href="#参考代码：优先队列" class="headerlink" title="参考代码：优先队列"></a>参考代码：优先队列</h3><blockquote><p>时间复杂度：$O(nlogk)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 键存取数组中的元素，值存取元素在数组中出现的次数</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 根据数组中元素在数组中出现的次数创建一个小根堆</span>        <span class="token comment">// int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span>        <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> minHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>                <span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> o1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> o2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> num <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> count <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 堆中元素小于 k 个，可以直接插入</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                minHeap<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>num<span class="token punctuation">,</span> count<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 如果堆顶元素出现次数更小，就弹出堆顶，并将当前值插入堆中。</span>                minHeap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                minHeap<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>num<span class="token punctuation">,</span> count<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> minHeap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><h3 id="参考代码：快速选择"><a href="#参考代码：快速选择" class="headerlink" title="参考代码：快速选择"></a>参考代码：快速选择</h3><blockquote><ul><li>时间复杂度：$O(n^2)$<ul><li>但由于我们在每次递归的开始会先随机选取中枢元素，故出现最坏情况的概率很低。平均情况下，时间复杂度为 <code>O(n)</code>。</li></ul></li><li>空间复杂度：$O(n)$</li></ul></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 键存取数组中的元素，值存取元素在数组中出现的次数</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span>        <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">quickSelect</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span>                             <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res<span class="token punctuation">,</span> <span class="token keyword">int</span> resIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 生成一个 [start, end] 的随机整数</span>        <span class="token keyword">int</span> picked <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> start<span class="token punctuation">;</span>        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> picked<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> start<span class="token punctuation">;</span>        <span class="token comment">// list.get([start + 1, index]) &gt; pivot</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> index<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> index<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// index 左侧元素都是大于 pivot 的，这等价于大于等于 pivot 的数多于 k 个</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">quickSelect</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> start<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> resIndex<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// 否则，大于等于 piovt 的数小于等于 k 个，可以直接添加到结果集中</span>            <span class="token comment">// 这里 index 必须取等号，否则集合中仅一个元素时会死循环</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>resIndex<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                resIndex<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 已添加到结果集的数少于 k 个</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">quickSelect</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span>                        res<span class="token punctuation">,</span> resIndex<span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先队列 </tag>
            
            <tag> 快速选择 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 338 题：比特位计数（简单）</title>
      <link href="/leetcode/338/"/>
      <url>/leetcode/338/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-338-题：比特位计数"><a href="#「力扣」第-338-题：比特位计数" class="headerlink" title="「力扣」第 338 题：比特位计数"></a>「力扣」第 338 题：比特位计数</h2><ul><li><a href="https://leetcode.cn/problems/counting-bits/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数 <code>n</code> ，对于&nbsp;<code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>n = 2<strong>输出：</strong>[0,1,1]<strong>解释：</strong>0 --&gt; 01 --&gt; 12 --&gt; 10</pre><pre><strong>示例 2：</strong><strong>输入：</strong>n = 5<strong>输出：</strong>[0,1,1,2,1,2]<strong>解释：</strong>0 --&gt; 01 --&gt; 12 --&gt; 103 --&gt; 114 --&gt; 1005 --&gt; 101</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>0 &lt;= n &lt;= 10<sup>5</sup></code></li></ul><p></p><p>&nbsp;</p><p><strong>进阶：</strong></p><ul>    <li>很容易就能实现时间复杂度为 <code>O(n log n)</code> 的解决方案，你可以在线性时间复杂度 <code>O(n)</code> 内用一趟扫描解决此问题吗？</li>    <li>你能不使用任何内置函数解决此问题吗？（如，C++ 中的&nbsp;<code>__builtin_popcount</code> ）</li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：位运算"><a href="#参考代码：位运算" class="headerlink" title="参考代码：位运算"></a>参考代码：位运算</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><p><strong>解法一</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">countBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// i &amp; (i - 1) 可以去掉 i 的二进制表示中最右端的 1 (变成0)</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i <span class="token operator">&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p><strong>解法二</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">countBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// if ((i &amp; 1) == 1) {</span>            <span class="token comment">//     // 奇数与前一个偶数的二进制表示：最右边 0 --&gt; 1</span>            <span class="token comment">//     res[i] = res[i - 1] + 1;</span>            <span class="token comment">// } else {</span>            <span class="token comment">//     // 偶数与其除以二的数二进制表示：最右边添加了一个 0</span>            <span class="token comment">//     res[i] = res[i &gt;&gt; 1];</span>            <span class="token comment">// }</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 337 题：打家劫舍 III（中等）</title>
      <link href="/leetcode/337/"/>
      <url>/leetcode/337/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-337-题：打家劫舍-III"><a href="#「力扣」第-337-题：打家劫舍-III" class="headerlink" title="「力扣」第 337 题：打家劫舍 III"></a>「力扣」第 337 题：打家劫舍 III</h2><ul><li><a href="https://leetcode.cn/problems/house-robber-iii/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/198/">「力扣」第 198 题：打家劫舍</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <meta charset="UTF-8">&nbsp;<code>root</code>&nbsp;。</p><p>除了 <meta charset="UTF-8">&nbsp;<code>root</code>&nbsp;之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p><p>给定二叉树的&nbsp;<code>root</code>&nbsp;。返回&nbsp;<strong>在不触动警报的情况下</strong>&nbsp;，小偷能够盗取的最高金额&nbsp;。</p><p>&nbsp;</p><pre><strong>示例 1:</strong><img alt="" src="../../images/leetcode/337/rob1-tree.jpg"><strong>输入: </strong>root = [3,2,3,null,3,null,1]<strong>输出:</strong> 7 <strong>解释:</strong>&nbsp;小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7</pre><pre><strong>示例 2:</strong><img alt="" src="../../images/leetcode/337/rob2-tree.jpg"><strong>输入: </strong>root = [3,4,5,1,3,null,1]<strong>输出:</strong> 9<strong>解释:</strong>&nbsp;小偷一晚能够盗取的最高金额 4 + 5 = 9</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li>树的节点数在&nbsp;<code>[1, 10<sup>4</sup>]</code> 范围内</li>  <li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：动态规划"><a href="#参考代码：动态规划" class="headerlink" title="参考代码：动态规划"></a>参考代码：动态规划</h3><p><strong>简化一下这个问题：</strong>一棵二叉树，树上的每个点都有对应的权值，每个点有两种状态（选中和不选中），问在不能同时选中有父子关系的点的情况下，能选中的点的最大权值和是多少。</p><p>我们可以用 <code>f(o)</code> 表示选择 <code>o</code> 节点的情况下，<code>o</code> 节点的子树上被选择的节点的最大权值和；<code>g(o)</code> 表示不选择 <code>o</code> 节点的情况下，<code>o</code> 节点的子树上被选择的节点的最大权值和；<code>l</code> 和 <code>r</code> 代表 <code>o</code> 的左右孩子。</p><p><strong>动态规划转移方程：</strong></p><ul><li><code>f(o) = o.val + g(l) + g(r)</code></li><li><code>g(o) = max(f(l), g(l)) + max(f(r), g(r))</code></li></ul><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rootStatus <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>rootStatus<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rootStatus<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * @return 长度为 2 的 int 数组     * 第一个元素表示选择 root 结点能盗取的最高金额     * 第二个元素表示不选择 root 结点能盗取的最高金额     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> leftStatus <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rightStatus <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>                <span class="token comment">// 选择了 root 结点，那么左右孩子结点均不能选择</span>                root<span class="token punctuation">.</span>val <span class="token operator">+</span> leftStatus<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> rightStatus<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token comment">// 没选择 root 结点，那么左右孩子选择与否由能盗取的最高金额决定</span>                <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftStatus<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> leftStatus<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                        <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>rightStatus<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rightStatus<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 322 题：零钱兑换（中等）</title>
      <link href="/leetcode/322/"/>
      <url>/leetcode/322/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-322-题：零钱兑换"><a href="#「力扣」第-322-题：零钱兑换" class="headerlink" title="「力扣」第 322 题：零钱兑换"></a>「力扣」第 322 题：零钱兑换</h2><ul><li><a href="https://leetcode.cn/problems/coin-change/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回&nbsp;<code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p>&nbsp;</p><pre><strong>示例&nbsp;1：</strong><strong>输入：</strong>coins = <span>[1, 2, 5]</span>, amount = <span>11</span><strong>输出：</strong><span>3</span> <strong>解释：</strong>11 = 5 + 5 + 1</pre><pre><strong>示例 2：</strong><strong>输入：</strong>coins = <span>[2]</span>, amount = <span>3</span><strong>输出：</strong>-1</pre><pre><strong>示例 3：</strong><strong>输入：</strong>coins = [1], amount = 0<strong>输出：</strong>0</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= coins.length &lt;= 12</code></li>  <li><code>1 &lt;= coins[i] &lt;= 2<sup>31</sup> - 1</code></li>  <li><code>0 &lt;= amount &lt;= 10<sup>4</sup></code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：动态规划"><a href="#参考代码：动态规划" class="headerlink" title="参考代码：动态规划"></a>参考代码：动态规划</h3><p><code>dp[i]</code> 为组成金额 <code>i</code> 所需最少的硬币数量</p><p><strong>动态规划转移方程：</strong><br>$$<br>dp[i]=\min\limits_{j=0 \dots m-1}{dp[i -coins[j]]} + 1<br>$$</p><blockquote><p>时间复杂度：$O(n \times m)$</p><p>空间复杂度：$O(m)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 0 &lt;= amount &lt;= 10^4</span>        <span class="token comment">// dp[i] 为组成金额 i 所需最少的硬币数量</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 不能使用 Integeter.MAX_VALUE 填充，+1 会导致返回 Integer.MIN_VALUE</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> amount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> amount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>coin <span class="token operator">&lt;=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 312 题：戳气球（困难）</title>
      <link href="/leetcode/312/"/>
      <url>/leetcode/312/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-312-题：戳气球"><a href="#「力扣」第-312-题：戳气球" class="headerlink" title="「力扣」第 312 题：戳气球"></a>「力扣」第 312 题：戳气球</h2><ul><li><a href="https://leetcode.cn/problems/burst-balloons/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组&nbsp;<code>nums</code>&nbsp;中。</p><p>现在要求你戳破所有的气球。戳破第 <code>i</code> 个气球，你可以获得&nbsp;<code>nums[i - 1] * nums[i] * nums[i + 1]</code> 枚硬币。&nbsp;这里的 <code>i - 1</code> 和 <code>i + 1</code> 代表和&nbsp;<code>i</code>&nbsp;相邻的两个气球的序号。如果 <code>i - 1</code>或 <code>i + 1</code> 超出了数组的边界，那么就当它是一个数字为 <code>1</code> 的气球。</p><p>求所能获得硬币的最大数量。</p><p>&nbsp;</p> <pre><strong>示例 1：</strong><strong>输入：</strong>nums = [3,1,5,8]<strong>输出：</strong>167<strong>解释：</strong>nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167</pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums = [1,5]<strong>输出：</strong>10</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>n == nums.length</code></li>  <li><code>1 &lt;= n &lt;= 300</code></li>  <li><code>0 &lt;= nums[i] &lt;= 100</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：动态规划"><a href="#参考代码：动态规划" class="headerlink" title="参考代码：动态规划"></a>参考代码：动态规划</h3><p>为了方便处理，我们对 <code>nums</code> 数组稍作处理，将其两边各加上题目中假设存在的 <code>nums[−1]</code> 和 <code>nums[n]</code> ，并保存在 <code>val</code> 数组中。</p><p>令 <code>dp[i][j]</code> 表示填满开区间 <code>(i,j)</code> 能得到的最多硬币数。即，戳破气球 <code>i</code> 和气球 <code>j</code> 之间（不包括 <code>i</code> 和 <code>j</code>）的所有气球，可以获得的最多硬币数。</p><p><strong>动态规划转移方程：</strong><br>$$<br>dp[i][j]= \begin{cases} \displaystyle<br>\max_\limits{k = i + 1}^{j - 1}val[i] \times val[k] \times val[j] + dp[i][k] + dp[k][j] ,&amp;i &lt; j - 1 \\<br>0, &amp; i \geq j - 1<br>\end{cases}<br>$$</p><blockquote><p>时间复杂度：$O(n^3)$</p><p>空间复杂度：$O(n^2)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> val <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        val<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            val<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 戳破气球 i 和气球 j 之间（不包括 i 和 j）的所有气球，可以获得的最多硬币数</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// i + 2 &lt;= j &lt;= n + 1,</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> sum <span class="token operator">=</span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> val<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">*</span> val<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 309 题：最佳买卖股票时机含冷冻期（中等）</title>
      <link href="/leetcode/309/"/>
      <url>/leetcode/309/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-309-题：最佳买卖股票时机含冷冻期"><a href="#「力扣」第-309-题：最佳买卖股票时机含冷冻期" class="headerlink" title="「力扣」第 309 题：最佳买卖股票时机含冷冻期"></a>「力扣」第 309 题：最佳买卖股票时机含冷冻期</h2><ul><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/121/">「力扣」第 121 题：买卖股票的最佳时机</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 <meta charset="UTF-8"><code>prices</code>，其中第&nbsp;<em>&nbsp;</em><code>prices[i]</code>&nbsp;表示第&nbsp;<code><em>i</em></code>&nbsp;天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul>  <li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li> </ul><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>&nbsp;</p><pre><strong>示例 1:</strong><strong>输入:</strong> prices = [1,2,3,0,2]<strong>输出: </strong>3 <strong>解释:</strong> 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</pre><pre><strong>示例 2:</strong><strong>输入:</strong> prices = [1]<strong>输出:</strong> 0</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= prices.length &lt;= 5000</code></li>  <li><code>0 &lt;= prices[i] &lt;= 1000</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：动态规划"><a href="#参考代码：动态规划" class="headerlink" title="参考代码：动态规划"></a>参考代码：动态规划</h3><p>我们用 <code>dp[i]</code> 表示 <strong>第 i 天结束之后</strong> 的「累计最大收益」。根据题目描述，由于我们最多只能同时买入（持有）一支股票，并且卖出股票后有冷冻期的限制，因此我们会有三种不同的状态：</p><ul><li><p>我们目前持有一支股票，对应的「累计最大收益」记为 <code>dp[i][0]</code>；</p></li><li><p>我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为 <code>dp[i][1]</code>；</p></li><li><p>我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 <code>dp[i][2]</code>。</p></li></ul><p><strong>动态规划转移方程：</strong></p><ul><li><code>dp[i][0] = max(dp[i-1][0], dp[i-1][2]-prices[i])</code></li><li><code>dp[i][1] = dp[i-1][0] - prices[i]</code></li><li><code>dp[i][2] = max(dp[i-1][1], dp[i-1][2])</code></li></ul><p>由于第 <code>i</code> 个状态只和第 <code>i-1</code> 个状态相关，根据「滚动数组」思想，我们可以只用三个变量来维护 <code>i−1</code> 时刻的状态。</p><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1 &lt;= prices.length &lt;= 5000</span>        <span class="token comment">// 持有一支股票</span>        <span class="token keyword">int</span> dp0 <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 不持有任何股票，并且处于冷冻期</span>        <span class="token keyword">int</span> dp1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 不持有任何股票，不处于冷冻期</span>        <span class="token keyword">int</span> dp2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 前一天持有的股票继续持有，或者前一天不持有任何股票不处于冷冻期选择现在买入</span>            <span class="token keyword">int</span> newDp0 <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp0<span class="token punctuation">,</span> dp2 <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 前一天持有一只股票，选择现在卖出</span>            <span class="token keyword">int</span> newDp1 <span class="token operator">=</span> dp0 <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 前一天不持有任何股票，现在也不买入</span>            dp2 <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp1<span class="token punctuation">,</span> dp2<span class="token punctuation">)</span><span class="token punctuation">;</span>            dp1 <span class="token operator">=</span> newDp1<span class="token punctuation">;</span>            dp0 <span class="token operator">=</span> newDp0<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 显然 dp0 &lt;= max(dp1,dp2)</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp1<span class="token punctuation">,</span> dp2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 301 题：删除无效的括号（困难）</title>
      <link href="/leetcode/301/"/>
      <url>/leetcode/301/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-301-题：删除无效的括号"><a href="#「力扣」第-301-题：删除无效的括号" class="headerlink" title="「力扣」第 301 题：删除无效的括号"></a>「力扣」第 301 题：删除无效的括号</h2><ul><li><a href="https://leetcode.cn/problems/remove-invalid-parentheses/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/20/">「力扣」第 20 题：有效的括号</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个由若干括号和字母组成的字符串 <code>s</code> ，删除最小数量的无效括号，使得输入的字符串有效。</p><p>返回所有可能的结果。答案可以按 <strong>任意顺序</strong> 返回。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>s = "()())()"<strong>输出：</strong>["(())()","()()()"]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>s = "(a)())()"<strong>输出：</strong>["(a())()","(a)()()"]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>s = ")("<strong>输出：</strong>[""]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= s.length &lt;= 25</code></li>  <li><code>s</code> 由小写英文字母以及括号 <code>'('</code> 和 <code>')'</code> 组成</li>  <li><code>s</code> 中至多含 <code>20</code> 个括号</li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：回溯"><a href="#参考代码：回溯" class="headerlink" title="参考代码：回溯"></a>参考代码：回溯</h3><blockquote><p>时间复杂度：$n \times 2^n$</p><p>空间复杂度：$n^2$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">removeInvalidParentheses</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 多余待删除的左右括号数目</span>        <span class="token keyword">int</span> leftRemove <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rightRemove <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                leftRemove<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>leftRemove <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    rightRemove<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    leftRemove<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> leftRemove<span class="token punctuation">,</span> rightRemove<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token class-name">StringBuilder</span> sb<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span>                           <span class="token keyword">int</span> leftRemove<span class="token punctuation">,</span> <span class="token keyword">int</span> rightRemove<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftRemove <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> rightRemove <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> s <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sb<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> begin <span class="token operator">&amp;&amp;</span> sb<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> sb<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 如果剩余的字符无法满足去掉的数量要求，可以直接返回了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>leftRemove <span class="token operator">+</span> rightRemove <span class="token operator">&gt;</span> sb<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 尝试去掉一个左括号</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>leftRemove <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> sb<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">backtrack</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">deleteCharAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> leftRemove <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> rightRemove<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 回溯。状态重置</span>                sb<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token char">'('</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 尝试去掉一个右括号</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rightRemove <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> sb<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">backtrack</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">deleteCharAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> leftRemove<span class="token punctuation">,</span> rightRemove <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 回溯。状态重置</span>                sb<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token char">')'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 字符串 s 是否是一个有效的括号     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> leftRemove <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                leftRemove<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>leftRemove <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    leftRemove<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> leftRemove <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 300 题：最长递增子序列（中等）</title>
      <link href="/leetcode/300/"/>
      <url>/leetcode/300/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-300-题：最长递增子序列"><a href="#「力扣」第-300-题：最长递增子序列" class="headerlink" title="「力扣」第 300 题：最长递增子序列"></a>「力扣」第 300 题：最长递增子序列</h2><ul><li><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列&nbsp;</strong>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [10,9,2,5,3,7,101,18]<strong>输出：</strong>4<strong>解释：</strong>最长递增子序列是 [2,3,7,101]，因此长度为 4 。</pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums = [0,1,0,3,2,3]<strong>输出：</strong>4</pre><pre><strong>示例 3：</strong><strong>输入：</strong>nums = [7,7,7,7,7,7,7]<strong>输出：</strong>1</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= nums.length &lt;= 2500</code></li>  <li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li> </ul><p></p><p>&nbsp;</p><p><b>进阶：</b></p><ul>  <li>你能将算法的时间复杂度降低到&nbsp;<code>O(n log(n))</code> 吗?</li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：贪心-二分查找优化插入过程"><a href="#参考代码：贪心-二分查找优化插入过程" class="headerlink" title="参考代码：贪心 + 二分查找优化插入过程"></a>参考代码：贪心 + 二分查找优化插入过程</h3><p><strong>数组 <code>greedy</code></strong> ：长度为 <code>i+1</code> 的递增子序列的末尾最小为 <code>greedy[i]</code></p><ul><li><code>nums[i]</code> 严格大于有序数组 <code>greedy</code> 的最后一个元素：将 <code>nums[i]</code> 添加到数组 <code>greedy</code> 末尾</li><li>否则，用 <code>nums[i]</code> 替换数组 <code>greedy</code> 中第一个大于等于 <code>nums[i]</code> 的元素</li></ul><blockquote><p>时间复杂度：$O(nlogn)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 长度为 i + 1 的递增子序列的末尾最小为 greedy[i]</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> greedy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        greedy<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 比 greedy 数组实际有效的末尾元素还大，直接添加在末尾元素的后面</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> greedy<span class="token punctuation">[</span>res<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token operator">++</span><span class="token punctuation">;</span>                greedy<span class="token punctuation">[</span>res<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">// 二分查找法。在数组 greedy 的有序区间 [0, res] 查找应该替换的位置</span>                <span class="token comment">// 替换应该是第一个大于等于 nums[i] 的数</span>                <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> right <span class="token operator">=</span> res<span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token comment">// 比 nums[i] 小的位置显然不是应该替换的位置</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>greedy<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        right <span class="token operator">=</span> mid<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                greedy<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 297 题：二叉树的序列化与反序列化（困难）</title>
      <link href="/leetcode/297/"/>
      <url>/leetcode/297/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-297-题：二叉树的序列化与反序列化"><a href="#「力扣」第-297-题：二叉树的序列化与反序列化" class="headerlink" title="「力扣」第 297 题：二叉树的序列化与反序列化"></a>「力扣」第 297 题：二叉树的序列化与反序列化</h2><ul><li><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示: </strong>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅&nbsp;<a href="https://leetcode.cn/faq/#binary-tree">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/297/serdeser.jpg" style="width: 442px; height: 324px;"> <strong>输入：</strong>root = [1,2,3,null,null,4,5]<strong>输出：</strong>[1,2,3,null,null,4,5]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>root = []<strong>输出：</strong>[]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>root = [1]<strong>输出：</strong>[1]</pre><pre><strong>示例 4：</strong><strong>输入：</strong>root = [1,2]<strong>输出：</strong>[1,2]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li>树中结点数在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>  <li><code>-1000 &lt;= Node.val &lt;= 1000</code></li> </ul><p></p><p>&nbsp;</p><p><strong>二叉树结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：深度优先搜索"><a href="#参考代码：深度优先搜索" class="headerlink" title="参考代码：深度优先搜索"></a>参考代码：深度优先搜索</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Codec</span> <span class="token punctuation">{</span>    <span class="token comment">// Encodes a tree to a single string.</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">serialize</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// Decodes your encoded data to tree.</span>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">deserialize</span><span class="token punctuation">(</span><span class="token class-name">String</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dataArray <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">deserialize</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>dataArray<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token class-name">StringBuilder</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">StringBuilder</span> sb<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"None,"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">serialize</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">serialize</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sb<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token class-name">TreeNode</span> <span class="token function">deserialize</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> dataList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"None"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>dataList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dataList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>dataList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>dataList<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>dataList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 287 题：寻找重复数（中等）</title>
      <link href="/leetcode/287/"/>
      <url>/leetcode/287/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-287-题：寻找重复数"><a href="#「力扣」第-287-题：寻找重复数" class="headerlink" title="「力扣」第 287 题：寻找重复数"></a>「力扣」第 287 题：寻找重复数</h2><ul><li><a href="https://leetcode.cn/problems/find-the-duplicate-number/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/136/">「力扣」第 136 题：只出现一次的数字</a></li><li><a href="https://iiifox.github.io/leetcode/142/">「力扣」第 142 题：环形链表 II</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含&nbsp;<code>n + 1</code> 个整数的数组&nbsp;<code>nums</code> ，其数字都在&nbsp;<code>[1, n]</code>&nbsp;范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p><p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回&nbsp;<strong>这个重复的数</strong> 。</p><p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [1,3,4,2,2]<strong>输出：</strong>2</pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums = [3,1,3,4,2]<strong>输出：</strong>3</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>  <li><code>nums.length == n + 1</code></li>  <li><code>1 &lt;= nums[i] &lt;= n</code></li>  <li><code>nums</code> 中 <strong>只有一个整数</strong> 出现 <strong>两次或多次</strong> ，其余整数均只出现 <strong>一次</strong></li> </ul><p></p><p>&nbsp;</p><p><b>进阶：</b></p><ul>  <li>如何证明 <code>nums</code> 中至少存在一个重复的数字?</li>  <li>你可以设计一个线性级时间复杂度 <code>O(n)</code> 的解决方案吗？</li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：Floyd-判圈算法"><a href="#参考代码：Floyd-判圈算法" class="headerlink" title="参考代码：Floyd 判圈算法"></a>参考代码：Floyd 判圈算法</h3><p><code>n+1</code> 个位置放最多 <code>n</code> 个不同的数字，由抽屉原理知，至少存在一个数 <code>target</code> 会在数组中出现不少于两次。</p><p>我们对 <code>nums</code> 数组建图，每个位置 <code>i</code> 连一条到位置 <code>nums[i]</code> 的有向边。由于存在的重复的数字 <code>target</code>，因此 <code>target</code> 这个位置至少有两条指向它的边，因此整张图一定存在环，且我们要找到的 <code>target</code> 就是这个环的入口。注意到 <code>nums</code> 中没有 <code>0</code> ，即不存在指向位置 <code>0</code> 的边，因此从 <code>0</code> 开始走，一定可以进入该环。</p><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">;</span>            fast <span class="token operator">=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span><span class="token punctuation">;</span>        slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">;</span>            fast <span class="token operator">=</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> Floyd 判圈算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 283 题：移动零（简单）</title>
      <link href="/leetcode/283/"/>
      <url>/leetcode/283/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-283-题：移动零"><a href="#「力扣」第-283-题：移动零" class="headerlink" title="「力扣」第 283 题：移动零"></a>「力扣」第 283 题：移动零</h2><ul><li><a href="https://leetcode.cn/problems/move-zeroes/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong>&nbsp;，必须在不复制数组的情况下原地对数组进行操作。</p><p>&nbsp;</p><pre><strong>示例 1:</strong><strong>输入:</strong> nums = [0,1,0,3,12]<strong>输出:</strong> [1,3,12,0,0]</pre><pre><strong>示例 2:</strong><strong>输入:</strong> nums = [0]<strong>输出:</strong> [0]</pre><p>&nbsp;</p><p><strong>提示</strong>:<meta charset="UTF-8"></p><ul>    <li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>    <li><code>-2<sup>31</sup>&nbsp;&lt;= nums[i] &lt;= 2<sup>31</sup>&nbsp;- 1</code></li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：左右指针"><a href="#参考代码：左右指针" class="headerlink" title="参考代码：左右指针"></a>参考代码：左右指针</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// nums[0, left] != 0;</span>        <span class="token comment">// nums(left, right] == 0</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> right <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> right<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token comment">// 这里并没有抽取出一个 swap 函数，减少函数调用开销</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 279 题：完全平方数（中等）</title>
      <link href="/leetcode/279/"/>
      <url>/leetcode/279/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-279-题：完全平方数"><a href="#「力扣」第-279-题：完全平方数" class="headerlink" title="「力扣」第 279 题：完全平方数"></a>「力扣」第 279 题：完全平方数</h2><ul><li><a href="https://leetcode.cn/problems/perfect-squares/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的最少数量 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><p>&nbsp;</p><pre><strong>示例&nbsp;1：</strong><strong>输入：</strong>n = <span>12</span><strong>输出：</strong>3 <strong>解释：</strong><span>12 = 4 + 4 + 4</span></pre><pre><strong>示例 2：</strong><strong>输入：</strong>n = <span>13</span><strong>输出：</strong>2<strong>解释：</strong><span>13 = 4 + 9</span></pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：四平方和定理"><a href="#参考代码：四平方和定理" class="headerlink" title="参考代码：四平方和定理"></a>参考代码：四平方和定理</h3><ul><li>任意一个正整数都可以被表示为至多四个正整数的平方和。</li></ul><ul><li>当且仅当 $n \ne 4^k \times (8m+7)$ 时，n 可以被表示为至多三个正整数的平方和。</li></ul><blockquote><p>时间复杂度：$O(\sqrt{n})$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPerfectSquare</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkAnswer4</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">*</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPerfectSquare</span><span class="token punctuation">(</span>n <span class="token operator">-</span> i <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 判断 x 是否为完全平方数     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isPerfectSquare</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> y <span class="token operator">*</span> y <span class="token operator">==</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 判断一个数能否表示成 4^k*(8m+7)，即答案是否为 4 。     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">checkAnswer4</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            x <span class="token operator">&gt;&gt;=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 四平方和定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 253 题：会议室 II（中等）</title>
      <link href="/leetcode/253/"/>
      <url>/leetcode/253/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-253-题：会议室-II"><a href="#「力扣」第-253-题：会议室-II" class="headerlink" title="「力扣」第 253 题：会议室 II"></a>「力扣」第 253 题：会议室 II</h2><ul><li><a href="https://leetcode.cn/problems/meeting-rooms-ii/">链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 未完成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 240 题：搜索二维矩阵 II（中等）</title>
      <link href="/leetcode/240/"/>
      <url>/leetcode/240/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-240-题：搜索二维矩阵-II"><a href="#「力扣」第-240-题：搜索二维矩阵-II" class="headerlink" title="「力扣」第 240 题：搜索二维矩阵 II"></a>「力扣」第 240 题：搜索二维矩阵 II</h2><ul><li><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个高效的算法来搜索&nbsp;<code><em>m</em>&nbsp;x&nbsp;<em>n</em></code>&nbsp;矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p><ul>  <li>每行的元素从左到右升序排列。</li>  <li>每列的元素从上到下升序排列。</li> </ul><p>&nbsp;</p><pre><b>示例 1：</b><img alt="" src="../../images/leetcode/240/searchgrid2.jpg"> <b>输入：</b>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5<b>输出：</b>true</pre><pre><b>示例 2：</b><img alt="" src="../../images/leetcode/240/searchgrid.jpg"> <b>输入：</b>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20<b>输出：</b>false</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>m == matrix.length</code></li>  <li><code>n == matrix[i].length</code></li>  <li><code>1 &lt;= n, m &lt;= 300</code></li>  <li><code>-10<sup>9</sup>&nbsp;&lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>  <li>每行的所有元素从左到右升序排列</li>  <li>每列的所有元素从上到下升序排列</li>  <li><code>-10<sup>9</sup>&nbsp;&lt;= target &lt;= 10<sup>9</sup></code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：Z-字形查找"><a href="#参考代码：Z-字形查找" class="headerlink" title="参考代码：Z 字形查找"></a>参考代码：Z 字形查找</h3><p>从矩阵 <code>matrix</code> 的右上角 <code>(0,n−1)</code> 开始搜索。在每一步的搜索过程中，如果我们位于位置 <code>(x,y)</code> ，那么行的搜索范围为 <code>[x, m−1]</code>，列的搜索范围为 <code>[0, y]</code> 。</p><p>因为每行的元素从左到右升序排列，每列的元素从上到下升序排列。因此 <code>(x,y)</code> 是搜索范围内 <strong>所在行的最大值，所在列的最小值</strong> 。</p><ul><li><p>如果 <code>matrix[x][y] = target</code>，说明搜索完成；</p></li><li><p>如果 <code>matrix[x][y] &gt; target</code>，将 <code>y</code> 减少 <code>1</code> ；</p></li><li><p>如果 <code>matrix[x][y] &lt; target</code>，将 <code>x</code> 增加 <code>1</code> 。</p></li></ul><p>在搜索的过程中，如果我们超出了矩阵的边界，那么说明矩阵中不存在 <code>target</code> 。</p><blockquote><p>时间复杂度：$O(m+n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">searchMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 特判。用于处理 null 与 []</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> y <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> y <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                x<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                y<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Z 字形查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 239 题：滑动窗口最大值（困难）</title>
      <link href="/leetcode/239/"/>
      <url>/leetcode/239/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-239-题：滑动窗口最大值"><a href="#「力扣」第-239-题：滑动窗口最大值" class="headerlink" title="「力扣」第 239 题：滑动窗口最大值"></a>「力扣」第 239 题：滑动窗口最大值</h2><ul><li><a href="https://leetcode.cn/problems/sliding-window-maximum/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code>，有一个大小为&nbsp;<code>k</code><em>&nbsp;</em>的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code>&nbsp;个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值 。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><b>输入：</b>nums = [1,3,-1,-3,5,3,6,7], k = 3<b>输出：</b>[3,3,5,5,6,7]<b>解释：</b>滑动窗口的位置                 最大值---------------               -----[1  3  -1] -3  5  3  6  7       <strong>3</strong> 1 [3  -1  -3] 5  3  6  7       <strong>3</strong> 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong> 1  3  -1 [-3  5  3] 6  7       <strong>5</strong> 1  3  -1  -3 [5  3  6] 7       <strong>6</strong> 1  3  -1  -3  5 [3  6  7]      <strong>7</strong></pre><pre><strong>示例 2：</strong><b>输入：</b>nums = [1], k = 1<b>输出：</b>[1]</pre><p>&nbsp;</p><p><b>提示：</b></p><ul>  <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>-10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>4</sup></code></li>  <li><code>1 &lt;= k &lt;= nums.length</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：单调队列"><a href="#参考代码：单调队列" class="headerlink" title="参考代码：单调队列"></a>参考代码：单调队列</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(k)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 存储滑动窗口内的下标(从小到大)，并且它们在数组 nums 中对应的值是严格单调递减的</span>        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> deque <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 当前元素入单调队列，并将所有小于等于当前元素的元素移除队列</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>deque<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>deque<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 窗口大小已经达到 k</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 将单调队列中不在窗口区间 [i-k+1, i] 的元素全部移除</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>deque<span class="token punctuation">.</span><span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> i <span class="token operator">-</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    deque<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 队首元素即为滑动窗口中的最大值</span>                res<span class="token punctuation">[</span>i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>deque<span class="token punctuation">.</span><span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 238 题：除自身以外数组的乘积（中等）</title>
      <link href="/leetcode/238/"/>
      <url>/leetcode/238/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-238-题：除自身以外数组的乘积"><a href="#「力扣」第-238-题：除自身以外数组的乘积" class="headerlink" title="「力扣」第 238 题：除自身以外数组的乘积"></a>「力扣」第 238 题：除自身以外数组的乘积</h2><ul><li><a href="https://leetcode.cn/problems/product-of-array-except-self/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/152/">「力扣」第 152 题：乘积最大子数组</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组&nbsp;<code>nums</code>，返回数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>&nbsp;等于&nbsp;<code>nums</code>&nbsp;中除&nbsp;<code>nums[i]</code>&nbsp;之外其余各元素的乘积&nbsp;。</p><p>题目数据 <strong>保证</strong> 数组&nbsp;<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在&nbsp; <strong>32 位</strong> 整数范围内。</p><p>请<strong>不要使用除法，</strong>且在&nbsp;<code>O(<em>n</em>)</code> 时间复杂度内完成此题。</p><p>&nbsp;</p><pre><strong>示例 1:</strong><strong>输入:</strong> nums = <span>[1,2,3,4]</span><strong>输出:</strong> <span>[24,12,8,6]</span></pre><pre><strong>示例 2:</strong><strong>输入:</strong> nums = [-1,1,0,-3,3]<strong>输出:</strong> [0,0,9,0,0]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>-30 &lt;= nums[i] &lt;= 30</code></li>  <li><strong>保证</strong> 数组&nbsp;<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在&nbsp; <strong>32 位</strong> 整数范围内</li> </ul><p></p><p>&nbsp;</p><p><strong>进阶：</strong>你可以在 <code>O(1)</code>&nbsp;的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组<strong>不被视为</strong>额外空间。）</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：前缀和"><a href="#参考代码：前缀和" class="headerlink" title="参考代码：前缀和"></a>参考代码：前缀和</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$   <code>输出数组不计入额外空间</code></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">productExceptSelf</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 为了节省空间，res[i] 先存储索引 i 左侧所有元素的乘积</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// rightProduct 为索引 i 右侧所有元素的乘积</span>        <span class="token keyword">int</span> rightProduct <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*=</span> rightProduct<span class="token punctuation">;</span>            rightProduct <span class="token operator">*=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 236 题：二叉树的最近公共祖先（中等）</title>
      <link href="/leetcode/236/"/>
      <url>/leetcode/236/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-236-题：二叉树的最近公共祖先"><a href="#「力扣」第-236-题：二叉树的最近公共祖先" class="headerlink" title="「力扣」第 236 题：二叉树的最近公共祖先"></a>「力扣」第 236 题：二叉树的最近公共祖先</h2><ul><li><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" target="_blank">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/236/binarytree.png" style="width: 200px; height: 190px;"> <strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<strong>输出：</strong>3<strong>解释：</strong>节点 <span>5 </span>和节点 <span>1 </span>的最近公共祖先是节点 <span>3 。</span></pre><pre><strong>示例 2：</strong><img alt="" src="../../images/leetcode/236/binarytree.png" style="width: 200px; height: 190px;"> <strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<strong>输出：</strong>5<strong>解释：</strong>节点 <span>5 </span>和节点 <span>4 </span>的最近公共祖先是节点 <span>5 。</span>因为根据定义最近公共祖先节点可以为节点本身。</pre><pre><strong>示例 3：</strong><strong>输入：</strong>root = [1,2], p = 1, q = 2<strong>输出：</strong>1</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li>树中节点数目在范围 <code>[2, 10<sup>5</sup>]</code> 内。</li>  <li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>  <li>所有 <code>Node.val</code> <code>互不相同</code> 。</li>  <li><code>p != q</code></li>  <li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li> </ul><p></p><p>&nbsp;</p><p><strong>二叉树结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：深度优先搜索"><a href="#参考代码：深度优先搜索" class="headerlink" title="参考代码：深度优先搜索"></a>参考代码：深度优先搜索</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token class-name">TreeNode</span> leftChild <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TreeNode</span> rightChild <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftChild <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// p、q 都位于右子树当中</span>            <span class="token keyword">return</span> rightChild<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rightChild <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// p、q 都位于左子树当中</span>            <span class="token keyword">return</span> leftChild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 都非空，说明一边一个，因此 root 是它们的最近公共祖先</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 234 题：回文链表（简单）</title>
      <link href="/leetcode/234/"/>
      <url>/leetcode/234/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-234-题：回文链表"><a href="#「力扣」第-234-题：回文链表" class="headerlink" title="「力扣」第 234 题：回文链表"></a>「力扣」第 234 题：回文链表</h2><ul><li><a href="https://leetcode.cn/problems/palindrome-linked-list/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/206/">「力扣」第 206 题：反转链表</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/234/pal1linked-list.jpg" style="width: 422px; height: 62px;"><strong>输入：</strong>head = [1,2,2,1]<strong>输出：</strong>true</pre><pre><strong>示例 2：</strong><img alt="" src="../../images/leetcode/234/pal2linked-list.jpg" style="width: 182px; height: 62px;"><strong>输入：</strong>head = [1,2]<strong>输出：</strong>false</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li>链表中节点数目在范围<code>[1, 10<sup>5</sup>]</code> 内</li>    <li><code>0 &lt;= Node.val &lt;= 9</code></li></ul><p></p><p>&nbsp;</p><p><strong>进阶：</strong>你能否用&nbsp;<code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p><p>&nbsp;</p><p><strong>链表定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：快慢指针"><a href="#参考代码：快慢指针" class="headerlink" title="参考代码：快慢指针"></a>参考代码：快慢指针</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 链表中节点数目在范围 [1, 10^5] 内</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment">// 结束时 slow 的下一个是链表右半部分（左半部分长度不小于右半部分长度）</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// slow 的下一个就是链表右半部分</span>        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment">// 左半部分与右半部分开始截断</span>        slow<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 右半部分链表开始反转</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">ListNode</span> next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 这里是为了还原链表而做的</span>        cur <span class="token operator">=</span> pre<span class="token punctuation">;</span>        <span class="token comment">// 此时 pre 是右半部分链表反转后的头结点</span>        <span class="token comment">// len左 &gt;= len右 ，因此判断条件只需要看右半部分就行</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">!=</span> pre<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 不破坏原链表结构，还原链表，注意：右链表的头结点是 cur</span>        pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">ListNode</span> next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 此时左链表尾结点 slow ，右链表头结点 pre</span>        slow<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 226 题：翻转二叉树（简单）</title>
      <link href="/leetcode/226/"/>
      <url>/leetcode/226/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-226-题：翻转二叉树"><a href="#「力扣」第-226-题：翻转二叉树" class="headerlink" title="「力扣」第 226 题：翻转二叉树"></a>「力扣」第 226 题：翻转二叉树</h2><ul><li><a href="https://leetcode.cn/problems/invert-binary-tree/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/226/invert1-tree.jpg" style="height: 165px; width: 500px;"><strong>输入：</strong>root = [4,2,7,1,3,6,9]<strong>输出：</strong>[4,7,2,9,6,3,1]</pre><pre><strong>示例 2：</strong><img alt="" src="../../images/leetcode/226/invert2-tree.jpg" style="width: 500px; height: 120px;"><strong>输入：</strong>root = [2,1,3]<strong>输出：</strong>[2,3,1]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>root = []<strong>输出：</strong>[]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li>树中节点数目范围在 <code>[0, 100]</code> 内</li>  <li><code>-100 &lt;= Node.val &lt;= 100</code></li> </ul><p></p><p>&nbsp;</p><p><strong>二叉树结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：深度优先搜索"><a href="#参考代码：深度优先搜索" class="headerlink" title="参考代码：深度优先搜索"></a>参考代码：深度优先搜索</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">TreeNode</span> leftChild <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TreeNode</span> rightChild <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> rightChild<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> leftChild<span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 221 题：最大正方形（中等）</title>
      <link href="/leetcode/221/"/>
      <url>/leetcode/221/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-221-题：最大正方形"><a href="#「力扣」第-221-题：最大正方形" class="headerlink" title="「力扣」第 221 题：最大正方形"></a>「力扣」第 221 题：最大正方形</h2><ul><li><a href="https://leetcode.cn/problems/maximal-square/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/85/">「力扣」第 85 题：最大矩形</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个由 <code>'0'</code> 和 <code>'1'</code> 组成的二维矩阵内，找到只包含 <code>'1'</code> 的最大正方形，并返回其面积。</p><p>&nbsp;</p><pre><strong>示例 1：</strong> <img alt="" src="../../images/leetcode/221/max1grid.jpg" style="width: 400px; height: 319px;"> <strong>输入：</strong>matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]<strong>输出：</strong>4</pre><pre><strong>示例 2：</strong><img alt="" src="../../images/leetcode/221/max2grid.jpg" style="width: 165px; height: 165px;"> <strong>输入：</strong>matrix = [["0","1"],["1","0"]]<strong>输出：</strong>1</pre><pre><strong>示例 3：</strong><strong>输入：</strong>matrix = [["0"]]<strong>输出：</strong>0</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>m == matrix.length</code></li>  <li><code>n == matrix[i].length</code></li>  <li><code>1 &lt;= m, n &lt;= 300</code></li>  <li><code>matrix[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：动态规划"><a href="#参考代码：动态规划" class="headerlink" title="参考代码：动态规划"></a>参考代码：动态规划</h3><p><code>dp[i][j]</code> 表示以 <code>(i,j)</code> 为右下角，且只包含 <code>1</code> 的正方形的边长最大值</p><p><strong>动态规划转移方程：</strong></p><ul><li><p>如果该位置的值是 <code>0</code>，则 <code>dp[i][j] = 0</code> ;</p></li><li><p>如果该位置的值是 <code>1</code>，则 <code>dp[i][j] = min(dp[i−1][j-1], dp[i−1][j], dp[i][j−1]) + 1</code></p></li></ul><blockquote><p>时间复杂度：$O(mn)$</p><p>空间复杂度：$O(mn)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maximalSquare</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxSide <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// m == matrix.length</span>        <span class="token comment">// n == matrix[i].length</span>        <span class="token comment">// 1 &lt;= m, n &lt;= 300</span>        <span class="token keyword">int</span> rows <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> cols <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// dp(i,j) 表示以 (i, j) 为右下角，且只包含 1 的正方形的边长最大值</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>rows<span class="token punctuation">]</span><span class="token punctuation">[</span>cols<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rows<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> cols<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                        <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                maxSide <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxSide<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxSide <span class="token operator">*</span> maxSide<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 215 题：数组中的第K个最大元素（中等）</title>
      <link href="/leetcode/215/"/>
      <url>/leetcode/215/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-215-题：数组中的第K个最大元素"><a href="#「力扣」第-215-题：数组中的第K个最大元素" class="headerlink" title="「力扣」第 215 题：数组中的第K个最大元素"></a>「力扣」第 215 题：数组中的第K个最大元素</h2><ul><li><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/347/">「力扣」第 347 题：前 K 个高频元素</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code><strong>k</strong></code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p>&nbsp;</p><pre><strong>示例 1:</strong><strong>输入:</strong> <span>[3,2,1,5,6,4],</span> k = 2<strong>输出:</strong> 5</pre><pre><strong>示例&nbsp;2:</strong><strong>输入:</strong> <span>[3,2,3,1,2,4,5,5,6], </span>k = 4<strong>输出:</strong> 4</pre><p>&nbsp;</p><p><strong>提示： </strong></p><ul>  <li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>-10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>4</sup></code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：优先队列"><a href="#参考代码：优先队列" class="headerlink" title="参考代码：优先队列"></a>参考代码：优先队列</h3><blockquote><p>时间复杂度：$O(nlogk)$</p><p>空间复杂度：$O(k)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 小根堆。存储数组中最大的 k 个元素</span>        <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> minHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 堆中元素小于 k 个，可以直接插入</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                minHeap<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 如果堆顶元素更小，就弹出堆顶，并将当前值插入堆中。</span>                minHeap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                minHeap<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> minHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><h3 id="参考代码：快速选择"><a href="#参考代码：快速选择" class="headerlink" title="参考代码：快速选择"></a>参考代码：快速选择</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$  <code>如果可以破坏原数组，则空间复杂度 O(logn)</code></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 不破坏原有数组，故使用 nums.clone</span>        <span class="token keyword">return</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> picked <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>picked <span class="token operator">==</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>picked<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>picked <span class="token operator">&lt;</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> picked <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                n right <span class="token operator">=</span> picked <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 在数组 nums 的区间 [left, right] 中生成一个随机索引，     * 该索引处的元素放入最终排好序的位置，返回其排好序的索引。     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 生成一个 [left, right] 的随机整数</span>        <span class="token keyword">int</span> picked <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> left<span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> picked<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token comment">// nums[left + 1, index] &lt; pivot</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> index<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> index<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> index<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先队列 </tag>
            
            <tag> 快速选择 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 208 题：实现 Trie (前缀树)（中等）</title>
      <link href="/leetcode/208/"/>
      <url>/leetcode/208/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-208-题：实现-Trie-前缀树"><a href="#「力扣」第-208-题：实现-Trie-前缀树" class="headerlink" title="「力扣」第 208 题：实现 Trie (前缀树)"></a>「力扣」第 208 题：实现 Trie (前缀树)</h2><ul><li><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><strong><a href="https://baike.baidu.com/item/字典树/9825209?fr=aladdin" target="_blank">Trie</a></strong>（发音类似 "try"）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><ul>  <li><code>Trie()</code> 初始化前缀树对象。</li>  <li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>  <li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>  <li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串&nbsp;<code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li> </ul><p>&nbsp;</p><pre><strong>示例：</strong><strong>输入</strong>["Trie", "insert", "search", "search", "startsWith", "insert", "search"][[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]<strong>输出</strong>[null, null, true, false, true, null, true]<strong>解释</strong>Trie trie = new Trie();trie.insert("apple");trie.search("apple");   // 返回 Truetrie.search("app");     // 返回 Falsetrie.startsWith("app"); // 返回 Truetrie.insert("app");trie.search("app");     // 返回 True</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>  <li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>  <li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 10<sup>4</sup></code> 次</li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：字典树"><a href="#参考代码：字典树" class="headerlink" title="参考代码：字典树"></a>参考代码：字典树</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">{</span>        <span class="token comment">/**     * word 和 prefix 仅由小写英文字母组成     */</span>    <span class="token keyword">private</span> <span class="token class-name">Trie</span><span class="token punctuation">[</span><span class="token punctuation">]</span> children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Trie</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">/**     * 表示该节点是否为字符串的结尾     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isEnd <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Trie</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        node<span class="token punctuation">.</span>isEnd <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Trie</span> node <span class="token operator">=</span> <span class="token function">searchPrefix</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>isEnd<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token class-name">String</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">searchPrefix</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 如果之前已经插入的字符串 word 的前缀之一为 prefix ，     * 返回 prefix 的最后一个结点 ；否则，返回 null 。     */</span>    <span class="token keyword">private</span> <span class="token class-name">Trie</span> <span class="token function">searchPrefix</span><span class="token punctuation">(</span><span class="token class-name">String</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Trie</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> prefix<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 207 题：课程表（中等）</title>
      <link href="/leetcode/207/"/>
      <url>/leetcode/207/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-207-题：课程表"><a href="#「力扣」第-207-题：课程表" class="headerlink" title="「力扣」第 207 题：课程表"></a>「力扣」第 207 题：课程表</h2><ul><li><a href="https://leetcode.cn/problems/course-schedule/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>numCourses - 1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组&nbsp;<code>prerequisites</code> 给出，其中&nbsp;<code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> ，表示如果要学习课程&nbsp;<code>a<sub>i</sub></code> 则 <strong>必须</strong> 先学习课程&nbsp; <code>b<sub>i</sub></code><sub> </sub>。</p><ul>  <li>例如，先修课程对&nbsp;<code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li> </ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>numCourses = 2, prerequisites = [[1,0]]<strong>输出：</strong>true<strong>解释：</strong>总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</pre><pre><strong>示例 2：</strong><strong>输入：</strong>numCourses = 2, prerequisites = [[1,0],[0,1]]<strong>输出：</strong>false<strong>解释：</strong>总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；    并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= numCourses &lt;= 10<sup>5</sup></code></li>  <li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>  <li><code>prerequisites[i].length == 2</code></li>  <li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>  <li><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：广度优先搜索"><a href="#参考代码：广度优先搜索" class="headerlink" title="参考代码：广度优先搜索"></a>参考代码：广度优先搜索</h3><blockquote><p>时间复杂度：$O(m+n)$</p><p>空间复杂度：$O(m+n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canFinish</span><span class="token punctuation">(</span><span class="token keyword">int</span> numCourses<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 入度表。inDegree[i] = val 表示学习课程 i 需要先修的课程有 val 门</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inDegree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 边。第 i 个元素表示修完课程 i 后才能学习的课程列表</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> edges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>numCourses<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            edges<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">:</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>            inDegree<span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            edges<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 首先加入入度为 0 ，即不需要先修课的结点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>inDegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">// 记录已经出队的课程数量</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Integer</span> u <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">// 遍历当前出队节点的所有后继节点</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> v <span class="token operator">:</span> edges<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                inDegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token comment">// 点 v 的入度为 0 ，将 v 入队列</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>inDegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count <span class="token operator">==</span> numCourses<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 206 题：反转链表（简单）</title>
      <link href="/leetcode/206/"/>
      <url>/leetcode/206/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-206-题：反转链表"><a href="#「力扣」第-206-题：反转链表" class="headerlink" title="「力扣」第 206 题：反转链表"></a>「力扣」第 206 题：反转链表</h2><ul><li><a href="https://leetcode.cn/problems/reverse-linked-list/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/234/">「力扣」第 234 题：回文链表</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/206/rev1ex1.jpg" style="width: 542px; height: 222px;"><strong>输入：</strong>head = [1,2,3,4,5]<strong>输出：</strong>[5,4,3,2,1]</pre><pre><strong>示例 2：</strong><img alt="" src="../../images/leetcode/206/rev1ex2.jpg" style="width: 182px; height: 222px;"><strong>输入：</strong>head = [1,2]<strong>输出：</strong>[2,1]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>head = []<strong>输出：</strong>[]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li>链表中节点的数目范围是 <code>[0, 5000]</code></li>    <li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p></p><p>&nbsp;</p><p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><p>&nbsp;</p><p><strong>链表结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：链表"><a href="#参考代码：链表" class="headerlink" title="参考代码：链表"></a>参考代码：链表</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 初始化上一个指针</span>        <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 初始化当前指针</span>        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 第 1 步：先把 next 存起来，下一轮迭代要用到</span>            <span class="token class-name">ListNode</span> next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment">// 第 2 步：实现当前结点的 next 指针的反转</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            <span class="token comment">// 第 3 步：重新定义下一轮迭代的循环变量</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 遍历完成以后，原来的最后一个结点就成为了 pre</span>        <span class="token comment">// 这个 pre 就是反转以后新的链表的头指针</span>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 200 题：岛屿数量（中等）</title>
      <link href="/leetcode/200/"/>
      <url>/leetcode/200/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-200-题：岛屿数量"><a href="#「力扣」第-200-题：岛屿数量" class="headerlink" title="「力扣」第 200 题：岛屿数量"></a>「力扣」第 200 题：岛屿数量</h2><ul><li><a href="https://leetcode.cn/problems/number-of-islands/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/79/">「力扣」第 79 题：单词搜索</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个由&nbsp;<code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>grid = [  ["1","1","1","1","0"],  ["1","1","0","1","0"],  ["1","1","0","0","0"],  ["0","0","0","0","0"]]<strong>输出：</strong>1</pre><pre><strong>示例 2：</strong><strong>输入：</strong>grid = [  ["1","1","0","0","0"],  ["1","1","0","0","0"],  ["0","0","1","0","0"],  ["0","0","0","1","1"]]<strong>输出：</strong>3</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>m == grid.length</code></li>  <li><code>n == grid[i].length</code></li>  <li><code>1 &lt;= m, n &lt;= 300</code></li>  <li><code>grid[i][j]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：深度优先搜索"><a href="#参考代码：深度优先搜索" class="headerlink" title="参考代码：深度优先搜索"></a>参考代码：深度优先搜索</h3><blockquote><p>时间复杂度：$O(m \times n)$</p><p>空间复杂度：$O(m \times n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numIslands</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                    res<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">// 还原 grid 数组</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'2'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'1'</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> col<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 如果 (row, col) 不是岛屿中的陆地，直接返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isArea</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col<span class="token punctuation">)</span> <span class="token operator">||</span> grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 将格子标记为「已遍历过」</span>        grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'2'</span><span class="token punctuation">;</span>        <span class="token comment">// 访问上、下、左、右四个相邻结点</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> row <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isArea</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> col<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>row <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> row <span class="token operator">&lt;</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>col <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> col <span class="token operator">&lt;</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 198 题：打家劫舍（中等）</title>
      <link href="/leetcode/198/"/>
      <url>/leetcode/198/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-198-题：打家劫舍"><a href="#「力扣」第-198-题：打家劫舍" class="headerlink" title="「力扣」第 198 题：打家劫舍"></a>「力扣」第 198 题：打家劫舍</h2><ul><li><a href="https://leetcode.cn/problems/house-robber/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/337/">「力扣」第 337 题：打家劫舍 III</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong> 不触动警报装置的情况下 </strong>，一夜之内能够偷窃到的最高金额。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>[1,2,3,1]<strong>输出：</strong>4<strong>解释：</strong>偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。&nbsp;    偷窃到的最高金额 = 1 + 3 = 4 。</pre><pre><strong>示例 2：</strong><strong>输入：</strong>[2,7,9,3,1]<strong>输出：</strong>12<strong>解释：</strong>偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。&nbsp;    偷窃到的最高金额 = 2 + 9 + 1 = 12 。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= nums.length &lt;= 100</code></li>  <li><code>0 &lt;= nums[i] &lt;= 400</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：动态规划"><a href="#参考代码：动态规划" class="headerlink" title="参考代码：动态规划"></a>参考代码：动态规划</h3><p><code>dp[i]</code> 表示前 <code>i</code> 间房屋能偷窃到的最高总金额</p><p><strong>动态规划转移方程：</strong></p><ul><li><code>dp[i] = max(dp[i−2]+nums[i], dp[i−1])</code></li></ul><p>考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。</p><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1 &lt;= nums.length &lt;= 100</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> first <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> second <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> second<span class="token punctuation">;</span>            second <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>first <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> second<span class="token punctuation">)</span><span class="token punctuation">;</span>            first <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> second<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 169 题：多数元素（简单）</title>
      <link href="/leetcode/169/"/>
      <url>/leetcode/169/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-169-题：多数元素"><a href="#「力扣」第-169-题：多数元素" class="headerlink" title="「力扣」第 169 题：多数元素"></a>「力扣」第 169 题：多数元素</h2><ul><li><a href="https://leetcode.cn/problems/majority-element/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个大小为 <code>n</code><em> </em>的数组&nbsp;<code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong>&nbsp;<code>⌊ n/2 ⌋</code>&nbsp;的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>&nbsp;</p><pre><strong>示例&nbsp;1：</strong><strong>输入：</strong>nums = [3,2,3]<strong>输出：</strong>3</pre><pre><strong>示例&nbsp;2：</strong><strong>输入：</strong>nums = [2,2,1,1,1,2,2]<strong>输出：</strong>2</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>n == nums.length</code></li>    <li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>    <li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li></ul><p></p><p>&nbsp;</p><p><strong>进阶：</strong>尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：Boyer-Moore-投票算法"><a href="#参考代码：Boyer-Moore-投票算法" class="headerlink" title="参考代码：Boyer-Moore 投票算法"></a>参考代码：Boyer-Moore 投票算法</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 初始化为一个 nums 中不存在的数。-10^9 &lt;= nums[i] &lt;= 10^9</span>        <span class="token comment">// 或者定义为 Integer 并初始化为 null（==比较时自动拆箱和自动装箱降低运行速度）</span>        <span class="token keyword">int</span> candidate <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 候选人下台，下一个候选人上</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                candidate <span class="token operator">=</span> num<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            count <span class="token operator">+=</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> candidate<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> candidate<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Boyer-Moore 投票算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 160 题：相交链表（简单）</title>
      <link href="/leetcode/160/"/>
      <url>/leetcode/160/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-160-题：相交链表"><a href="#「力扣」第-160-题：相交链表" class="headerlink" title="「力扣」第 160 题：相交链表"></a>「力扣」第 160 题：相交链表</h2><ul><li><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个单链表的头节点&nbsp;<code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><a href="../../images/leetcode/160/160_statement.png" target="_blank"><img alt="" src="../../images/leetcode/160/160_statement.png" style="height: 130px; width: 400px;"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul>    <li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>    <li><code>listA</code> - 第一个链表</li>    <li><code>listB</code> - 第二个链表</li>    <li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>    <li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><a href="../../images/leetcode/160/160_example_1.png" target="_blank"><img alt="" src="../../images/leetcode/160/160_example_1_1.png" style="height: 130px; width: 400px;"></a><strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3<strong>输出：</strong>Intersected at '8'<strong>解释：</strong>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</pre><pre><strong>示例&nbsp;2：</strong><a href="../../images/leetcode/160/160_example_2.png" target="_blank"><img alt="" src="../../images/leetcode/160/160_example_2.png" style="height: 136px; width: 350px;"></a><strong>输入：</strong>intersectVal&nbsp;= 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<strong>输出：</strong>Intersected at '2'<strong>解释：</strong>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</pre><pre><strong>示例&nbsp;3：</strong><a href="../../images/leetcode/160/160_example_3.png" target="_blank"><img alt="" src="../../images/leetcode/160/160_example_3.png" style="height: 126px; width: 200px;"></a><strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<strong>输出：</strong>null<strong>解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>listA</code> 中节点数目为 <code>m</code></li>    <li><code>listB</code> 中节点数目为 <code>n</code></li>    <li><code>1 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>    <li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>    <li><code>0 &lt;= skipA &lt;= m</code></li>    <li><code>0 &lt;= skipB &lt;= n</code></li>    <li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>    <li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><p></p><p>&nbsp;</p><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><p>&nbsp;</p><p><strong>链表结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { *         val = x; *         next = null; *     } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：双指针"><a href="#参考代码：双指针" class="headerlink" title="参考代码：双指针"></a>参考代码：双指针</h3><blockquote><p>时间复杂度：$O(m+n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> headA<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 指针 ptr1 先指向 headA 的头结点，直到最后一个结点后转而指向 headB 的头结点</span>        <span class="token class-name">ListNode</span> ptr1 <span class="token operator">=</span> headA<span class="token punctuation">;</span>        <span class="token comment">// 指针 ptr2 先指向 headB 的头结点，直到最后一个结点后转而指向 headA 的头结点</span>        <span class="token class-name">ListNode</span> ptr2 <span class="token operator">=</span> headB<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>ptr1 <span class="token operator">!=</span> ptr2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ptr1 <span class="token operator">=</span> <span class="token punctuation">(</span>ptr1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> headB <span class="token operator">:</span> ptr1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            ptr2 <span class="token operator">=</span> <span class="token punctuation">(</span>ptr2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> headA <span class="token operator">:</span> ptr2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ptr1<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 155 题：最小栈（中等）</title>
      <link href="/leetcode/155/"/>
      <url>/leetcode/155/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-155-题：最小栈"><a href="#「力扣」第-155-题：最小栈" class="headerlink" title="「力扣」第 155 题：最小栈"></a>「力扣」第 155 题：最小栈</h2><ul><li><a href="https://leetcode.cn/problems/min-stack/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul>  <li><code>MinStack()</code> 初始化堆栈对象。</li>  <li><code>void push(int val)</code> 将元素val推入堆栈。</li>  <li><code>void pop()</code> 删除堆栈顶部的元素。</li>  <li><code>int top()</code> 获取堆栈顶部的元素。</li>  <li><code>int getMin()</code> 获取堆栈中的最小元素。</li> </ul><p>&nbsp;</p><pre><strong>示例 1:</strong><strong>输入：</strong>["MinStack","push","push","push","getMin","pop","top","getMin"][[],[-2],[0],[-3],[],[],[],[]]<strong>输出：</strong>[null,null,null,null,-3,null,0,-2]<strong>解释：</strong>MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>-2<sup>31</sup>&nbsp;&lt;= val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>  <li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li>  <li><code>push</code>,&nbsp;<code>pop</code>,&nbsp;<code>top</code>, and&nbsp;<code>getMin</code>最多被调用&nbsp;<code>3 * 10<sup>4</sup></code>&nbsp;次</li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：最小栈"><a href="#参考代码：最小栈" class="headerlink" title="参考代码：最小栈"></a>参考代码：最小栈</h3><p>使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。</p><ul><li><p>当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；</p></li><li><p>当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；</p></li><li><p>在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</p></li></ul><blockquote><p>时间复杂度：对于题目中的所有操作，时间复杂度均为 $O(1)$ 。</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MinStack</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 辅助栈，是一个非严格的单调栈，栈顶元素是栈中最小元素</span>    <span class="token keyword">private</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> helper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">MinStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        helper<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 辅助栈每次入栈的元素是栈顶元素与当前元素的最小值</span>        helper<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>helper<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        helper<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> helper<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 152 题：乘积最大子数组（中等）</title>
      <link href="/leetcode/152/"/>
      <url>/leetcode/152/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-152-题：乘积最大子数组"><a href="#「力扣」第-152-题：乘积最大子数组" class="headerlink" title="「力扣」第 152 题：乘积最大子数组"></a>「力扣」第 152 题：乘积最大子数组</h2><ul><li><a href="https://leetcode.cn/problems/maximum-product-subarray/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/53/">「力扣」第 53 题：最大子数组和</a></li><li><a href="https://iiifox.github.io/leetcode/238/">「力扣」第 238 题：除自身以外数组的乘积</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code>&nbsp;，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个&nbsp;<strong>32-位</strong> 整数。</p><p><strong>子数组</strong> 是数组的连续子序列。</p><p>&nbsp;</p><pre><strong>示例 1:</strong><strong>输入:</strong> nums = [2,3,-2,4]<strong>输出:</strong> <span>6</span><strong>解释:</strong>&nbsp;子数组 [2,3] 有最大乘积 6。</pre><pre><strong>示例 2:</strong><strong>输入:</strong> nums = [-2,0,-1]<strong>输出:</strong> 0<strong>解释:</strong>&nbsp;结果不能为 2, 因为 [-2,-1] 不是子数组。</pre><p>&nbsp;</p><p><strong>提示:</strong></p><ul>  <li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>  <li><code>-10 &lt;= nums[i] &lt;= 10</code></li>  <li><code>nums</code> 的任何前缀或后缀的乘积都 <strong>保证</strong>&nbsp;是一个 <strong>32-位</strong> 整数</li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：动态规划"><a href="#参考代码：动态规划" class="headerlink" title="参考代码：动态规划"></a>参考代码：动态规划</h3><p><code>maxDp[i]</code> 表示以 <code>nums[i]</code> 结尾的乘积最大子数组的乘积，</p><p><code>minDp[i]</code> 表示以 <code>nums[i]</code> 结尾的乘积最小子数组的乘积，</p><p><strong>动态规划转移方程：</strong></p><ul><li><code>maxDp[i] = max{maxDp[i-1]*nums[i], minDp[i-1]*nums[i], nums[i]}</code></li><li><code>minDp[i] = min{maxDp[i-1]*nums[i], minDp[i-1]*nums[i], nums[i]}</code></li></ul><p>由于第 <code>i</code> 个状态只和第 <code>i-1</code> 个状态相关，根据「滚动数组」思想，我们可以只用两个变量来维护 <code>i−1</code> 时刻的状态，一个维护 <code>maxDp[i-1]</code> ，一个维护 <code>minDp[i-1]</code> 。</p><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProduct</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1 &lt;= nums.length &lt;= 2 * 10^4</span>        <span class="token keyword">int</span> maxDp <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minDp <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> max <span class="token operator">=</span> maxDp<span class="token punctuation">;</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> minDp<span class="token punctuation">;</span>            maxDp <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> min <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            minDp <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>max <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> min <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> maxDp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 148 题：排序链表（中等）</title>
      <link href="/leetcode/148/"/>
      <url>/leetcode/148/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-148-题：排序链表"><a href="#「力扣」第-148-题：排序链表" class="headerlink" title="「力扣」第 148 题：排序链表"></a>「力扣」第 148 题：排序链表</h2><ul><li><a href="https://leetcode.cn/problems/sort-list/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/21/">「力扣」第 21 题：合并两个有序链表</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你链表的头结点&nbsp;<code>head</code>&nbsp;，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/148/sort_list_1.jpg" style="width: 450px;"> <b>输入：</b>head = [4,2,1,3]<b>输出：</b>[1,2,3,4]</pre><pre><strong>示例 2：</strong><img alt="" src="../../images/leetcode/148/sort_list_2.jpg" style="width: 550px;"> <b>输入：</b>head = [-1,5,3,4,0]<b>输出：</b>[-1,0,3,4,5]</pre><pre><strong>示例 3：</strong><b>输入：</b>head = []<b>输出：</b>[]</pre><p>&nbsp;</p><p><b>提示：</b></p><ul>  <li>链表中节点的数目在范围&nbsp;<code>[0, 5 * 10<sup>4</sup>]</code>&nbsp;内</li>  <li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li> </ul><p></p><p>&nbsp;</p><p><b>进阶：</b>你可以在&nbsp;<code>O(n&nbsp;log&nbsp;n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><p>&nbsp;</p><p><strong>链表结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：自顶向下的归并排序（推荐）"><a href="#参考代码：自顶向下的归并排序（推荐）" class="headerlink" title="参考代码：自顶向下的归并排序（推荐）"></a>参考代码：自顶向下的归并排序（推荐）</h3><p><strong>时间复杂度明显优于自底向上（最高阶的常数项系数更小）</strong></p><blockquote><p>时间复杂度：$O(nlogn)$</p><p>空间复杂度：$O(logn)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">sortList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 设置递归终止条件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">// 防止当链表长度为 2 时，slow 指向第二个元素</span>        <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">ListNode</span> head2 <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        slow<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token function">sortList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sortList</span><span class="token punctuation">(</span>head2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 「力扣」第 21 题：合并两个有序链表</span>    <span class="token keyword">private</span> <span class="token class-name">ListNode</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> list1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> list2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ListNode</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token comment">// 两者都不为空的时候，才有必要进行比较</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>list1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> list2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>list1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> list1<span class="token punctuation">;</span>                list1 <span class="token operator">=</span> list1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> list2<span class="token punctuation">;</span>                list2 <span class="token operator">=</span> list2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 跳出循环时 list1 与 list2 有且仅有一条为空</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token punctuation">(</span>list1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> list2 <span class="token operator">:</span> list1<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><h3 id="参考代码：自底向上的归并排序（进阶）"><a href="#参考代码：自底向上的归并排序（进阶）" class="headerlink" title="参考代码：自底向上的归并排序（进阶）"></a>参考代码：自底向上的归并排序（进阶）</h3><blockquote><p>时间复杂度：$O(nlogn)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">sortList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 计算链表的长度</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ListNode</span> node <span class="token operator">=</span> head<span class="token punctuation">;</span> node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> node <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            length<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 虚拟头结点</span>        <span class="token class-name">ListNode</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 自底向上的归并排序：每连续两段长为 subLength 的有序链表进行合并排序</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> subLength <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> subLength <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> subLength <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> dummy<span class="token punctuation">;</span>            <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 截取第一段 subLength 长的链表 [head1, cur]</span>                <span class="token class-name">ListNode</span> head1 <span class="token operator">=</span> cur<span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> subLength <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 截取第二段 subLength 长的链表 [head2, cur]</span>                <span class="token class-name">ListNode</span> head2 <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token comment">// 第二段链表最后一个结点的下一个结点，用于辅助定位下一轮循环的起点</span>                <span class="token class-name">ListNode</span> next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cur <span class="token operator">=</span> head2<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> subLength <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token comment">// 更新 cur 指针，准备下一轮循环的选取</span>                    cur <span class="token operator">=</span> next<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// pre 指针的 next 域指向合并后两条链表的头结点，并更新 pre 指针</span>                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>head1<span class="token punctuation">,</span> head2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 「力扣」第 21 题：合并两个有序链表</span>    <span class="token keyword">private</span> <span class="token class-name">ListNode</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> list1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> list2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ListNode</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token comment">// 两者都不为空的时候，才有必要进行比较</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>list1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> list2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>list1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> list1<span class="token punctuation">;</span>                list1 <span class="token operator">=</span> list1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> list2<span class="token punctuation">;</span>                list2 <span class="token operator">=</span> list2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 跳出循环时 list1 与 list2 有且仅有一条为空</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token punctuation">(</span>list1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> list2 <span class="token operator">:</span> list1<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 146 题：LRU 缓存（中等）</title>
      <link href="/leetcode/146/"/>
      <url>/leetcode/146/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-146-题：LRU-缓存"><a href="#「力扣」第-146-题：LRU-缓存" class="headerlink" title="「力扣」第 146 题：LRU 缓存"></a>「力扣」第 146 题：LRU 缓存</h2><ul><li><a href="https://leetcode.cn/problems/lru-cache/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><div class="title__3Vvk"> 请你设计并实现一个满足&nbsp;  <a href="https://baike.baidu.com/item/LRU" target="_blank">LRU (最近最少使用) 缓存</a> 约束的数据结构。</div><div class="title__3Vvk"> 实现  <code>LRUCache</code> 类：</div><div class="original__bRMd">  <div>   <ul>    <li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量&nbsp;<code>capacity</code> 初始化 LRU 缓存</li>    <li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>    <li><code>void put(int key, int value)</code>&nbsp;如果关键字&nbsp;<code>key</code> 已经存在，则变更其数据值&nbsp;<code>value</code> ；如果不存在，则向缓存中插入该组&nbsp;<code>key-value</code> 。如果插入操作导致关键字数量超过&nbsp;<code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>   </ul>  </div></div><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p>&nbsp;</p><p><strong>示例：</strong></p><pre><strong>输入</strong>["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<strong>输出</strong>[null, null, null, 1, null, -1, null, -1, 3, 4]<strong>解释</strong>LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 {1=1}lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}lRUCache.get(1);    // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.get(2);    // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}lRUCache.get(1);    // 返回 -1 (未找到)lRUCache.get(3);    // 返回 3lRUCache.get(4);    // 返回 4</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= capacity &lt;= 3000</code></li>  <li><code>0 &lt;= key &lt;= 10000</code></li>  <li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>  <li>最多调用 <code>2 * 10<sup>5</sup></code> 次 <code>get</code> 和 <code>put</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：LRU"><a href="#参考代码：LRU" class="headerlink" title="参考代码：LRU"></a>参考代码：LRU</h3><blockquote><p>时间复杂度：对于 <code>put</code> 和 <code>get</code> 都是 $O(1)$</p><p>空间复杂度：$O(capacity)$</p></blockquote><p><strong>方法一：直接使用底层提供的功能</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 第三个参数 accessOrder：true 基于访问顺序，false 基于插入顺序</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> <span class="token number">0.75F</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p><strong>方法二：手动实现</strong></p><p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p><ul><li><p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p></li><li><p>哈希表即为普通的哈希映射（<code>HashMap</code>），通过缓存数据的键映射到其在双向链表中的位置。</p></li></ul><p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 $O(1)$ 的时间内完成 <code>get</code> 或者 <code>put</code> 操作。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 双向链表的结点类     */</span>    <span class="token keyword">class</span> <span class="token class-name">LRUCacheNode</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> key<span class="token punctuation">;</span>        <span class="token keyword">int</span> value<span class="token punctuation">;</span>        <span class="token class-name">LRUCacheNode</span> pre<span class="token punctuation">;</span>        <span class="token class-name">LRUCacheNode</span> next<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">LRUCacheNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">LRUCacheNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token comment">// 双向链表的虚拟头结点与虚拟尾结点</span>    <span class="token keyword">private</span> <span class="token class-name">LRUCacheNode</span> dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LRUCacheNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">LRUCacheNode</span> dummyTail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LRUCacheNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 哈希表：通过缓存数据的键映射到其在双向链表中的位置</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">LRUCacheNode</span><span class="token punctuation">&gt;</span></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>        dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> dummyTail<span class="token punctuation">;</span>        dummyTail<span class="token punctuation">.</span>pre <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">LRUCacheNode</span> node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 如果 key 存在，先通过哈希表定位，再移动到头部</span>        <span class="token function">removeToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">LRUCacheNode</span> node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 如果 key 不存在，创建一个新的结点</span>            <span class="token class-name">LRUCacheNode</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LRUCacheNode</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 添加进哈希表</span>            cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 添加至双向链表的头部</span>            <span class="token function">addToHead</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            size<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 如果超出容量，删除双向链表的尾部结点并删除哈希表中对应的项</span>                cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token function">removeTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                size<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span>            node<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token function">removeToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeToHead</span><span class="token punctuation">(</span><span class="token class-name">LRUCacheNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token class-name">LRUCacheNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node<span class="token punctuation">.</span>pre<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>pre <span class="token operator">=</span> node<span class="token punctuation">.</span>pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addToHead</span><span class="token punctuation">(</span><span class="token class-name">LRUCacheNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 先处理好 node 结点的指针指向</span>        node<span class="token punctuation">.</span>pre <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> dummyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment">// 处理 node 结点的 next 域结点的 pre 指针指向</span>        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>pre <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token comment">// 处理 node 结点的 pre 域结点（虚拟头结点）的 next 指针指向</span>        <span class="token comment">// node.pre.next = node;</span>        dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token class-name">LRUCacheNode</span> <span class="token function">removeTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">LRUCacheNode</span> res <span class="token operator">=</span> dummyTail<span class="token punctuation">.</span>pre<span class="token punctuation">;</span>        <span class="token function">removeNode</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计 </tag>
            
            <tag> LRU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 142 题：环形链表 II（中等）</title>
      <link href="/leetcode/142/"/>
      <url>/leetcode/142/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-142-题：环形链表-II"><a href="#「力扣」第-142-题：环形链表-II" class="headerlink" title="「力扣」第 142 题：环形链表 II"></a>「力扣」第 142 题：环形链表 II</h2><ul><li><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/141/">「力扣」第 141 题：环形链表</a></li><li><a href="https://iiifox.github.io/leetcode/287/">「力扣」第 287 题：寻找重复数</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表的头节点 &nbsp;<code>head</code>&nbsp;，返回链表开始入环的第一个节点。如果链表无环，则返回&nbsp;<code>null</code>。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改 </strong>链表。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img src="../../images/leetcode/142/circularlinkedlist.png"><strong>输入：</strong>head = [3,2,0,-4], pos = 1<strong>输出：</strong>返回索引为 1 的链表节点<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。</pre><pre><strong>示例&nbsp;2：</strong><img alt="" src="../../images/leetcode/142/circularlinkedlist_test2.png"><strong>输入：</strong>head = [1,2], pos = 0<strong>输出：</strong>返回索引为 0 的链表节点<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。</pre><pre><strong>示例 3：</strong><img alt="" src="../../images/leetcode/142/circularlinkedlist_test3.png"><strong>输入：</strong>head = [1], pos = -1<strong>输出：</strong>返回 null<strong>解释：</strong>链表中没有环。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li>链表中节点的数目范围在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>    <li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>    <li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p></p><p>&nbsp;</p><p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p><p>&nbsp;</p><p><strong>链表结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { *         val = x; *         next = null; *     } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：Floyd-判圈算法"><a href="#参考代码：Floyd-判圈算法" class="headerlink" title="参考代码：Floyd 判圈算法"></a>参考代码：Floyd 判圈算法</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">// 慢指针一次走一步、快指针一次走两步，快慢指针能够相遇则说明存在环</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment">// 链表中存在环，此时快指针比慢指针在环中多移动 n 圈</span>            <span class="token comment">// 因为快指针走的路程是慢指针的两倍，</span>            <span class="token comment">// 于是从头结点到快慢指针相遇的距离恰好就是环的 n 圈</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">// 循环不是 beak 退出的，链表不存在环</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> fast<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 链表中存在环。将慢指针指向头结点，此后快慢指针每次均移动一步</span>        slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">// 显然快指针在环中再移动 n 圈后两指针会在原来相遇点处再次相遇，</span>        <span class="token comment">// 此时快慢指针速度一样，因此第二次相遇的起始点处就是入环的第一个结点</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
            <tag> Floyd 判圈算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 141 题：环形链表（简单）</title>
      <link href="/leetcode/141/"/>
      <url>/leetcode/141/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-141-题：环形链表"><a href="#「力扣」第-141-题：环形链表" class="headerlink" title="「力扣」第 141 题：环形链表"></a>「力扣」第 141 题：环形链表</h2><ul><li><a href="https://leetcode.cn/problems/linked-list-cycle/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/142/">「力扣」第 142 题：环形链表 II</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递&nbsp;</strong>。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/141/circularlinkedlist.png"><strong>输入：</strong>head = [3,2,0,-4], pos = 1<strong>输出：</strong>true<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。</pre><pre><strong>示例&nbsp;2：</strong><img alt="" src="../../images/leetcode/141/circularlinkedlist_test2.png"><strong>输入：</strong>head = [1,2], pos = 0<strong>输出：</strong>true<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。</pre><pre><strong>示例 3：</strong><img alt="" src="../../images/leetcode/141/circularlinkedlist_test3.png"><strong>输入：</strong>head = [1], pos = -1<strong>输出：</strong>false<strong>解释：</strong>链表中没有环。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li>链表中节点的数目范围是 <code>[0, 10<sup>4</sup>]</code></li>    <li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>    <li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><p></p><p>&nbsp;</p><p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p><p>&nbsp;</p><p><strong>链表结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { *         val = x; *         next = null; *     } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：快慢指针"><a href="#参考代码：快慢指针" class="headerlink" title="参考代码：快慢指针"></a>参考代码：快慢指针</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">// 慢指针一次走一步、快指针一次走两步，快慢指针能够相遇则说明存在环</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 139 题：单词拆分（中等）</title>
      <link href="/leetcode/139/"/>
      <url>/leetcode/139/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-139-题：单词拆分"><a href="#「力扣」第-139-题：单词拆分" class="headerlink" title="「力扣」第 139 题：单词拆分"></a>「力扣」第 139 题：单词拆分</h2><ul><li><a href="https://leetcode.cn/problems/word-break/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p><p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入:</strong> s = "leetcode", wordDict = ["leet", "code"]<strong>输出:</strong> true<strong>解释:</strong> 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。</pre><pre><strong>示例 2：</strong><strong>输入:</strong> s = "applepenapple", wordDict = ["apple", "pen"]<strong>输出:</strong> true<strong>解释:</strong> 返回 true 因为 <span>"</span>applepenapple<span>"</span> 可以由 <span>"</span>apple" "pen" "apple<span>" 拼接成</span>。&nbsp;    注意，你可以重复使用字典中的单词。</pre><pre><strong>示例 3：</strong><strong>输入:</strong> s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]<strong>输出:</strong> false</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= s.length &lt;= 300</code></li>  <li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>  <li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>  <li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li>  <li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：动态规划"><a href="#参考代码：动态规划" class="headerlink" title="参考代码：动态规划"></a>参考代码：动态规划</h3><blockquote><p>时间复杂度：$O(n^2)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//  dp[i] 表示字符串 s 前 i 个字符组成的字符串满足题意</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 1 &lt;= wordDict[i].length &lt;= 20</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// s[0, j-1] 满足 &amp;&amp; s[j, i-1] 是集合中的字符串</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 136 题：只出现一次的数字（简单）</title>
      <link href="/leetcode/136/"/>
      <url>/leetcode/136/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-136-题：只出现一次的数字"><a href="#「力扣」第-136-题：只出现一次的数字" class="headerlink" title="「力扣」第 136 题：只出现一次的数字"></a>「力扣」第 136 题：只出现一次的数字</h2><ul><li><p><a href="https://leetcode.cn/problems/single-number/">链接</a></p></li><li><p><a href="https://iiifox.github.io/leetcode/287/">「力扣」第 287 题：寻找重复数</a></p></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><pre><strong>示例 1:</strong><strong>输入:</strong> [2,2,1]<strong>输出:</strong> 1</pre><pre><strong>示例&nbsp;2:</strong><strong>输入:</strong> [4,1,2,1,2]<strong>输出:</strong> 4</pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：位运算"><a href="#参考代码：位运算" class="headerlink" title="参考代码：位运算"></a>参考代码：位运算</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">^=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 128 题：最长连续序列（中等）</title>
      <link href="/leetcode/128/"/>
      <url>/leetcode/128/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-128-题：最长连续序列"><a href="#「力扣」第-128-题：最长连续序列" class="headerlink" title="「力扣」第 128 题：最长连续序列"></a>「力扣」第 128 题：最长连续序列</h2><ul><li><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为&nbsp;<code>O(n)</code><em> </em>的算法解决此问题。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [100,4,200,1,3,2]<strong>输出：</strong>4<strong>解释：</strong>最长数字连续序列是 <span>[1, 2, 3, 4]。它的长度为 4。</span></pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums = [0,3,7,2,5,8,4,6,0,1]<strong>输出：</strong>9</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：哈希表"><a href="#参考代码：哈希表" class="headerlink" title="参考代码：哈希表"></a>参考代码：哈希表</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 对于连续序列，我们只从最小的开始计数</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> currentStreak <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    currentStreak<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> currentStreak<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 124 题：二叉树中的最大路径和（困难）</title>
      <link href="/leetcode/124/"/>
      <url>/leetcode/124/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-124-题：二叉树中的最大路径和"><a href="#「力扣」第-124-题：二叉树中的最大路径和" class="headerlink" title="「力扣」第 124 题：二叉树中的最大路径和"></a>「力扣」第 124 题：二叉树中的最大路径和</h2><ul><li><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径<strong> 至少包含一个 </strong>节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/124/exx1.jpg" style="width: 322px; height: 182px;"> <strong>输入：</strong>root = [1,2,3]<strong>输出：</strong>6<strong>解释：</strong>最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</pre><pre><strong>示例 2：</strong><img alt="" src="../../images/leetcode/124/exx2.jpg"> <strong>输入：</strong>root = [-10,9,20,null,null,15,7]<strong>输出：</strong>42<strong>解释：</strong>最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li>树中节点数目范围是 <code>[1, 3 * 10<sup>4</sup>]</code></li>  <li><code>-1000 &lt;= Node.val &lt;= 1000</code></li> </ul><p></p><p>&nbsp;</p><p><strong>二叉树结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：深度优先搜索"><a href="#参考代码：深度优先搜索" class="headerlink" title="参考代码：深度优先搜索"></a>参考代码：深度优先搜索</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment">// -1000 &lt;= Node.val &lt;= 1000</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> maxSum <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">maxGain</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> maxSum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 在二叉树中寻找以根节点为起点的一条路径，使得该路径上的节点值之和最大     *     * @param root 根节点     * @return 路径上的结点值之和     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">maxGain</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 递归计算左右子结点的最大贡献值</span>        <span class="token comment">// 只有在最大贡献值大于零时，才会选取对应子节点</span>        <span class="token keyword">int</span> leftGain <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxGain</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rightGain <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxGain</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 结点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span>        <span class="token keyword">int</span> priceNewPath <span class="token operator">=</span> leftGain <span class="token operator">+</span> root<span class="token punctuation">.</span>val <span class="token operator">+</span> rightGain<span class="token punctuation">;</span>        <span class="token comment">// 更新答案</span>        maxSum <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxSum<span class="token punctuation">,</span> priceNewPath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 返回结点的最大贡献值</span>        <span class="token keyword">return</span> root<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftGain<span class="token punctuation">,</span> rightGain<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 121 题：买卖股票的最佳时机（简单）</title>
      <link href="/leetcode/121/"/>
      <url>/leetcode/121/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-121-题：买卖股票的最佳时机"><a href="#「力扣」第-121-题：买卖股票的最佳时机" class="headerlink" title="「力扣」第 121 题：买卖股票的最佳时机"></a>「力扣」第 121 题：买卖股票的最佳时机</h2><ul><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/53/">「力扣」第 53 题：最大子数组和</a></li><li><a href="https://iiifox.github.io/leetcode/309/">「力扣」第 309 题：最佳买卖股票时机含冷冻期</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组 <code>prices</code> ，它的第&nbsp;<code>i</code> 个元素&nbsp;<code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>[7,1,5,3,6,4]<strong>输出：</strong>5<strong>解释：</strong>在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</pre><pre><strong>示例 2：</strong><strong>输入：</strong>prices = [7,6,4,3,1]<strong>输出：</strong>0<strong>解释：</strong>在这种情况下, 没有交易完成, 所以最大利润为 0。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>  <li><code>0 &lt;= prices[i] &lt;= 10<sup>4</sup></code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：动态规划"><a href="#参考代码：动态规划" class="headerlink" title="参考代码：动态规划"></a>参考代码：动态规划</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 记录历史最低价格。0 &lt;= prices[i] &lt;= 10^4</span>        <span class="token keyword">int</span> minPrice <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> price <span class="token operator">:</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 判断是否需要更新历史最低价格</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>price <span class="token operator">&lt;</span> minPrice<span class="token punctuation">)</span> <span class="token punctuation">{</span>                minPrice <span class="token operator">=</span> price<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">&lt;</span> price <span class="token operator">-</span> minPrice<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// res：这一天之前的最低点买入所能获得的最大利润</span>                res <span class="token operator">=</span> price <span class="token operator">-</span> minPrice<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 114 题：二叉树展开为链表（中等）</title>
      <link href="/leetcode/114/"/>
      <url>/leetcode/114/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-114-题：二叉树展开为链表"><a href="#「力扣」第-114-题：二叉树展开为链表" class="headerlink" title="「力扣」第 114 题：二叉树展开为链表"></a>「力扣」第 114 题：二叉树展开为链表</h2><ul><li><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul>  <li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>  <li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin" target="_blank"><strong>先序遍历</strong></a> 顺序相同。</li> </ul><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/114/flaten.jpg" style="width: 500px; height: 226px;"> <strong>输入：</strong>root = [1,2,5,3,4,null,6]<strong>输出：</strong>[1,null,2,null,3,null,4,null,5,null,6]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>root = []<strong>输出：</strong>[]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>root = [0]<strong>输出：</strong>[0]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li>树中结点数在范围 <code>[0, 2000]</code> 内</li>  <li><code>-100 &lt;= Node.val &lt;= 100</code></li> </ul><p></p><p>&nbsp;</p><p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p><p>&nbsp;</p><p><strong>二叉树定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：类似-Morris-遍历查找前驱结点"><a href="#参考代码：类似-Morris-遍历查找前驱结点" class="headerlink" title="参考代码：类似 Morris 遍历查找前驱结点"></a>参考代码：类似 Morris 遍历查找前驱结点</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 当前结点的前驱结点</span>                <span class="token class-name">TreeNode</span> pre <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                pre<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token comment">// 处理当前结点的左右指针</span>                root<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 105 题：从前序与中序遍历序列构造二叉树（中等）</title>
      <link href="/leetcode/105/"/>
      <url>/leetcode/105/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-105-题：从前序与中序遍历序列构造二叉树"><a href="#「力扣」第-105-题：从前序与中序遍历序列构造二叉树" class="headerlink" title="「力扣」第 105 题：从前序与中序遍历序列构造二叉树"></a>「力扣」第 105 题：从前序与中序遍历序列构造二叉树</h2><ul><li><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个整数数组&nbsp;<code>preorder</code> 和 <code>inorder</code>&nbsp;，其中&nbsp;<code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code>&nbsp;是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p>&nbsp;</p><pre><strong>示例 1:</strong><img alt="" src="../../images/leetcode/105/tree.jpg" style="height: 302px; width: 277px;"> <strong>输入</strong><strong>:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<strong>输出:</strong> [3,9,20,null,null,15,7]</pre><pre><strong>示例 2:</strong><strong>输入:</strong> preorder = [-1], inorder = [-1]<strong>输出:</strong> [-1]</pre><p>&nbsp;</p><p><strong>提示:</strong></p><ul>  <li><code>1 &lt;= preorder.length &lt;= 3000</code></li>  <li><code>inorder.length == preorder.length</code></li>  <li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>  <li><code>preorder</code>&nbsp;和&nbsp;<code>inorder</code>&nbsp;均 <strong>无重复</strong> 元素</li>  <li><code>inorder</code>&nbsp;均出现在&nbsp;<code>preorder</code></li>  <li><code>preorder</code>&nbsp;<strong>保证</strong> 为二叉树的前序遍历序列</li>  <li><code>inorder</code>&nbsp;<strong>保证</strong> 为二叉树的中序遍历序列</li> </ul><p></p><p>&nbsp;</p><p><strong>二叉树结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：分治"><a href="#参考代码：分治" class="headerlink" title="参考代码：分治"></a>参考代码：分治</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>        <span class="token comment">// 键存取中序遍历中的结点值，值存取结点值对应的中序索引</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1 &lt;= preorder.length &lt;= 3000</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span> preLeft<span class="token punctuation">,</span> <span class="token keyword">int</span> preRight<span class="token punctuation">,</span>                               <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span> inLeft<span class="token punctuation">,</span> <span class="token keyword">int</span> inRight<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>preLeft <span class="token operator">&gt;</span> preRight<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 前序遍历中的第一个结点就是根节点。先把根节点建立出来</span>        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preLeft<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 在中序遍历中定位根节点（获取索引）</span>        <span class="token keyword">int</span> inRoot <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 得到左子树中的结点数目</span>        <span class="token keyword">int</span> leftSize <span class="token operator">=</span> inRoot <span class="token operator">-</span> inLeft<span class="token punctuation">;</span>        <span class="token comment">// 递归地构造左子树，并连接到根节点</span>        <span class="token comment">// 先序遍历中「从 左边界+1 开始的 leftSize」个元素</span>        <span class="token comment">// 就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preLeft <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preLeft <span class="token operator">+</span> leftSize<span class="token punctuation">,</span>                inorder<span class="token punctuation">,</span> inLeft<span class="token punctuation">,</span> inRoot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 递归地构造右子树，并连接到根节点</span>        <span class="token comment">// 先序遍历中「从 左边界+左子树节点数目+1 开始到 右边界」的元素</span>        <span class="token comment">// 就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preLeft <span class="token operator">+</span> leftSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preRight<span class="token punctuation">,</span>                inorder<span class="token punctuation">,</span> inRoot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inRight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 104 题：二叉树的最大深度（简单）</title>
      <link href="/leetcode/104/"/>
      <url>/leetcode/104/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-104-题：二叉树的最大深度"><a href="#「力扣」第-104-题：二叉树的最大深度" class="headerlink" title="「力扣」第 104 题：二叉树的最大深度"></a>「力扣」第 104 题：二叉树的最大深度</h2><ul><li><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/543/">「力扣」第 543 题：二叉树的直径</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong>&nbsp;叶子节点是指没有子节点的节点。</p><pre><strong>示例：</strong><br> 给定二叉树 [3,9,20,null,null,15,7]，<br>    3   / \  9  20    /  \   15   7</pre><p>返回它的最大深度&nbsp;3 。</p><p>&nbsp;</p><p><strong>二叉树结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：深度优先搜索"><a href="#参考代码：深度优先搜索" class="headerlink" title="参考代码：深度优先搜索"></a>参考代码：深度优先搜索</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(height)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span>            <span class="token operator">:</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 102 题：二叉树的层序遍历（中等）</title>
      <link href="/leetcode/102/"/>
      <url>/leetcode/102/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-102-题：二叉树的层序遍历"><a href="#「力扣」第-102-题：二叉树的层序遍历" class="headerlink" title="「力扣」第 102 题：二叉树的层序遍历"></a>「力扣」第 102 题：二叉树的层序遍历</h2><ul><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/102/tree1.jpg" style="width: 277px; height: 302px;"> <strong>输入：</strong>root = [3,9,20,null,null,15,7]<strong>输出：</strong>[[3],[9,20],[15,7]]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>root = [1]<strong>输出：</strong>[[1]]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>root = []<strong>输出：</strong>[]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>  <li><code>-1000 &lt;= Node.val &lt;= 1000</code></li> </ul><p></p><p>&nbsp;</p><p><strong>二叉树结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：广度优先搜索"><a href="#参考代码：广度优先搜索" class="headerlink" title="参考代码：广度优先搜索"></a>参考代码：广度优先搜索</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 树中节点数目在范围 [0, 2000] 内</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 存放当前层所有节点值的集合</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> level <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 当前层的结点个数</span>            <span class="token keyword">int</span> currentLevelSize <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 循环开始前，队列存放的仅有当前层的所有结点。</span>            <span class="token comment">// 循环中：队列依次将当前层结点出队，并将下一层所有节点依次入队</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currentLevelSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                level<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 101 题：对称二叉树（简单）</title>
      <link href="/leetcode/101/"/>
      <url>/leetcode/101/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-101-题：对称二叉树"><a href="#「力扣」第-101-题：对称二叉树" class="headerlink" title="「力扣」第 101 题：对称二叉树"></a>「力扣」第 101 题：对称二叉树</h2><ul><li><a href="https://leetcode.cn/problems/symmetric-tree/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/101/symtree1.jpg" style="width: 354px; height: 291px;"><strong>输入：</strong>root = [1,2,2,3,4,4,3]<strong>输出：</strong>true</pre><pre><strong>示例 2：</strong><img alt="" src="../../images/leetcode/101/symtree2.jpg" style="width: 308px; height: 258px;"><strong>输入：</strong>root = [1,2,2,null,3,null,3]<strong>输出：</strong>false</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li>树中节点数目在范围 <code>[1, 1000]</code> 内</li>    <li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p></p><p>&nbsp;</p><p><strong>进阶：</strong>你可以运用递归和迭代两种方法解决这个问题吗？</p><p>&nbsp;</p><p><strong>二叉树结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：深度优先搜索（推荐）"><a href="#参考代码：深度优先搜索（推荐）" class="headerlink" title="参考代码：深度优先搜索（推荐）"></a>参考代码：深度优先搜索（推荐）</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 树中节点数目在范围 [1, 1000] 内</span>        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 如果 p 与 q 都为 null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> q <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 如果一个为 null，另一个不为 null。或者，都非空但是结点值不一样</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> q <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">!=</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">,</span> q<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">dfs</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">,</span> q<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><h3 id="参考代码：广度优先搜索"><a href="#参考代码：广度优先搜索" class="headerlink" title="参考代码：广度优先搜索"></a>参考代码：广度优先搜索</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 树中节点数目在范围 [1, 1000] 内</span>        <span class="token keyword">return</span> <span class="token function">check</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 不能用 ArrayDeque，否则 offer(null) 会报错</span>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 每一轮比较一次左右子树对称位置的两个结点（出队列）</span>        <span class="token comment">// 并将比较的两个节点的左右孩子按照比较顺序依次入队列（入队列）</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 出队列，准备比较</span>            p <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果 p 与 q 都为 null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> q <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 如果一个为 null，另一个不为 null。或者，都非空但是结点值不一样</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> q <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">!=</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 入队列</span>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 98 题：验证二叉搜索树（中等）</title>
      <link href="/leetcode/98/"/>
      <url>/leetcode/98/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-98-题：验证二叉搜索树"><a href="#「力扣」第-98-题：验证二叉搜索树" class="headerlink" title="「力扣」第 98 题：验证二叉搜索树"></a>「力扣」第 98 题：验证二叉搜索树</h2><ul><li><a href="https://leetcode.cn/problems/validate-binary-search-tree/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/94/">「力扣」第 94 题：二叉树的中序遍历</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul>  <li>节点的左子树只包含<strong> 小于 </strong>当前节点的数。</li>  <li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>  <li>所有左子树和右子树自身必须也是二叉搜索树。</li> </ul><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/98/tree1.jpg" style="width: 302px; height: 182px;"> <strong>输入：</strong>root = [2,1,3]<strong>输出：</strong>true</pre><pre><strong>示例 2：</strong><img alt="" src="../../images/leetcode/98/tree2.jpg" style="width: 422px; height: 292px;"> <strong>输入：</strong>root = [5,1,4,null,null,3,6]<strong>输出：</strong>false<strong>解释：</strong>根节点的值是 5 ，但是右子节点的值是 4 。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li>树中节点数目范围在<code>[1, 10<sup>4</sup>]</code> 内</li>  <li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li> </ul><p></p><p>&nbsp;</p><p><strong>二叉树结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：深度优先搜索（推荐）"><a href="#参考代码：深度优先搜索（推荐）" class="headerlink" title="参考代码：深度优先搜索（推荐）"></a>参考代码：深度优先搜索（推荐）</h3><p>中序遍历升序排即可，可以定义一个 <code>pre</code> 表示当前结点的前驱结点。</p><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * -2^31 &lt;= Node.val &lt;= 2^31 - 1     */</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> pre <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 如果左子树不满足。或者，当前结点小于等于其前驱结点。均不满足 BST</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">||</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> pre<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pre <span class="token operator">=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token comment">// 访问右子树</span>        <span class="token keyword">return</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><h3 id="参考代码：栈"><a href="#参考代码：栈" class="headerlink" title="参考代码：栈"></a>参考代码：栈</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 因为： -2^31 &lt;= Node.val &lt;= 2^31 - 1</span>        <span class="token keyword">long</span> pre <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 访问当前结点：如果当前结点小于等于前驱结点，说明不满足 BST</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> pre<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            pre <span class="token operator">=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 96 题：不同的二叉搜索树（中等）</title>
      <link href="/leetcode/96/"/>
      <url>/leetcode/96/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-96-题：不同的二叉搜索树"><a href="#「力扣」第-96-题：不同的二叉搜索树" class="headerlink" title="「力扣」第 96 题：不同的二叉搜索树"></a>「力扣」第 96 题：不同的二叉搜索树</h2><ul><li><a href="https://leetcode.cn/problems/unique-binary-search-trees/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/96/uniquebstn3.jpg" style="width: 600px; height: 148px;"> <strong>输入：</strong>n = 3<strong>输出：</strong>5</pre><pre><strong>示例 2：</strong><strong>输入：</strong>n = 1<strong>输出：</strong>1</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= n &lt;= 19</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：卡塔兰数"><a href="#参考代码：卡塔兰数" class="headerlink" title="参考代码：卡塔兰数"></a>参考代码：卡塔兰数</h3><p>题目要求是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：</p><ul><li><code>C(n)</code>： 长度为 <code>n</code> 的序列能构成的不同二叉搜索树的个数。</li><li><code>F(i,n)</code>： 以 <code>i</code> 为根、序列长度为 <code>n</code> 的不同二叉搜索树个数 (<code>1≤i≤n</code>)。</li></ul><p><strong>卡塔兰数（一定要最后除以 <code>n+1</code> 以防止精度溢出）：</strong></p><p>$C(n) = \sum\limits_{i=1}^{n}F(i,n) = \sum\limits_{i=1}^{n}C(i-1) \cdot C(n-i) = \frac{C_{2n}^{n}}{n+1} = \frac{n+1}{1} \times\frac{n+2}{2} \times \cdots \times \frac{n+n}{n} \times \frac{1}{n+1}$</p><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 需要使用 long 类型防止计算过程中的溢出</span>        <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// res 为 n + i 个不同元素中选 i 个的组合数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">=</span> res <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">/</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>res <span class="token operator">/</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卡塔兰数 </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 94 题：二叉树的中序遍历（简单）</title>
      <link href="/leetcode/94/"/>
      <url>/leetcode/94/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-94-题：二叉树的中序遍历"><a href="#「力扣」第-94-题：二叉树的中序遍历" class="headerlink" title="「力扣」第 94 题：二叉树的中序遍历"></a>「力扣」第 94 题：二叉树的中序遍历</h2><ul><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/98/">「力扣」第 98 题：验证二叉搜索树</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong>&nbsp;遍历。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/94/inorder_1.jpg" style="height: 200px; width: 125px;"><strong>输入：</strong>root = [1,null,2,3]<strong>输出：</strong>[1,3,2]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>root = []<strong>输出：</strong>[]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>root = [1]<strong>输出：</strong>[1]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li>树中节点数目在范围 <code>[0, 100]</code> 内</li>    <li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p></p><p>&nbsp;</p><p><strong>进阶:</strong>&nbsp;递归算法很简单，你可以通过迭代算法完成吗？</p><p>&nbsp;</p><p><strong>二叉树结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：深度优先搜索"><a href="#参考代码：深度优先搜索" class="headerlink" title="参考代码：深度优先搜索"></a>参考代码：深度优先搜索</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 中序遍历：左 -&gt; 根 -&gt; 右</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><h3 id="参考代码：栈"><a href="#参考代码：栈" class="headerlink" title="参考代码：栈"></a>参考代码：栈</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><h3 id="参考代码：Morris-遍历"><a href="#参考代码：Morris-遍历" class="headerlink" title="参考代码：Morris 遍历"></a>参考代码：Morris 遍历</h3><p><strong>当前结点的前驱结点的右指针指向当前节点</strong></p><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// pre：当前结点的前驱结点</span>                <span class="token class-name">TreeNode</span> pre <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> pre<span class="token punctuation">.</span>right <span class="token operator">!=</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 第一次来到 pre 结点，右指针指向当前结点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    pre<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">;</span>                    root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment">// 第二次来到 pre 节点，断开右指针对当前结点的指向</span>                    pre<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 栈 </tag>
            
            <tag> Morris 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 85 题：最大矩形（困难）</title>
      <link href="/leetcode/85/"/>
      <url>/leetcode/85/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-85-题：最大矩形"><a href="#「力扣」第-85-题：最大矩形" class="headerlink" title="「力扣」第 85 题：最大矩形"></a>「力扣」第 85 题：最大矩形</h2><ul><li><a href="https://leetcode.cn/problems/maximal-rectangle/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/84/">「力扣」第 84 题：柱状图中最大的矩形</a></li><li><a href="https://iiifox.github.io/leetcode/221/">「力扣」第 221 题：最大正方形</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个仅包含&nbsp;<code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/85/maximal.jpg" style="width: 402px; height: 322px;"> <strong>输入：</strong>matrix = [    ["1","0","1","0","0"],    ["1","0","1","1","1"],    ["1","1","1","1","1"],    ["1","0","0","1","0"]]<strong>输出：</strong>6<strong>解释：</strong>最大矩形如上图所示。</pre><pre><strong>示例 2：</strong><strong>输入：</strong>matrix = []<strong>输出：</strong>0</pre><pre><strong>示例 3：</strong><strong>输入：</strong>matrix = [["0"]]<strong>输出：</strong>0</pre><pre><strong>示例 4：</strong><strong>输入：</strong>matrix = [["1"]]<strong>输出：</strong>1</pre><pre><strong>示例 5：</strong><strong>输入：</strong>matrix = [["0","0"]]<strong>输出：</strong>0</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>rows == matrix.length</code></li>  <li><code>cols == matrix[0].length</code></li>  <li><code>1 &lt;= row, cols &lt;= 200</code></li>  <li><code>matrix[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：单调栈"><a href="#参考代码：单调栈" class="headerlink" title="参考代码：单调栈"></a>参考代码：单调栈</h3><p><strong><font color="red">观察下图，可以按行划分，即可转化为第 84 题</font></strong></p><p><img src="../../images/leetcode/85/%E9%A2%98%E8%A7%A3.png"></p><blockquote><p>时间复杂度：$O(mn)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maximalRectangle</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 遍历每一列，更新高度。转化为第 84 题</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    heights<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    heights<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">// 「力扣」第 84 题：柱状图中最大的矩形</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 单调栈，存储数组的索引。其索引对应的元素值在栈中从下至上严格递增</span>        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 「哨兵」，无限低的柱子。</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 栈非空并且栈顶元素大于(等于)当前元素，说明需要弹出栈顶元素</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> heights<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// index 位置右边柱子严格低于该位置柱子的最近位置是 i；</span>                <span class="token comment">// 左边柱子严格低于该位置柱子的最近位置是出栈后栈顶元素(注意哨兵-1)</span>                <span class="token keyword">int</span> index <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> heights<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 栈中还有元素。这些位置右边均不存在低于自身柱高的柱子</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> heights<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 84 题：柱状图中最大的矩形（困难）</title>
      <link href="/leetcode/84/"/>
      <url>/leetcode/84/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-84-题：柱状图中最大的矩形"><a href="#「力扣」第-84-题：柱状图中最大的矩形" class="headerlink" title="「力扣」第 84 题：柱状图中最大的矩形"></a>「力扣」第 84 题：柱状图中最大的矩形</h2><ul><li><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/85/">「力扣」第 85 题：最大矩形</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p>&nbsp;</p><pre><strong>示例 1:</strong><img src="../../images/leetcode/84/histogram.jpg"><strong>输入：</strong>heights = [2,1,5,6,2,3]<strong>输出：</strong>10<strong>解释：</strong>最大的矩形为图中红色区域，面积为 10</pre><pre><strong>示例 2：</strong><img src="../../images/leetcode/84/histogram-1.jpg"><strong>输入：</strong> heights = [2,4]<b>输出：</b> 4</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= heights.length &lt;=10<sup>5</sup></code></li>  <li><code>0 &lt;= heights[i] &lt;= 10<sup>4</sup></code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：单调栈"><a href="#参考代码：单调栈" class="headerlink" title="参考代码：单调栈"></a>参考代码：单调栈</h3><p><strong><font color="red">我们归纳一下枚举「高」的方法：</font></strong></p><ul><li><p>首先我们枚举某一根柱子 <code>i</code> 作为高 <code>h = heights[i]</code> ；</p></li><li><p>随后我们需要进行向左右两边扩展，使得扩展到的柱子的高度均不小于 <code>h</code> 。换句话说，我们需要找到左右两侧最近的高度小于 <code>h</code> 的柱子，这样这两根柱子之间（不包括其本身）的所有柱子高度均不小于 <code>h</code> ，并且就是 <code>i</code> 能够扩展到的最远范围。</p></li></ul><p><strong>在一维数组中对每一个数找到<strong><font color="gree">（左边、右边）</font></strong>第一个比自己小的元素。这类“在一维数组中找第一个满足某种条件的数”的场景就是典型的单调栈应用场景。</strong></p><hr><p><strong><font color="blue">一个小细节的说明：</font></strong></p><ul><li>常规单调栈处理的是 <strong>无重复元素</strong> 的数组，对于有重复元素的处理我们需要将栈的泛型设置为一个 <code>List</code> </li></ul><p>对于本题，我们需要的是 <strong>计算矩形的最大面积</strong> ，而不需要准确的知道每一根柱子左右扩散能达到的最远范围。</p><p><strong><font color="purple">注意到这一点，我们能发现：</font></strong> 当我们对当前柱子 <code>i</code> 向右扩展，如果遇到与当前柱子高度一样的柱子 <code>j1、j2、j3...jk</code> 。这个时候柱子 <code>j1、j2、j3...、jk</code> 左右扩展对应的最大矩形面积和柱子 <code>i</code> 其实是一样的。因此，我们只需要这 <code>k + 1</code> 根柱子中有一根扩展的最大矩形面积是真实的（ <strong>其他的可以更小，但是不能更大</strong> ）。</p><p>为此，我们将常规的弹栈条件设置为 <code>heights[stack.peek()] &gt;= heights[i]</code> ，针对于相等的 <code>k + 1</code> 根柱子来说，它们的左边界都真实的确定了，其中最后一根柱子 <code>jk</code> 的右边界也真实的确定了（ <strong>其他的 <code>k</code> 根计算小了</strong> ）。</p><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 单调栈，存储数组的索引。其索引对应的元素值在栈中从下至上严格递增</span>        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 「哨兵」，无限低的柱子。</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 栈非空并且栈顶元素大于(等于)当前元素，说明需要弹出栈顶元素</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> heights<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// index 位置右边柱子严格低于该位置柱子的最近位置是 i；</span>                <span class="token comment">// 左边柱子严格低于该位置柱子的最近位置是出栈后栈顶元素(注意哨兵-1)</span>                <span class="token keyword">int</span> index <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> heights<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 栈中还有元素。这些位置右边均不存在低于自身柱高的柱子</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> heights<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 79 题：单词搜索（中等）</title>
      <link href="/leetcode/79/"/>
      <url>/leetcode/79/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-79-题：单词搜索（中等）"><a href="#「力扣」第-79-题：单词搜索（中等）" class="headerlink" title="「力扣」第 79 题：单词搜索（中等）"></a>「力扣」第 79 题：单词搜索（中等）</h2><ul><li><a href="https://leetcode.cn/problems/word-search/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/200/">「力扣」第 200 题：岛屿数量</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个&nbsp;<code>m x n</code> 二维字符网格&nbsp;<code>board</code> 和一个字符串单词&nbsp;<code>word</code> 。如果&nbsp;<code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/79/word1.jpg" style="width: 322px; height: 242px;"> <strong>输入：</strong>board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"<strong>输出：</strong>true</pre><pre><strong>示例 2：</strong><img alt="" src="../../images/leetcode/79/word2.jpg" style="width: 322px; height: 242px;"> <strong>输入：</strong>board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"<strong>输出：</strong>true</pre><pre><strong>示例 3：</strong><img alt="" src="../../images/leetcode/79/word3.jpg" style="width: 322px; height: 242px;"> <strong>输入：</strong>board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"<strong>输出：</strong>false</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>m == board.length</code></li>  <li><code>n = board[i].length</code></li>  <li><code>1 &lt;= m, n &lt;= 6</code></li>  <li><code>1 &lt;= word.length &lt;= 15</code></li>  <li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li> </ul><p></p><p>&nbsp;</p><p><strong>进阶：</strong>你可以使用搜索剪枝的技术来优化解决方案，使其在 <code>board</code> 更大的情况下可以更快解决问题？</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：回溯"><a href="#参考代码：回溯" class="headerlink" title="参考代码：回溯"></a>参考代码：回溯</h3><blockquote><p>时间复杂度：$mn \times 3^L$    <code>L 为字符串 word 的长度</code></p><p>空间复杂度：$O(mn)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">exist</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> <span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1 &lt;= m, n &lt;= 6</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> board<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 初始化为 false 表示所有数都还没有使用</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> wordArray <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">backtrack</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> used<span class="token punctuation">,</span> wordArray<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used<span class="token punctuation">,</span>                              <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 如果超出区域。或者当前字符已经使用过了。或者与应该匹配的 chars 位置字符不一致</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isArea</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">||</span> used<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">||</span> board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">!=</span> chars<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 最后一个字符也匹配成功。递归终止。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">==</span> chars<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 当前位置的字符设置为已经使用过</span>        used<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// 尝试选择下一个方向</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">backtrack</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> used<span class="token punctuation">,</span> chars<span class="token punctuation">,</span> x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">,</span> begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token operator">||</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> used<span class="token punctuation">,</span> chars<span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">,</span> begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token operator">||</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> used<span class="token punctuation">,</span> chars<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token operator">||</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> used<span class="token punctuation">,</span> chars<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// 回溯。状态重置</span>            used<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isArea</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> board<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>y <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 78 题：子集（中等）</title>
      <link href="/leetcode/78/"/>
      <url>/leetcode/78/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-78-题：子集"><a href="#「力扣」第-78-题：子集" class="headerlink" title="「力扣」第 78 题：子集"></a>「力扣」第 78 题：子集</h2><p><a href="https://leetcode.cn/problems/subsets/">链接</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组&nbsp;<code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [1,2,3]<strong>输出：</strong>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums = [0]<strong>输出：</strong>[[],[0]]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= nums.length &lt;= 10</code></li>  <li><code>-10 &lt;= nums[i] &lt;= 10</code></li>  <li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：回溯"><a href="#参考代码：回溯" class="headerlink" title="参考代码：回溯"></a>参考代码：回溯</h3><blockquote><p>时间复杂度：$O(2^n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">subsets</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">backtrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span>                           <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> path<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 每一轮开始，就将其添加到结果集</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 选择 nums[i]</span>            path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">backtrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 回溯：状态重置。不选择 nums[i]</span>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 76 题：最小覆盖子串（困难）</title>
      <link href="/leetcode/76/"/>
      <url>/leetcode/76/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-76-题：最小覆盖子串"><a href="#「力扣」第-76-题：最小覆盖子串" class="headerlink" title="「力扣」第 76 题：最小覆盖子串"></a>「力扣」第 76 题：最小覆盖子串</h2><ul><li><a href="https://leetcode.cn/problems/minimum-window-substring/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/438/">「力扣」第 438 题：找到字符串中所有字母异位词</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>""</code> 。</p><p>&nbsp;</p><p><strong>注意：</strong></p><ul>  <li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>  <li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li> </ul><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>s = "ADOBECODEBANC", t = "ABC"<strong>输出：</strong>"BANC"</pre><pre><strong>示例 2：</strong><strong>输入：</strong>s = "a", t = "a"<strong>输出：</strong>"a"</pre><pre><strong>示例 3:</strong><strong>输入:</strong> s = "a", t = "aa"<strong>输出:</strong> ""<strong>解释:</strong> t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>  <li><code>s</code> 和 <code>t</code> 由英文字母组成</li> </ul><p></p><p>&nbsp;</p> <p><strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p><p>&nbsp;</p> <p>&nbsp;</p> <h3 id="参考代码：滑动窗口"><a href="#参考代码：滑动窗口" class="headerlink" title="参考代码：滑动窗口"></a>参考代码：滑动窗口</h3><p>1、一开始的时候，<code>left</code> 和 <code>right</code> 都位于 0 的位置，<code>right</code> 向右移动，直至包含 <code>t</code> 的所有字符。因为我们要求的是最小子串，因此，以 <code>left</code> 开头的子串 <code>[left, right + 1]</code>、 <code>[left, right + 2]</code>、……、 <code>[left, len - 1]</code> 一定不符合要求。因此可以不用判断。</p><p>2、然后考虑 <code>left</code> 如何移动，<code>left</code> 不能向左移动，向左移动只能让子串更长，我们要求最小子串，因此  <code>left</code> 只能右移，移到 <code>left</code> 滑出以后，恰恰好 <code>[left, right]</code> 这个区间里面的字符不包含 <code>t</code> 所有字符。</p><p>3、然后 <code>right</code> 继续向右移动，直到包含 <code>t</code> 所有字符的最小子串。</p><p>4、重复上述过程，直到 <code>right</code> 到达 <code>s</code> 的末尾。</p><blockquote><p>时间复杂度：$O(m+n+58)$</p><p>空间复杂度：$O(m+n+58)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">minWindow</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">String</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// s 和 t 由英文字母组成，'A' = 65 'z' = 122</span>        <span class="token comment">// 窗口数组，统计当前窗口内 t 中存在的字符出现的次数</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> window <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">58</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 统计字符串 t 中每个字符出现的次数</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pattern <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">58</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> t<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pattern<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 统计字符串 t 中不同字符数。differ 记录窗口内未完全匹配的字符数</span>        <span class="token keyword">int</span> differ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                differ<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minLen <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> right <span class="token operator">&lt;</span> chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span> right<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> curChar <span class="token operator">=</span> chars<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 该字符在 t 中是存在的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pattern<span class="token punctuation">[</span>curChar <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                window<span class="token punctuation">[</span>curChar <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token comment">// 窗口内该字符出现的次数等于 t 中该字符的次数了</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">[</span>curChar <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>curChar <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    differ<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">// 当前窗口内已经涵盖 t 所有字符，此时左指针可以考虑右移了</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>differ <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 判断是否是一个满足条件的更小的子串</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> minLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    start <span class="token operator">=</span> left<span class="token punctuation">;</span>                    minLen <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 考虑左边界向右边走</span>                <span class="token keyword">char</span> leftChar <span class="token operator">=</span> chars<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// 即将出窗口的字符在 t 中是存在的</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pattern<span class="token punctuation">[</span>leftChar <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    window<span class="token punctuation">[</span>leftChar <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token comment">// 窗口内 leftChar 字符数已经少于 t 中的 leftChar 字符数了</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">[</span>leftChar <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> pattern<span class="token punctuation">[</span>leftChar <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        differ<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>minLen <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">""</span>                 <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> start <span class="token operator">+</span> minLen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 75 题：颜色分类（中等）</title>
      <link href="/leetcode/75/"/>
      <url>/leetcode/75/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-75-题：颜色分类"><a href="#「力扣」第-75-题：颜色分类" class="headerlink" title="「力扣」第 75 题：颜色分类"></a>「力扣」第 75 题：颜色分类</h2><ul><li><a href="https://leetcode.cn/problems/sort-colors/">链接</a></li></ul><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个包含红色、白色和蓝色、共&nbsp;<code>n</code><em> </em>个元素的数组 <meta charset="UTF-8">&nbsp;<code>nums</code>&nbsp;，<strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 <code>0</code>、&nbsp;<code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p><p>必须在不使用库的sort函数的情况下解决这个问题。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [2,0,2,1,1,0]<strong>输出：</strong>[0,0,1,1,2,2]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums = [2,0,1]<strong>输出：</strong>[0,1,2]</pre><p>&nbsp;</p><p> <strong>提示：</strong></p><ul> <li><code>n == nums.length</code></li>  <li><code>1 &lt;= n &lt;= 300</code></li>  <li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li> </ul><p></p><p>&nbsp;</p><p><strong>进阶：</strong></p><ul>  <li>你可以不使用代码库中的排序函数来解决这道题吗？</li>  <li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：左右指针"><a href="#参考代码：左右指针" class="headerlink" title="参考代码：左右指针"></a>参考代码：左右指针</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sortColors</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 「荷兰国旗问题」：本题我们需要选取的 pivot = 1</span>        <span class="token keyword">int</span> lt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> gt <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// nums[0, lt) == 0</span>        <span class="token comment">// nums[lt, i) == 1</span>        <span class="token comment">// nums(gt, n-1] == 2</span>        label<span class="token operator">:</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> lt<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> gt<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 如果 nums[i] &gt; 1，则交换至使 i 位置数 &lt;= 1</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> gt<span class="token punctuation">)</span><span class="token punctuation">;</span>                gt<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> gt<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span> label<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">// nums[i] == 0</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lt<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                lt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 72 题：编辑距离（困难）</title>
      <link href="/leetcode/72/"/>
      <url>/leetcode/72/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-72-题：编辑距离"><a href="#「力扣」第-72-题：编辑距离" class="headerlink" title="「力扣」第 72 题：编辑距离"></a>「力扣」第 72 题：编辑距离</h2><ul><li><a href="https://leetcode.cn/problems/edit-distance/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个单词&nbsp;<code>word1</code> 和&nbsp;<code>word2</code>，请返回将&nbsp;<code>word1</code>&nbsp;转换成&nbsp;<code>word2</code> 所使用的最少操作数&nbsp;。</p><p>你可以对一个单词进行如下三种操作：</p><ul>  <li>插入一个字符</li>  <li>删除一个字符</li>  <li>替换一个字符</li> </ul><p>&nbsp;</p><pre><strong>示例&nbsp;1：</strong><strong>输入：</strong>word1 = "horse", word2 = "ros"<strong>输出：</strong>3<strong>解释：</strong>horse -&gt; rorse (将 'h' 替换为 'r')rorse -&gt; rose (删除 'r')rose -&gt; ros (删除 'e')</pre><pre><strong>示例&nbsp;2：</strong><strong>输入：</strong>word1 = "intention", word2 = "execution"<strong>输出：</strong>5<strong>解释：</strong>intention -&gt; inention (删除 't')inention -&gt; enention (将 'i' 替换为 'e')enention -&gt; exention (将 'n' 替换为 'x')exention -&gt; exection (将 'n' 替换为 'c')exection -&gt; execution (插入 'u')</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>  <li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：动态规划"><a href="#参考代码：动态规划" class="headerlink" title="参考代码：动态规划"></a>参考代码：动态规划</h3><blockquote><p>时间复杂度：$O(mn)$</p><p>空间复杂度：$O(mn)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDistance</span><span class="token punctuation">(</span><span class="token class-name">String</span> word1<span class="token punctuation">,</span> <span class="token class-name">String</span> word2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> word1Array <span class="token operator">=</span> word1<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> word2Array <span class="token operator">=</span> word2<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len1 <span class="token operator">=</span> word1Array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> len2 <span class="token operator">=</span> word2Array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// dp[i][j] 表示将 word1[0, i) 转换成为 word2[0, j) 的方案数</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 当 word2 长度为 0 时，就删除所有 word1 的字符</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 当 word1 长度为 0 时，就插入所有 word2 的字符</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> len2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>word1Array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> word2Array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 1、在下标 i 处插入一个字符</span>                <span class="token keyword">int</span> insert <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// 2、将下标 i 处字符删除</span>                <span class="token keyword">int</span> delete <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// 3、将下标 i 处字符替换</span>                <span class="token keyword">int</span> replace <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// 在以上三种情况中选出步骤最少的</span>                dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>insert<span class="token punctuation">,</span> delete<span class="token punctuation">)</span><span class="token punctuation">,</span> replace<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len1<span class="token punctuation">]</span><span class="token punctuation">[</span>len2<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 70 题：爬楼梯（简单）</title>
      <link href="/leetcode/70/"/>
      <url>/leetcode/70/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-70-题：爬楼梯"><a href="#「力扣」第-70-题：爬楼梯" class="headerlink" title="「力扣」第 70 题：爬楼梯"></a>「力扣」第 70 题：爬楼梯</h2><ul><li><a href="https://leetcode.cn/problems/climbing-stairs/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设你正在爬楼梯。需要 <code>n</code>&nbsp;阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>n = 2<strong>输出：</strong>2<strong>解释：</strong>有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶</pre><pre><strong>示例 2：</strong><strong>输入：</strong>n = 3<strong>输出：</strong>3<strong>解释：</strong>有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= n &lt;= 45</code></li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：数学"><a href="#参考代码：数学" class="headerlink" title="参考代码：数学"></a>参考代码：数学</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> sqrt5 <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 用浮点数计算来实现，可能会产生精度误差。</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> sqrt5<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span>                <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> sqrt5<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> sqrt5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 64 题：最小路径和（中等）</title>
      <link href="/leetcode/64/"/>
      <url>/leetcode/64/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-64-题：最小路径和"><a href="#「力扣」第-64-题：最小路径和" class="headerlink" title="「力扣」第 64 题：最小路径和"></a>「力扣」第 64 题：最小路径和</h2><ul><li><a href="https://leetcode.cn/problems/minimum-path-sum/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/62/">「力扣」第 62 题：不同路径</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含非负整数的 <code><em>m</em>&nbsp;x&nbsp;<em>n</em></code>&nbsp;网格&nbsp;<code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/64/minpath.jpg" style="width: 242px; height: 242px;"><strong>输入：</strong>grid = [[1,3,1],[1,5,1],[4,2,1]]<strong>输出：</strong>7<strong>解释：</strong>因为路径 1→3→1→1→1 的总和最小。</pre><pre><strong>示例 2：</strong><strong>输入：</strong>grid = [[1,2,3],[4,5,6]]<strong>输出：</strong>12</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>m == grid.length</code></li>    <li><code>n == grid[i].length</code></li>    <li><code>1 &lt;= m, n &lt;= 200</code></li>    <li><code>0 &lt;= grid[i][j] &lt;= 100</code></li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：动态规划"><a href="#参考代码：动态规划" class="headerlink" title="参考代码：动态规划"></a>参考代码：动态规划</h3><blockquote><p>时间复杂度：$O(mn)$</p><p>空间复杂度：$O(mn)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 也可以直接在原数组上操作，但是实际开发中不要破坏原数组数据</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 网格的第一行的每个元素只能从左上角元素开始向右移动到达</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 网格的第一列的每个元素只能从左上角元素开始向下移动到达</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment">// 对于不在第一行和第一列的元素：</span>        <span class="token comment">// dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 62 题：不同路径（中等）</title>
      <link href="/leetcode/62/"/>
      <url>/leetcode/62/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-62-题：不同路径"><a href="#「力扣」第-62-题：不同路径" class="headerlink" title="「力扣」第 62 题：不同路径"></a>「力扣」第 62 题：不同路径</h2><ul><li><a href="https://leetcode.cn/problems/unique-paths/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/64/">「力扣」第 64 题：最小路径和</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个机器人位于一个 <code>m x n</code><em>&nbsp;</em>网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img src="../../images/leetcode/62/robot_maze.png"><strong>输入：</strong>m = 3, n = 7<strong>输出：</strong>28</pre><pre><strong>示例 2：</strong><strong>输入：</strong>m = 3, n = 2<strong>输出：</strong>3<strong>解释：</strong>从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向下</pre><pre><strong>示例 3：</strong><strong>输入：</strong>m = 7, n = 3<strong>输出：</strong>28</pre><pre><strong>示例 4：</strong><strong>输入：</strong>m = 3, n = 3<strong>输出：</strong>6</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= m, n &lt;= 100</code></li>    <li>题目数据保证答案小于等于 <code>2 * 10<sup>9</sup></code></li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：组合数学"><a href="#参考代码：组合数学" class="headerlink" title="参考代码：组合数学"></a>参考代码：组合数学</h3><p>$C_{m+n-2}^{m-1} = {m+n-2 \choose m-1} = \frac {(m+n-2)!} {(m-1)!(n-1)!} = \frac{n-1+1}{1} \times \frac{n-1+2}{2} \times \cdots \times \frac{n-1+m-1}{m-1}$</p><blockquote><p>时间复杂度：$O(min(m,n))$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 题目数据保证答案小于等于 20 亿，但是最后一步是除法，可能会越界</span>        <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 让循环次数更少，我们始终让 m 不大于 n</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">&gt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> m<span class="token punctuation">;</span>            m <span class="token operator">=</span> n<span class="token punctuation">;</span>            n <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment">// res 为 n - 1 + i 个不同元素中选 i 个的组合数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 注意不要写成 *=</span>            res <span class="token operator">=</span> res <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">/</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 56 题：合并区间（中等）</title>
      <link href="/leetcode/56/"/>
      <url>/leetcode/56/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-56-题：合并区间"><a href="#「力扣」第-56-题：合并区间" class="headerlink" title="「力扣」第 56 题：合并区间"></a>「力扣」第 56 题：合并区间</h2><ul><li><a href="https://leetcode.cn/problems/merge-intervals/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>intervals = [[1,3],[2,6],[8,10],[15,18]]<strong>输出：</strong>[[1,6],[8,10],[15,18]]<strong>解释：</strong>区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</pre><pre><strong>示例&nbsp;2：</strong><strong>输入：</strong>intervals = [[1,4],[4,5]]<strong>输出：</strong>[[1,5]]<strong>解释：</strong>区间 [1,4] 和 [4,5] 可被视为重叠区间。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>  <li><code>intervals[i].length == 2</code></li>  <li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>4</sup></code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：排序"><a href="#参考代码：排序" class="headerlink" title="参考代码：排序"></a>参考代码：排序</h3><blockquote><p>时间复杂度：$O(nlogn)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 先按照区间起始位置排序</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> v1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> v2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> merged <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> interval <span class="token operator">:</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> interval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> interval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 如果结果数组是空的，或者结果数组中最后区间的终止位置 &lt; 当前区间的起始位置</span>            <span class="token comment">// 则不合并，直接将当前区间加入结果数组</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>merged<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> merged<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>merged<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> left<span class="token punctuation">)</span> <span class="token punctuation">{</span>                merged<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>left<span class="token punctuation">,</span> right<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">// 反之将当前区间合并至数组的最后区间</span>                merged<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>merged<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span>                     <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>merged<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>merged<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> merged<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>merged<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 55 题：跳跃游戏（中等）</title>
      <link href="/leetcode/55/"/>
      <url>/leetcode/55/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-55-题：跳跃游戏"><a href="#「力扣」第-55-题：跳跃游戏" class="headerlink" title="「力扣」第 55 题：跳跃游戏"></a>「力扣」第 55 题：跳跃游戏</h2><ul><li><a href="https://leetcode.cn/problems/jump-game/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个非负整数数组&nbsp;<code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p>&nbsp;</p><pre><strong>示例&nbsp;1：</strong><strong>输入：</strong>nums = [2,3,1,1,4]<strong>输出：</strong>true<strong>解释：</strong>可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</pre><pre><strong>示例&nbsp;2：</strong><strong>输入：</strong>nums = [3,2,1,0,4]<strong>输出：</strong>false<strong>解释：</strong>无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>  <li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：贪心"><a href="#参考代码：贪心" class="headerlink" title="参考代码：贪心"></a>参考代码：贪心</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canJump</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// [0, i) 里能达到的最远下标</span>        <span class="token keyword">int</span> rightMost <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 注意 [0] 这一个特殊测试用例，条件不应写成 n &lt; nums.length - 1</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 该位置是可达的，尝试更新最远下标</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> rightMost<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rightMost <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>rightMost<span class="token punctuation">,</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 最远能够到达最后一个下标</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rightMost <span class="token operator">&gt;=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">// 可以直接返回 false 了。因为最远仅能到达上一个下标 i - 1</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Can jump exception"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 53 题：最大子数组和（简单）</title>
      <link href="/leetcode/53/"/>
      <url>/leetcode/53/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-53-题：最大子数组和"><a href="#「力扣」第-53-题：最大子数组和" class="headerlink" title="「力扣」第 53 题：最大子数组和"></a>「力扣」第 53 题：最大子数组和</h2><ul><li><p><a href="https://leetcode.cn/problems/maximum-subarray/">链接</a></p></li><li><p><a href="https://iiifox.github.io/leetcode/121/">「力扣」第 121 题： 买卖股票的最佳时机</a></p></li><li><p><a href="https://iiifox.github.io/leetcode/152/">「力扣」第 152 题：乘积最大子数组</a></p></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组 </strong>是数组中的一个连续部分。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [-2,1,-3,4,-1,2,1,-5,4]<strong>输出：</strong>6<strong>解释：</strong>连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6 。</pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums = [1]<strong>输出：</strong>1</pre><pre><strong>示例 3：</strong><strong>输入：</strong>nums = [5,4,-1,7,8]<strong>输出：</strong>23</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>    <li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li></ul><p></p><p>&nbsp;</p><p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：动态规划（推荐）"><a href="#参考代码：动态规划（推荐）" class="headerlink" title="参考代码：动态规划（推荐）"></a>参考代码：动态规划（推荐）</h3><p><code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的「连续子数组的最大和」<strong><font color="blue">（连续子数组的最后一个位置是 <code>i</code> ）</font></strong></p><p><strong>动态规划转移方程：</strong></p><ul><li><code>dp[i] = max{dp[i−1]+nums[i], nums[i]}</code></li></ul><p>考虑到 <code>dp[i]</code> 只和 <code>dp[i-1]</code> 相关，于是我们可以只用一个变量 <code>pre</code> 来维护对于当前 <code>dp[i]</code> 的 <code>dp[i-1]</code> 的值是多少，从而让空间复杂度降低到 $O(1)$ ，这有点类似「滚动数组」的思想。</p><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            pre <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>pre <span class="token operator">+</span> num<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> pre<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><h3 id="参考代码：分治"><a href="#参考代码：分治" class="headerlink" title="参考代码：分治"></a>参考代码：分治</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(logn)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">maxSubArraySum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">maxSubArraySum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 左半部分最大子数组和</span>        <span class="token keyword">int</span> leftSum <span class="token operator">=</span> <span class="token function">maxSubArraySum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 横跨左右边界的最大子数组和</span>        <span class="token keyword">int</span> crossingSum <span class="token operator">=</span> <span class="token function">maxCrossingSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 右半部分最大子数组和</span>        <span class="token keyword">int</span> rightSum <span class="token operator">=</span> <span class="token function">maxSubArraySum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>crossingSum<span class="token punctuation">,</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftSum<span class="token punctuation">,</span> rightSum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">maxCrossingSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 计算左边以 mid 结尾的最大子数组和</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> leftSum <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> mid<span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> left<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;</span> leftSum<span class="token punctuation">)</span> <span class="token punctuation">{</span>                leftSum <span class="token operator">=</span> sum<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">// 计算右边以 mid + 1 开始的最大子数组和</span>        sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rightSum <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;</span> rightSum<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rightSum <span class="token operator">=</span> sum<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> leftSum <span class="token operator">+</span> rightSum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 49 题：字母异位词分组（中等）</title>
      <link href="/leetcode/49/"/>
      <url>/leetcode/49/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-49-题：字母异位词分组"><a href="#「力扣」第-49-题：字母异位词分组" class="headerlink" title="「力扣」第 49 题：字母异位词分组"></a>「力扣」第 49 题：字母异位词分组</h2><ul><li><a href="https://leetcode.cn/problems/group-anagrams/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p>&nbsp;</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> strs = <span>["eat", "tea", "tan", "ate", "nat", "bat"]</span><strong>输出: </strong>[["bat"],["nat","tan"],["ate","eat","tea"]]</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> strs = <span>[""]</span><strong>输出: </strong>[[""]]</pre><p><strong>示例 3:</strong></p><pre><strong>输入:</strong> strs = <span>["a"]</span><strong>输出: </strong>[["a"]]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= strs.length &lt;= 10<sup>4</sup></code></li>  <li><code>0 &lt;= strs[i].length &lt;= 100</code></li>  <li><code>strs[i]</code>&nbsp;仅包含小写字母</li> </ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：计数排序"><a href="#参考代码：计数排序" class="headerlink" title="参考代码：计数排序"></a>参考代码：计数排序</h3><p><code>n</code> 是 <code>strs</code> 中的字符串的数量，<code>k</code> 是 <code>strs</code> 中的字符串的的最大长度</p><blockquote><p>时间复杂度：$O(n \times (k + 26))$</p><p>空间复杂度：$O(n \times (k + 26))$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> str <span class="token operator">:</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// strs[i] 仅包含小写字母</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> counts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> str<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                counts<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键</span>            <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> counts<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>counts<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token char">'a'</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>counts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">// StringBuilder 没有重写 Object 中的 hashCode 和 equals 方法，不能作键</span>            <span class="token class-name">String</span> key <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 需要再添加一次，因为该键返回的可能是默认值（即第一次添加）</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 48 题：旋转图像（中等）</title>
      <link href="/leetcode/48/"/>
      <url>/leetcode/48/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-48-题：旋转图像"><a href="#「力扣」第-48-题：旋转图像" class="headerlink" title="「力扣」第 48 题：旋转图像"></a>「力扣」第 48 题：旋转图像</h2><ul><li><a href="https://leetcode.cn/problems/rotate-image/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 <em>n&nbsp;</em>×&nbsp;<em>n</em> 的二维矩阵&nbsp;<code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在<strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank"> 原地</a></strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要 </strong>使用另一个矩阵来旋转图像。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/48/mat1.jpg" style="height: 188px; width: 500px;"> <strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]<strong>输出：</strong>[[7,4,1],[8,5,2],[9,6,3]]</pre><pre><strong>示例 2：</strong><img alt="" src="../../images/leetcode/48/mat2.jpg" style="height: 201px; width: 500px;"> <strong>输入：</strong>matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<strong>输出：</strong>[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>n == matrix.length == matrix[i].length</code></li>  <li><code>1 &lt;= n &lt;= 20</code></li>  <li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：矩阵"><a href="#参考代码：矩阵" class="headerlink" title="参考代码：矩阵"></a>参考代码：矩阵</h3><blockquote><p>时间复杂度：$O(n^2)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>n <span class="token operator">-</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>n <span class="token operator">-</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 46 题：全排列（中等）</title>
      <link href="/leetcode/46/"/>
      <url>/leetcode/46/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-46-题：全排列"><a href="#「力扣」第-46-题：全排列" class="headerlink" title="「力扣」第 46 题：全排列"></a>「力扣」第 46 题：全排列</h2><ul><li><a href="https://leetcode.cn/problems/permutations/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其所有可能的全排列。你可以 <strong>按任意顺序</strong> 返回答案。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [1,2,3]<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums = [0,1]<strong>输出：</strong>[[0,1],[1,0]]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>nums = [1]<strong>输出：</strong>[[1]]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= nums.length &lt;= 6</code></li>  <li><code>-10 &lt;= nums[i] &lt;= 10</code></li>  <li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：回溯"><a href="#参考代码：回溯" class="headerlink" title="参考代码：回溯"></a>参考代码：回溯</h3><blockquote><p>时间复杂度：$O(n \times n!)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">permute</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 初始化的时候都为 false 表示这些数还没有被选择</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">backtrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> used<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">,</span>                           <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> path<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 剪枝：该数没有被使用过才能考虑添加</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>used<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token function">backtrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> used<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 回溯：状态重置</span>                used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 42 题：接雨水（困难）</title>
      <link href="/leetcode/42/"/>
      <url>/leetcode/42/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-42-题：接雨水"><a href="#「力扣」第-42-题：接雨水" class="headerlink" title="「力扣」第 42 题：接雨水"></a>「力扣」第 42 题：接雨水</h2><ul><li><a href="https://leetcode.cn/problems/trapping-rain-water/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/11/">「力扣」第 11 题：盛最多水的容器</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定&nbsp;<code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img src="../../images/leetcode/42/rainwatertrap.png" style="height: 161px; width: 412px;"><strong>输入：</strong>height = [0,1,0,2,1,0,1,3,2,1,2,1]<strong>输出：</strong>6<strong>解释：</strong>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，    在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </pre><pre><strong>示例 2：</strong><strong>输入：</strong>height = [4,2,0,3,2,5]<strong>输出：</strong>9</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>n == height.length</code></li>    <li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>    <li><code>0 &lt;= height[i] &lt;= 10<sup>5</sup></code></li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：左右指针"><a href="#参考代码：左右指针" class="headerlink" title="参考代码：左右指针"></a>参考代码：左右指针</h3><p>维护两个指针 <code>left</code> 和 <code>right</code>，以及两个变量 <code>leftMax</code> 和 <code>rightMax</code> ，初始时 <code>left = 0</code>、<code>right = n − 1</code> 。<code>leftMax</code> 维护区间 <code>[0, left)</code> 上的最大值，<code>rightMax</code> 维护区间 <code>(right, n-1]</code> 上的最大值。</p><ul><li>指针 <code>left</code> 只会向右移动，指针 <code>right</code> 只会向左移动：<ul><li><code>height[left] &lt; height[right]</code> ：左指针右移</li><li><code>height[left] &gt; height[right]</code> ：右指针左移</li></ul></li></ul><p><strong><font color="khahi">我们注意到：每次指针不动的那个位置就是当前遍历完所有数据的最大值。因此可以得出如下结论：</font></strong></p><ul><li><p>如果 <code>height[left] &lt; height[right]</code>，则必有 <code>leftMax &lt; rightMax</code>，下标 <code>left</code> 处能接的雨水量等于 <code>leftMax − height[left]</code>，将下标 <code>left</code> 处能接的雨水量加到能接的雨水总量，然后将左指针右移并更新 <code>leftMax</code>；</p></li><li><p>如果 <code>height[left] &gt;= height[right]</code>，则必有 <code>leftMax &gt;= rightMax</code>，下标<code>right</code> 处能接的雨水量等于 <code>rightMax − height[right]</code>，将下标 <code>right</code> 处能接的雨水量加到能接的雨水总量，然后将右指针左移并更新 <code>rightMax</code> 。</p></li></ul><p><strong>当两个指针相遇时，即可得到能接的雨水总量</strong></p><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">// leftMax 维护 [0, left) 中的最大值</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> leftMax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">// rightMax 维护 (right, n-1] 中的最大值</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> height<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rightMax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">// 最后一个位置 left == right 处是最高柱子的位置，不用计算了</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 此时已遍历的最高柱子在右端</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                leftMax <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftMax<span class="token punctuation">,</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">+=</span> leftMax <span class="token operator">-</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">// 此时已遍历的最高柱子在左端</span>                rightMax <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>rightMax<span class="token punctuation">,</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">+=</span> rightMax <span class="token operator">-</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 39 题：组合总和（中等）</title>
      <link href="/leetcode/39/"/>
      <url>/leetcode/39/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-39-题：组合总和"><a href="#「力扣」第-39-题：组合总和" class="headerlink" title="「力扣」第 39 题：组合总和"></a>「力扣」第 39 题：组合总和</h2><ul><li><a href="https://leetcode.cn/problems/combination-sum/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个 <strong>无重复元素</strong> 的整数数组&nbsp;<code>candidates</code> 和一个目标整数&nbsp;<code>target</code>&nbsp;，找出&nbsp;<code>candidates</code>&nbsp;中可以使数字和为目标数&nbsp;<code>target</code> 的所有&nbsp;<strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。&nbsp;</p><p>对于给定的输入，保证和为&nbsp;<code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p>&nbsp;</p><pre><strong>示例&nbsp;1：</strong><strong>输入：</strong>candidates = <span>[2,3,6,7], </span>target = <span>7</span><strong>输出：</strong>[[2,2,3],[7]]<strong>解释：</strong>2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。</pre><pre><strong>示例&nbsp;2：</strong><strong>输入: </strong>candidates = [2,3,5]<span>, </span>target = 8<strong>输出: </strong>[[2,2,2,2],[2,3,3],[3,5]]</pre><pre><strong>示例 3：</strong><strong>输入: </strong>candidates = <span>[2], </span>target = 1<strong>输出: </strong>[]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= candidates.length &lt;= 30</code></li>  <li><code>1 &lt;= candidates[i] &lt;= 200</code></li>  <li><code>candidate</code> 中的每个元素都 <strong>互不相同</strong></li>  <li><code>1 &lt;= target &lt;= 500</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：回溯"><a href="#参考代码：回溯" class="headerlink" title="参考代码：回溯"></a>参考代码：回溯</h3><p><strong><font color="purple">什么时候使用 <code>used</code> 数组，什么时候使用 <code>begin</code> 变量？</font></strong></p><ul><li><p><strong>排列问题，讲究顺序</strong>（即 [2, 2, 3] 与 [2, 3, 2] 视为不同列表时），需要记录哪些数字已经使用过，此时用 <code>used</code> 数组；</p></li><li><p><strong>组合问题，不讲究顺序</strong>（即 [2, 2, 3] 与 [2, 3, 2] 视为相同列表时），需要按照某种顺序搜索，此时使用 <code>begin</code> 变量。</p></li></ul><blockquote><p>时间复杂度：$O(n \times 2^n)$</p><p>空间复杂度：$O(target)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">combinationSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 排序，方便剪枝</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">backtrack</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">/**     * @param candidates 排好序的候选数组     * @param target     每减去一个元素，目标值变小     * @param begin      搜索起点     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span>                           <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> path<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 注意不能直接添加 path，这样最终添加的都是空集合（同一个索引）</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 剪枝（注意前提是已经排好序）</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">backtrack</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target <span class="token operator">-</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> path<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 回溯：状态重置</span>            path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 34 题：在排序数组中查找元素的第一个和最后一个位置（中等）</title>
      <link href="/leetcode/34/"/>
      <url>/leetcode/34/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-34-题：在排序数组中查找元素的第一个和最后一个位置"><a href="#「力扣」第-34-题：在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="「力扣」第 34 题：在排序数组中查找元素的第一个和最后一个位置"></a>「力扣」第 34 题：在排序数组中查找元素的第一个和最后一个位置</h2><ul><li><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回&nbsp;<code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为&nbsp;<code>O(log n)</code>&nbsp;的算法解决此问题。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [5,7,7,8,8,10], target = 8<strong>输出：</strong>[3,4]</pre><pre><strong>示例&nbsp;2：</strong><strong>输入：</strong>nums = [5,7,7,8,8,10], target = 6<strong>输出：</strong>[-1,-1]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>nums = [], target = 0<strong>输出：</strong>[-1,-1]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>    <li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code></li>    <li><code>nums</code>&nbsp;是一个非递减数组</li>    <li><code>-10<sup>9</sup>&nbsp;&lt;= target&nbsp;&lt;= 10<sup>9</sup></code></li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：二分查找"><a href="#参考代码：二分查找" class="headerlink" title="参考代码：二分查找"></a>参考代码：二分查找</h3><blockquote><p>时间复杂度：$O(logn)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">searchRange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> firstPosition <span class="token operator">=</span> <span class="token function">findFirstPosition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果一个都没匹配到，可以直接返回了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstPosition <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> lastPosition <span class="token operator">=</span> <span class="token function">findLastPosition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>firstPosition<span class="token punctuation">,</span> lastPosition<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findFirstPosition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 要找等于的第一个索引，即大于等于的第一个索引</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 向下取整</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">// 小于一定不是解</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 下一轮搜索区间是 [mid + 1, right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">// nums[mid] &gt;= target; 下一轮搜索区间是 [left, mid]</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token operator">?</span> left <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findLastPosition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 要找等于的最后一个索引，即小于等于的最后一个索引</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 向上取整</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">// 大于一定不是解</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 下一轮搜索区间是 [left, mid - 1]</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">// nums[mid] &lt;= target; 下一轮搜索区间是 [mid, right]</span>                left <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token operator">?</span> left <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 33 题：搜索旋转排序数组（中等）</title>
      <link href="/leetcode/33/"/>
      <url>/leetcode/33/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-33-题：搜索旋转排序数组"><a href="#「力扣」第-33-题：搜索旋转排序数组" class="headerlink" title="「力扣」第 33 题：搜索旋转排序数组"></a>「力扣」第 33 题：搜索旋转排序数组</h2><ul><li><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为&nbsp;<code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回&nbsp;<code>-1</code>&nbsp;。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [4,5,6,7,0,1,2], target = 0<strong>输出：</strong>4</pre><pre><strong>示例&nbsp;2：</strong><strong>输入：</strong>nums = [4,5,6,7,0,1,2], target = 3<strong>输出：</strong>-1</pre><pre><strong>示例 3：</strong><strong>输入：</strong>nums = [1], target = 0<strong>输出：</strong>-1</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= nums.length &lt;= 5000</code></li>    <li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>    <li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li>    <li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li>    <li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：二分查找"><a href="#参考代码：二分查找" class="headerlink" title="参考代码：二分查找"></a>参考代码：二分查找</h3><p><strong><font color="blue">将升序数组 <code>nums</code> 从任意位置进行旋转，不妨设数组区间为 <code>[left, right]</code> ，旋转位置索引为 <code>k</code> ，记 <code>mid </code> 为数组的中间位置索引。</font></strong></p><ul><li><code>k &lt; mid</code> ：即将有序数组 <strong>左边少于一半的数放入右边</strong> ，从而旋转后 <code>nums</code> 左半部分 <code>[left, mid]</code> 有序；</li><li><code>k &gt; mid</code> ：即将有序数组 <strong>左边多于一半的数放入右边</strong> ，从而旋转后 <code>nums</code> 右半部分 <code>[mid, rigth]</code> 有序；</li><li><code>k == mid</code> ，这里我们按照 <code>mid</code> 的划分（中点位置向下还是向上取整）不同有两种情况：<ul><li>若 <code>mid = (left + right) &gt;&gt; 1</code> ， 则 <code>nums</code> 左半部分 <code>[left, mid]</code> 有序；</li><li>若 <code>mid = (left + right + 1) &gt;&gt; 1</code> ， 则 <code>nums</code> 右半部分 <code>[mid, rigth]</code> 有序。</li></ul></li></ul><p><strong><font color="green">因此，有以下结论：</font></strong></p><ul><li>若旋转位置 <code>k != 0</code> ，则区间 <code>[left, mid]</code> 与 <code>[mid, right]</code> 有且仅有一个有序；</li><li>若旋转位置 <code>k == 0</code> ，则区间 <code>[left, mid]</code> 与 <code>[mid, right]</code> 都有序，即在 <code>[left, right]</code> 上升序。</li></ul><p><strong>怎么确定旋转后的数组 <code>nums</code> 是左边有序还是右边有序呢？</strong>其实对上面的分析过程进一步观察就能知道：</p><ul><li><code>nums</code> 的左半部分区间 <code>[left, mid]</code> 有序，等价于 <code>nums[left] &lt; nums[mid]</code></li><li><code>nums</code> 的右半部分区间 <code>[left, mid]</code> 有序，等价于 <code>nums[mid] &lt; nums[right]</code></li></ul><hr><p><strong><font color="red">我们对数组 <code>nums</code> 进行二分查找：</font></strong></p><ul><li>如果 <code>target</code> 的值位于有序的一半区间，则采用二分查找即可。</li><li>如果 <code>target</code> 的值位于无序的一半区间，我们注意到 <strong>此时这个无序的区间也可以看做到有序经过某个位置旋转得到</strong> ，故可继续二分。</li></ul><blockquote><p>时间复杂度：$O(logn)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 此时 [mid, right] 有序</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token operator">&amp;&amp;</span> target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 如果 target 的值落在有序区间 [mid, right]</span>                    left <span class="token operator">=</span> mid<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment">// 否则，下一轮搜索区间是 [left, mid-1]</span>                    right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">// 此时 [left, mid-1] 有序。</span>                <span class="token comment">// 但是为了和上一个 if 有同样的收缩行为，我们只认为 [left, mid-1] 有序</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token operator">&amp;&amp;</span> target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 如果 target 的值落在有序区间 [left, mid-1]</span>                    right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment">// 否则，下一轮搜索区间是 [mid, right]</span>                    left <span class="token operator">=</span> mid<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> left <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 32 题：最长有效括号（困难）</title>
      <link href="/leetcode/32/"/>
      <url>/leetcode/32/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-32-题：最长有效括号"><a href="#「力扣」第-32-题：最长有效括号" class="headerlink" title="「力扣」第 32 题：最长有效括号"></a>「力扣」第 32 题：最长有效括号</h2><ul><li><a href="https://leetcode.cn/problems/longest-valid-parentheses/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/20/">「力扣」第 20 题：有效的括号</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个只包含 <code>'('</code>&nbsp;和 <code>')'</code>&nbsp;的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>&nbsp;</p><pre><p><strong>示例 1：</strong><strong>输入：</strong>s = "(()"<strong>输出：</strong>2<strong>解释：</strong>最长有效括号子串是 "()"</p></pre><pre><strong>示例 2：</strong><strong>输入：</strong>s = ")()())"<strong>输出：</strong>4<strong>解释：</strong>最长有效括号子串是 "()()"</pre><pre><strong>示例 3：</strong><strong>输入：</strong>s = ""<strong>输出：</strong>0</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>0 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>  <li><code>s[i]</code> 为 <code>'('</code> 或 <code>')'</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：动态规划"><a href="#参考代码：动态规划" class="headerlink" title="参考代码：动态规划"></a>参考代码：动态规划</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestValidParentheses</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// dp[i] 表示以下标 i 字符结尾的最长有效括号的长度</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 有效的子串一定以 ')' 结尾</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 前一个字符是 '('，最长有效括号就是 dp[i-2] + 2</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token number">2</span> <span class="token operator">?</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 前一个字符是 ')'，则下标为 i-1-dp[i-1] 的字符必须是 '('</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span>                            <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">-</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 更新最长有效括号子串的长度</span>                res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 31 题：下一个排列（中等）</title>
      <link href="/leetcode/31/"/>
      <url>/leetcode/31/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-31-题：下一个排列"><a href="#「力扣」第-31-题：下一个排列" class="headerlink" title="「力扣」第 31 题：下一个排列"></a>「力扣」第 31 题：下一个排列</h2><ul><li><a href="https://leetcode.cn/problems/next-permutation/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>整数数组的一个 <strong>排列</strong>&nbsp; 就是将其所有成员以序列或线性顺序排列。</p><ul>  <li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li> </ul><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ul>  <li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>  <li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>  <li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li> </ul><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p><p>必须<strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank"> 原地 </a></strong>修改，只允许使用额外常数空间。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [1,2,3]<strong>输出：</strong>[1,3,2]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums = [3,2,1]<strong>输出：</strong>[1,2,3]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>nums = [1,1,5]<strong>输出：</strong>[1,5,1]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= nums.length &lt;= 100</code></li>  <li><code>0 &lt;= nums[i] &lt;= 100</code></li> </ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：双指针"><a href="#参考代码：双指针" class="headerlink" title="参考代码：双指针"></a>参考代码：双指针</h3><p><strong><font color="red">步骤：</font></strong></p><ul><li><p>先找出满足 <code>nums[i] &lt; nums[i+1]</code> 的最大索引 <code>i</code> ；</p><ul><li><strong><font color="purple">如果不存在，说明整个数组是递减序，翻转整个数组就是答案。</font></strong></li></ul></li><li><p>再找出满足 <code>nums[j] &gt; nums[i]</code> 的最大索引 <code>j</code> ；</p><ul><li>此时 <code>nums[i+1: ]</code> 是数组 <code>nums</code> 右端的 <strong>最长降序子串</strong> 。从而下一个排列应该是：<ul><li><code>i</code> 位置前面的数不变，将 <code>i</code> 位置的数稍微扩大一点点（在 <code>i</code> 位置右端找一个稍大于 <code>i</code> 位置的数，然后交换），然后 <code>i</code> 右端的数字典序逆序。</li></ul></li></ul></li><li><p>交换 <code>nums[i]</code> 和 <code>nums[j]</code>；</p></li><li><p>最后翻转 <code>nums[i+1:]</code>。</p></li></ul><p><strong><font color="green">一些细节的说明：</font></strong></p><ul><li>第二步查找满足条件的最大索引 <code>j</code> ，这个查找区间只需在 <code>i</code> 右端找即可，因为 <code>i+1</code> 位置的数是满足 <code>nums[i+1] &gt; nums[i]</code> 的。</li><li><code>i</code> 和 <code>j</code> 位置交换后，<code>nums[i+1: ]</code> 仍是 <code>nums</code> 右端的 <strong>降序子串</strong> ，只是可能不是 <strong>最长降序子串</strong> 了（<code>j=i+1</code>），故将 <code>i</code> 右端数字字典序逆序只需要反转即可。</li></ul><hr><p><strong><font color="blue">举例：<code>nums = [4, 5, 2, 6, 3, 1]</code></font></strong></p><ul><li><p>此时 <code>i = 2</code>，右端最长降序子串是 <code>[6,3,1]</code></p><ul><li>下一个排列应该是将 <code>i</code> 位置的数稍微扩大一点点，然后 <code>i</code> 右端的数字典序逆序。</li></ul></li><li><p>在 <code>[6,3,2]</code> 中找最右严格大于 2 的数，即 3。此时 <code>j = 4</code></p></li><li><p>交换 i 和 j 处元素，此时 <code>nums=[4,5,3,6,2,1]</code></p></li><li><p>此时 <code>nums[i+1: ] = [6,2,1]</code> 仍是 nums 右端的 <strong>降序子串</strong>，将其反转即可</p><ul><li><code>nums = [4, 5, 3, 1, 2, 6]</code></li></ul></li></ul><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">nextPermutation</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 先找出满足 nums[i] &lt; nums[i+1] 的最大索引 i</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            i<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment">// 如果不存在，就翻转整个数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// 再找出满足 nums[j] &gt; nums[i] 的最大索引 `j` ；</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 交换 nums[i] 和 nums[j]</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 最后翻转 nums[i+1:]</span>            <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">/**     * 将子串 nums[start:] 进行反转     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> start <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> start<span class="token operator">++</span><span class="token punctuation">,</span> end<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 23 题：合并K个升序链表（困难）</title>
      <link href="/leetcode/23/"/>
      <url>/leetcode/23/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-23-题：合并K个升序链表"><a href="#「力扣」第-23-题：合并K个升序链表" class="headerlink" title="「力扣」第 23 题：合并K个升序链表"></a>「力扣」第 23 题：合并K个升序链表</h2><ul><li><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/21/">「力扣」第 21 题：合并两个有序链表</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>lists = [[1,4,5],[1,3,4],[2,6]]<strong>输出：</strong>[1,1,2,3,4,4,5,6]<strong>解释：</strong>链表数组如下：[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</pre><pre><strong>示例 2：</strong><strong>输入：</strong>lists = []<strong>输出：</strong>[]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>lists = [[]]<strong>输出：</strong>[]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>k == lists.length</code></li>    <li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>    <li><code>0 &lt;= lists[i].length &lt;= 500</code></li>    <li><code>-10<sup>4</sup> &lt;= lists[i][j] &lt;= 10<sup>4</sup></code></li>    <li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>    <li><code>lists[i].length</code> 的总和不超过 <code>10<sup>4</sup></code></li></ul><p></p><p>&nbsp;</p><p><strong>链表结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：归并排序"><a href="#参考代码：归并排序" class="headerlink" title="参考代码：归并排序"></a>参考代码：归并排序</h3><blockquote><p>时间复杂度：$O(kn \times logk)$  <code>n=max(lists[i].length)</code></p><p>空间复杂度：$O(logk)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lists<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> lists<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token class-name">ListNode</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lists<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 只有一个有序链表，直接返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> lists<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> l1 <span class="token operator">=</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> l2 <span class="token operator">=</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>            <span class="token comment">// 「力扣」第 21 题：合并两个有序链表</span>    <span class="token keyword">private</span> <span class="token class-name">ListNode</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> list1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> list2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ListNode</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>                <span class="token comment">// 两者都不为空的时候，才有必要进行比较</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>list1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> list2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>list1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> list1<span class="token punctuation">;</span>                list1 <span class="token operator">=</span> list1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> list2<span class="token punctuation">;</span>                list2 <span class="token operator">=</span> list2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment">// 跳出循环时 list1 与 list2 有且仅有一条为空</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token punctuation">(</span>list1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> list2 <span class="token operator">:</span> list1<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 22 题：括号生成（中等）</title>
      <link href="/leetcode/22/"/>
      <url>/leetcode/22/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-22-题：括号生成"><a href="#「力扣」第-22-题：括号生成" class="headerlink" title="「力扣」第 22 题：括号生成"></a>「力扣」第 22 题：括号生成</h2><ul><li><a href="https://leetcode.cn/problems/generate-parentheses/">链表</a></li><li><a href="https://iiifox.github.io/leetcode/20/">「力扣」第 20 题：有效的括号</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>数字 <code>n</code>&nbsp;代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的 </strong>括号组合。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>n = 3<strong>输出：</strong>["((()))","(()())","(())()","()(())","()()()"]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>n = 1<strong>输出：</strong>["()"]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= n &lt;= 8</code></li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：回溯"><a href="#参考代码：回溯" class="headerlink" title="参考代码：回溯"></a>参考代码：回溯</h3><ul><li><strong>有效括号的定义如下：</strong><ul><li><p>任何一个位置处：<code>已使用的左括号数 &gt;= 已使用的右括号数</code> </p></li><li><p>结束位置处：<code>已使用的左括号数 == 已使用的右括号数 == n</code> </p></li></ul></li><li>为了减少一个参数 <code>n</code> 的传递，记括号对数为 <code>n</code> ，我们将其定义修改为剩余括号数：<ul><li>任何一个位置处：<code>剩余左括号数 &lt;= 剩余右括号数</code> </li><li>结束位置处：<code>剩余左括号数 == 剩余右括号数 == 0</code> </li></ul></li></ul><p><strong><font color="red">因此很容易可以发现：</font></strong></p><ul><li><strong>放左括号：</strong>只要还有可以使用的左括号就可以尝试放一个左括号</li><li><strong>放右括号：</strong>只有当剩余左括号数 <code>少于</code> 剩余右括号数，才能放一个右括号</li></ul><blockquote><p>时间复杂度：$O(\frac {4^n} {\sqrt{n}})$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">backtrack</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">/**     * @param left  还有几个左括号可以使用     * @param right 还有几个右括号可以使用     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span>                           <span class="token class-name">StringBuilder</span> path<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 左括号还可以使用，就尝试放一个左括号</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">backtrack</span><span class="token punctuation">(</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token char">'('</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>            path<span class="token punctuation">.</span><span class="token function">deleteCharAt</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 只有当剩余左括号数少于右括号数，才能放一个右括号</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">backtrack</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token char">')'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>            path<span class="token punctuation">.</span><span class="token function">deleteCharAt</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 卡塔兰数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 21 题：合并两个有序链表（简单）</title>
      <link href="/leetcode/21/"/>
      <url>/leetcode/21/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-21-题：合并两个有序链表"><a href="#「力扣」第-21-题：合并两个有序链表" class="headerlink" title="「力扣」第 21 题：合并两个有序链表"></a>「力扣」第 21 题：合并两个有序链表</h2><ul><li><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/23/">「力扣」第 23 题：合并K个升序链表</a></li><li><a href="https://iiifox.github.io/leetcode/148/">「力扣」第 148 题：排序链表</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&nbsp;</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/21/merge_ex1.jpg" style="width: 662px; height: 302px;"><strong>输入：</strong>l1 = [1,2,4], l2 = [1,3,4]<strong>输出：</strong>[1,1,2,3,4,4]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>l1 = [], l2 = []<strong>输出：</strong>[]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>l1 = [], l2 = [0]<strong>输出：</strong>[0]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li>两个链表的节点数目范围是 <code>[0, 50]</code></li>    <li><code>-100 &lt;= Node.val &lt;= 100</code></li>    <li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><p></p><p>&nbsp;</p><p><strong>链表结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：链表"><a href="#参考代码：链表" class="headerlink" title="参考代码：链表"></a>参考代码：链表</h3><p><strong><font color="blue">方法一：递归</font></strong></p><blockquote><p>时间复杂度：$O(m+n)$</p><p>空间复杂度：$O(m+n)$    <code>递归时栈空间</code></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> list1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> list2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>list1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> list2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>list2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> list1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>list1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            list1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> list2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> list1<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            list2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>list1<span class="token punctuation">,</span> list2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> list2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p><strong><font color="red">方法二：迭代</font></strong></p><blockquote><p>时间复杂度：$O(m+n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> list1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> list2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ListNode</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token comment">// 两者都不为空的时候，才有必要进行比较</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>list1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> list2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>list1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> list1<span class="token punctuation">;</span>                list1 <span class="token operator">=</span> list1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> list2<span class="token punctuation">;</span>                list2 <span class="token operator">=</span> list2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 进入循环是因为 list1 != null &amp;&amp; list2 != null</span>        <span class="token comment">// 从而跳出循环 list1 == null || list2 == null；</span>        <span class="token comment">// 而每一轮循环只有一条链表的长度会减一，</span>        <span class="token comment">// 故跳出循环时 list1 与 list2 不同时为空。</span>        <span class="token comment">// 从而跳出循环时 list1 与 list2 有且仅有一条为空</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token punctuation">(</span>list1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> list2 <span class="token operator">:</span> list1<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 20 题：有效的括号（简单）</title>
      <link href="/leetcode/20/"/>
      <url>/leetcode/20/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-20-题：有效的括号"><a href="#「力扣」第-20-题：有效的括号" class="headerlink" title="「力扣」第 20 题：有效的括号"></a>「力扣」第 20 题：有效的括号</h2><ul><li><a href="https://leetcode.cn/problems/valid-parentheses/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/32/">「力扣」第 32 题：最长有效括号</a></li><li><a href="https://iiifox.github.io/leetcode/301/">「力扣」第 301 题：删除无效的括号</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code>&nbsp;的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol>    <li>左括号必须用相同类型的右括号闭合。</li>    <li>左括号必须以正确的顺序闭合。</li></ol><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>s = "()"<strong>输出：</strong>true</pre><pre><strong>示例&nbsp;2：</strong><strong>输入：</strong>s = "()[]{}"<strong>输出：</strong>true</pre><pre><strong>示例&nbsp;3：</strong><strong>输入：</strong>s = "(]"<strong>输出：</strong>false</pre><pre><strong>示例&nbsp;4：</strong><strong>输入：</strong>s = "([)]"<strong>输出：</strong>false</pre><pre><strong>示例&nbsp;5：</strong><strong>输入：</strong>s = "{[]}"<strong>输出：</strong>true</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>    <li><code>s</code> 仅由括号 <code>'()[]{}'</code> 组成</li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：栈"><a href="#参考代码：栈" class="headerlink" title="参考代码：栈"></a>参考代码：栈</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 长度为奇数直接返回 false</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">switch</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">case</span> <span class="token char">'('</span><span class="token operator">:</span>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token char">')'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token char">'['</span><span class="token operator">:</span>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token char">']'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token char">'{'</span><span class="token operator">:</span>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token char">'}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">default</span><span class="token operator">:</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 19 题：删除链表的倒数第 N 个结点（中等）</title>
      <link href="/leetcode/19/"/>
      <url>/leetcode/19/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-19-题：删除链表的倒数第-N-个结点"><a href="#「力扣」第-19-题：删除链表的倒数第-N-个结点" class="headerlink" title="「力扣」第 19 题：删除链表的倒数第 N 个结点"></a>「力扣」第 19 题：删除链表的倒数第 N 个结点</h2><ul><li><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个链表，删除链表的倒数第&nbsp;<code>n</code><em>&nbsp;</em>个结点，并且返回链表的头结点。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/19/remove_ex1.jpg" style="width: 542px; height: 222px;"><strong>输入：</strong>head = [1,2,3,4,5], n = 2<strong>输出：</strong>[1,2,3,5]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>head = [1], n = 1<strong>输出：</strong>[]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>head = [1,2], n = 1<strong>输出：</strong>[1]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li>链表中结点的数目为 <code>sz</code></li>    <li><code>1 &lt;= sz &lt;= 30</code></li>    <li><code>0 &lt;= Node.val &lt;= 100</code></li>    <li><code>1 &lt;= n &lt;= sz</code></li></ul><p></p><p>&nbsp;</p><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><p>&nbsp;</p><p><strong>链表结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：双指针"><a href="#参考代码：双指针" class="headerlink" title="参考代码：双指针"></a>参考代码：双指针</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 设置虚拟头结点（常用技巧）</span>        <span class="token class-name">ListNode</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> first <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> second <span class="token operator">=</span> dummy<span class="token punctuation">;</span>                <span class="token comment">// first 指针先走 n + 1 步，后面一起移动的时候：</span>        <span class="token comment">// first 指针指向链表末尾 null，second 指针指向待删除结点的上一个节点</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            first <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            n<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            first <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            second <span class="token operator">=</span> second<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 此时，second 来到了待删除的结点的上一个结点</span>        second<span class="token punctuation">.</span>next <span class="token operator">=</span> second<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 17 题：电话号码的字母组合（中等）</title>
      <link href="/leetcode/17/"/>
      <url>/leetcode/17/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-17-题：电话号码的字母组合"><a href="#「力扣」第-17-题：电话号码的字母组合" class="headerlink" title="「力扣」第 17 题：电话号码的字母组合"></a>「力扣」第 17 题：电话号码的字母组合</h2><ul><li><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个仅包含数字&nbsp;<code>2-9</code>&nbsp;的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="../../images/leetcode/17/200px-telephone-keypad2svg.png" style="width: 200px;"></p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>digits = "23"<strong>输出：</strong>["ad","ae","af","bd","be","bf","cd","ce","cf"]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>digits = ""<strong>输出：</strong>[]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>digits = "2"<strong>输出：</strong>["a","b","c"]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>0 &lt;= digits.length &lt;= 4</code></li>    <li><code>digits[i]</code> 是范围 <code>['2', '9']</code> 的一个数字。</li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：回溯"><a href="#参考代码：回溯" class="headerlink" title="参考代码：回溯"></a>参考代码：回溯</h3><p><code>m</code> 是输入中对应 <code>3</code> 个字母的数字个数（包括数字 <code>2、3、4、5、6、8</code>），<code>n</code> 是输入中对应 <code>4</code> 个字母的数字个数（包括数字 <code>7、9</code>），<code>m + n</code> 是输入数字的总个数。</p><blockquote><p>时间复杂度：$O(3^m \times 4^n)$</p><p>空间复杂度：$O(m+n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">letterCombinations</span><span class="token punctuation">(</span><span class="token class-name">String</span> digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 0 &lt;= digits.length &lt;= 4。处理特殊用例 ""</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>digits<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment">// 在匿名内部类的代码块里将数据初始化</span>        <span class="token class-name">Map</span><span class="token operator">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> photoMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span>            <span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'2'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'b'</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'3'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token char">'d'</span><span class="token punctuation">,</span> <span class="token char">'e'</span><span class="token punctuation">,</span> <span class="token char">'f'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'4'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token char">'g'</span><span class="token punctuation">,</span> <span class="token char">'h'</span><span class="token punctuation">,</span> <span class="token char">'i'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'5'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token char">'j'</span><span class="token punctuation">,</span> <span class="token char">'k'</span><span class="token punctuation">,</span> <span class="token char">'l'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'6'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token char">'m'</span><span class="token punctuation">,</span> <span class="token char">'n'</span><span class="token punctuation">,</span> <span class="token char">'o'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'7'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token char">'p'</span><span class="token punctuation">,</span> <span class="token char">'q'</span><span class="token punctuation">,</span> <span class="token char">'r'</span><span class="token punctuation">,</span> <span class="token char">'s'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'8'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token char">'t'</span><span class="token punctuation">,</span> <span class="token char">'u'</span><span class="token punctuation">,</span> <span class="token char">'v'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'9'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token char">'w'</span><span class="token punctuation">,</span> <span class="token char">'x'</span><span class="token punctuation">,</span> <span class="token char">'y'</span><span class="token punctuation">,</span> <span class="token char">'z'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">backtrack</span><span class="token punctuation">(</span>photoMap<span class="token punctuation">,</span> digits<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token operator">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> photoMap<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> digitsArray<span class="token punctuation">,</span>                           <span class="token keyword">int</span> depth<span class="token punctuation">,</span> <span class="token class-name">StringBuilder</span> path<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">==</span> digitsArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> photoMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>digitsArray<span class="token punctuation">[</span>depth<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">backtrack</span><span class="token punctuation">(</span>photoMap<span class="token punctuation">,</span> digitsArray<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 回溯：状态重置</span>            path<span class="token punctuation">.</span><span class="token function">deleteCharAt</span><span class="token punctuation">(</span>depth<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 15 题：三数之和（中等）</title>
      <link href="/leetcode/15/"/>
      <url>/leetcode/15/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-15-题：三数之和"><a href="#「力扣」第-15-题：三数之和" class="headerlink" title="「力扣」第 15 题：三数之和"></a>「力扣」第 15 题：三数之和</h2><ul><li><a href="https://leetcode.cn/problems/3sum/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/1/">「力扣」第 1 题：两数之和</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个包含 <code>n</code> 个整数的数组&nbsp;<code>nums</code>，判断&nbsp;<code>nums</code>&nbsp;中是否存在三个元素 a，b，c ，使得&nbsp;a + b + c = 0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [-1,0,1,2,-1,-4]<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]</pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums = []<strong>输出：</strong>[]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>nums = [0]<strong>输出：</strong>[]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>0 &lt;= nums.length &lt;= 3000</code></li>    <li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：排序-左右指针"><a href="#参考代码：排序-左右指针" class="headerlink" title="参考代码：排序 + 左右指针"></a>参考代码：排序 + 左右指针</h3><p><strong><font color="blue">关于代码注释中的重复计入说明：</font></strong></p><ul><li>若数组 <code>nums = {-1, -1, -1, -1, -1, 2}</code> ，则只有唯一答案 <code>[-1, -1, 2]</code> 。</li></ul><p>即我们按照 <strong>升序</strong> 来返回结果的话，每两个连续相等的元素在答案列表中 <code>first</code> 位置只能出现一次，否则即重复计入了。同理，<code>second</code> 、<code>third</code> 位置也一样。</p><blockquote><p>时间复杂度：$O(n^2)$</p><p>空间复杂度：$O(logn)$    <code>空间复杂度主要是 sort 函数排序调用的栈空间，另外如果要求不改变 nums，则需要拷贝一份数组进行排序查找。其空间复杂度为 O(n)</code></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">threeSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 元素个数少于三个，直接返回。0 &lt;= nums.length &lt;= 3000</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 先进行排序，然后固定最小元素索引，后面两个元素可以用左右指针来搜索</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> first <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> first <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> first<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 第一个数就已经大于零，后面的不用看了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>first<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 保证第一个元素没有重复计入。在上一轮第一个元素已经计入过 first-1 位置</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>first<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>first <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> target <span class="token operator">=</span> <span class="token operator">-</span>nums<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> second <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> third <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">// 在升序数组 nums 区间 [i+1, nums.length-1] 中找不重复的两数和为 target</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>second <span class="token operator">&lt;</span> third<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>second<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>third<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// 符合要求，添加到 res 当中</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>second<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>third<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 保证第二、第三个元素没有重复计入。这里有点区别于 first 元素的是：</span>                    <span class="token comment">// 已找到。左右指针均需移动，因此 second+1 位置只有左指针能取</span>                    <span class="token comment">// 即：第一个元素去重是到达重复元素的位置进行去重；</span>                    <span class="token comment">//     而第二、三个元素则是将下一个位置去重</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>second <span class="token operator">&lt;</span> third <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>second <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>second<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        second<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>second <span class="token operator">&lt;</span> third <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>third <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>third<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        third<span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment">// 左右指针都要移动。查找下一对符合要求的索引</span>                    second<span class="token operator">++</span><span class="token punctuation">;</span>                    third<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 后面的数太大了，右指针左移</span>                    third<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment">// sum &lt; target。前面的数太小了，左指针右移</span>                    second<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 11 题：盛最多水的容器（中等）</title>
      <link href="/leetcode/11/"/>
      <url>/leetcode/11/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-11-题：盛最多水的容器"><a href="#「力扣」第-11-题：盛最多水的容器" class="headerlink" title="「力扣」第 11 题：盛最多水的容器"></a>「力扣」第 11 题：盛最多水的容器</h2><ul><li><a href="https://leetcode.cn/problems/container-with-most-water/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/42/">「力扣」第 42 题：接雨水</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 <code>n</code> 的整数数组&nbsp;<code>height</code>&nbsp;。有&nbsp;<code>n</code>&nbsp;条垂线，第 <code>i</code> 条线的两个端点是&nbsp;<code>(i, 0)</code>&nbsp;和&nbsp;<code>(i, height[i])</code>&nbsp;。</p><p>找出其中的两条线，使得它们与&nbsp;<code>x</code>&nbsp;轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/11/question_11.jpg"><strong>输入：</strong>[1,8,6,2,5,4,8,3,7]<strong>输出：</strong>49 <strong>解释：</strong>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。    在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为&nbsp;49。</pre><pre><strong>示例 2：</strong><strong>输入：</strong>height = [1,1]<strong>输出：</strong>1</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>n == height.length</code></li>    <li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>    <li><code>0 &lt;= height[i] &lt;= 10<sup>4</sup></code></li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：左右指针"><a href="#参考代码：左右指针" class="headerlink" title="参考代码：左右指针"></a>参考代码：左右指针</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 区间 [left, right] 表示盛水的宽度</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> height<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 盛水的高度为左右两边最短的那根木板</span>            res <span class="token operator">=</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token operator">?</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">*</span> height<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token operator">:</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">*</span> height<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p><strong><font color="red">代码优化（复杂度同上）：</font></strong></p><p>在上述代码中，指针每移动一次都需要对 <code>res</code> 进行计算更新，其实这是不太必要的。</p><p>记 <code>minHeight = min(nums[left], nums[right])</code> ：</p><ul><li>如果 <code>nums[left] &lt;= minHeight </code> ：我们可以考虑一次性 <strong>将左指针右移到不能继续右移为止</strong> 。即如果 <code>nums[left+1] &lt;= minHeight </code> ，此时盛水的宽度变小了的同时高度也没有增大，盛水的容量是不会大于当前的计算值的，可以进一步右移左指针，从而可以使用 <strong>循环</strong> 将左指针右移到不能继续右移为止。</li><li>同理，对于右指针也是如此。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 区间 [left, right] 表示盛水的宽度</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> height<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 盛水的高度为左右两边最短的那根木板</span>            <span class="token keyword">int</span> minHeight <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> minHeight <span class="token operator">*</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 考虑左指针右移</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> minHeight <span class="token operator">&amp;&amp;</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 考虑右指针左移</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> minHeight <span class="token operator">&amp;&amp;</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 10 题：正则表达式匹配（困难）</title>
      <link href="/leetcode/10/"/>
      <url>/leetcode/10/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-10-题：正则表达式匹配"><a href="#「力扣」第-10-题：正则表达式匹配" class="headerlink" title="「力扣」第 10 题：正则表达式匹配"></a>「力扣」第 10 题：正则表达式匹配</h2><ul><li><a href="https://leetcode.cn/problems/regular-expression-matching/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串&nbsp;<code>s</code>&nbsp;和一个字符规律&nbsp;<code>p</code>，请你来实现一个支持 <code>'.'</code>&nbsp;和&nbsp;<code>'*'</code>&nbsp;的正则表达式匹配。</p><ul>    <li><code>'.'</code> 匹配任意单个字符</li>    <li><code>'*'</code> 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖&nbsp;<strong>整个&nbsp;</strong>字符串&nbsp;<code>s</code>的，而不是部分字符串。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>s = "aa", p = "a"<strong>输出：</strong>false<strong>解释：</strong>"a" 无法匹配 "aa" 整个字符串。</pre><pre><strong>示例 2:</strong><strong>输入：</strong>s = "aa", p = "a*"<strong>输出：</strong>true<strong>解释：</strong>因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。    因此，字符串 "aa" 可被视为 'a' 重复了一次。</pre><pre><strong>示例&nbsp;3：</strong><strong>输入：</strong>s = "ab", p = ".*"<strong>输出：</strong>true<strong>解释：</strong>".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= s.length&nbsp;&lt;= 20</code></li>    <li><code>1 &lt;= p.length&nbsp;&lt;= 30</code></li>    <li><code>s</code>&nbsp;只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母。</li>    <li><code>p</code>&nbsp;只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母，以及字符&nbsp;<code>.</code>&nbsp;和&nbsp;<code>*</code>。</li>    <li>保证每次出现字符&nbsp;<code>*</code> 时，前面都匹配到有效的字符</li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：动态规划"><a href="#参考代码：动态规划" class="headerlink" title="参考代码：动态规划"></a>参考代码：动态规划</h3><blockquote><p>时间复杂度：$O(mn)$</p><p>空间复杂度：$O(mn)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">String</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 多开一行一列是为了保存边界条件，即字符长度为 0 的情况</span>        <span class="token comment">// 这一点在字符串的动态规划问题中比较常见</span>        <span class="token comment">// dp[i][j] 表示 s 的前 i 个字符与 p 中的前 j 个字符是否能够匹配</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// i 从 0 开始是让 '.*'、'a*' 等可以匹配 ''</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 以 ‘*’ 结尾，可以匹配前面字符零次或多次，即扔组合（不匹配）或扔字符</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// p 中的第 j-1 个字符与 s 的第 i 个字符相匹配</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">matches</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> p<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">// 注意：即使能够匹配，也有可能匹配零次。比如 s="a",p="aa*"</span>                        <span class="token comment">// 将该组合扔掉(匹配零次) or 将该字符扔掉</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">||</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token comment">// p 中的第 j-1 个字符与 s 的第 i 个字符不匹配。将该组合扔掉</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">matches</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> p<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// s 的第 i 个字符与 p 中的第 j 个字符匹配。看各自的前一个字符</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 剩下的情况: s 的第 i 个字符与 p 中的第 j 个字符都为小写字母且不相等</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">/**     * 判断 s 的第 i 个字符与 p 中的第 j 个字符是否相匹配     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">String</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'.'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 5 题：最长回文子串（中等）</title>
      <link href="/leetcode/5/"/>
      <url>/leetcode/5/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-5-题：最长回文子串"><a href="#「力扣」第-5-题：最长回文子串" class="headerlink" title="「力扣」第 5 题：最长回文子串"></a>「力扣」第 5 题：最长回文子串</h2><ul><li><a href="https://leetcode.cn/problems/longest-palindromic-substring/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/647/">「力扣」第 647 题：回文子串</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>s = "babad"<strong>输出：</strong>"bab"<strong>解释：</strong>"aba" 同样是符合题意的答案。</pre><pre><strong>示例 2：</strong><strong>输入：</strong>s = "cbbd"<strong>输出：</strong>"bb"</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= s.length &lt;= 1000</code></li>    <li><code>s</code> 仅由数字和英文字母组成</li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：Manacher-算法"><a href="#参考代码：Manacher-算法" class="headerlink" title="参考代码：Manacher 算法"></a>参考代码：Manacher 算法</h3><p>求最长回文字符串可以采用中心扩散的思想，即求位置 i 为中心的最长回文字符串（由位置 i 处向两端不断扩散，直至不满足回文字符串要求为止）。这里有一个问题，其回文字符串的长度可能是奇数也可能是偶数，偶数回文字符串的中心位置索引不存在。</p><p>为此我们可以通过一个特别地操作将最大回文字符串长度为奇偶数的情况统一起来：我们向字符串的头尾以及每两个字符中间添加一个特殊字符 <code>#</code> ，比如字符串 <code>aaba</code> 处理后会变成 <code>#a#a#b#a#</code> 。这样，其回文字符串的长度都将是奇数。</p><ul><li><strong>注意：</strong>这里的特殊字符不需要是没有出现过的字母。因为上述处理后，通过中心扩散，其特殊字符的比较对象不会是原字符串中的字符。</li></ul><p><strong>引入两个定义</strong></p><ul><li><code>回文直径</code>：回文字符串的长度。</li><li><code>回文半径</code>：回文字符串长度的一半（向上取整）。</li></ul><p>在中心扩散中，我们用一个数组 <code>p</code> 来进行记录：<code>p[i]</code> 表示以 <code>i</code> 为中心的最长回文子串的 <strong>回文半径</strong> 。</p><p><strong>Manacher 算法</strong> 是在中心扩散的思想上进行了一个优化，我们用一个变量 <code>right</code> 记录当前已经扩散到的最右边界位置的索引，其对应的回文串中心记为 <code>cneter</code> 、回文串左边界为 <code>left</code> 。当我们要求下一个位置 <code>i</code> 为中心的最长回文字符串时：</p><ul><li><code>i &lt; right</code> ：记 <code>i</code> 关于 <code>center</code> 的对称位置索引为 <code>j</code> ，由于区间 <code>[left, right]</code> 是 <code>center</code> 为中心的最长回文子串，因此有：<ul><li><code>j</code> 为中心的最长回文子串左边界大于 <code>left</code> ：<code>p[i] = p[j]</code></li><li><code>j</code> 为中心的最长回文子串左边界等于 <code>left</code> ：<code>p[i] &gt;= right - i + 1</code></li><li><code>j</code> 为中心的最长回文子串左边界小于 <code>left</code> ：<code>p[i] = right - i + 1</code></li></ul></li><li><code>i &gt;= right</code> 直接中心扩散</li></ul><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 添加特殊字符 '#' 的字符数组（该字符可以与原字符串中字符一样）</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> wrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> wrap<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            wrap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token char">'#'</span> <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// p[i] 表示以 wrap[i] 为中心最长回文串的回文半径</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>wrap<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 已经遍历的所有回文子串的最右边下标，其对应的最左下标为 left</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// right 所属回文子串中心下标</span>        <span class="token keyword">int</span> center <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 已经遍历过的最长回文子串中心下标</span>        <span class="token keyword">int</span> resCenter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> wrap<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 子串 [left, right] 中 i 关于其中心的对称位置</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>center <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> i<span class="token punctuation">;</span>                temp <span class="token operator">=</span> right <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// j 为中心的最长回文串左边界不等于 left，可以直接确定 p[i]</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">// temp = 1               (i &gt;= right)</span>            <span class="token comment">// temp = right - i - 1   (i &lt; right &amp;&amp; p[j] != temp)</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> temp <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">+</span> temp <span class="token operator">&lt;</span> wrap<span class="token punctuation">.</span>length                    <span class="token operator">&amp;&amp;</span> wrap<span class="token punctuation">[</span>i <span class="token operator">-</span> temp<span class="token punctuation">]</span> <span class="token operator">==</span> wrap<span class="token punctuation">[</span>i <span class="token operator">+</span> temp<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                temp<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                            <span class="token comment">// 执行到此，i 为中心的最长回文串右边界必然不会小于 right。更新最右边界。</span>            right <span class="token operator">=</span> i <span class="token operator">+</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            center <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token comment">// 判断是否需要更新最长回文串的中心位置</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> p<span class="token punctuation">[</span>resCenter<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                resCenter <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">// 计算最长回文串的长度和开始的位置</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token punctuation">(</span>resCenter <span class="token operator">-</span> p<span class="token punctuation">[</span>resCenter<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 截取最长回文子串</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> start <span class="token operator">+</span> p<span class="token punctuation">[</span>resCenter<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Manacher 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 4 题：寻找两个正序数组的中位数（困难）</title>
      <link href="/leetcode/4/"/>
      <url>/leetcode/4/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-4-题：寻找两个正序数组的中位数"><a href="#「力扣」第-4-题：寻找两个正序数组的中位数" class="headerlink" title="「力扣」第 4 题：寻找两个正序数组的中位数"></a>「力扣」第 4 题：寻找两个正序数组的中位数</h2><ul><li><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums1 = [1,3], nums2 = [2]<strong>输出：</strong>2.00000<strong>解释：</strong>合并数组 = [1,2,3] ，中位数 2</pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums1 = [1,2], nums2 = [3,4]<strong>输出：</strong>2.50000<strong>解释：</strong>合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>nums1.length == m</code></li>    <li><code>nums2.length == n</code></li>    <li><code>0 &lt;= m &lt;= 1000</code></li>    <li><code>0 &lt;= n &lt;= 1000</code></li>    <li><code>1 &lt;= m + n &lt;= 2000</code></li>    <li><code>-10<sup>6</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>6</sup></code></li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：二分查找"><a href="#参考代码：二分查找" class="headerlink" title="参考代码：二分查找"></a>参考代码：二分查找</h3><p><img src="../../images/leetcode/4/%E9%A2%98%E8%A7%A3.png"></p><p><strong><font color="red">有以下性质：</font></strong></p><ul><li>m + n 为奇数：size(左) = size(右) + 1，中位数即 <strong>红线左边最大值</strong></li><li>m + n 为偶数：中位数即 <strong>红线左边最大值与右边最小值的均值</strong></li></ul><p><strong><font color="blue">我们记：</font></strong></p><ul><li>数组 <code>nums1</code> 在红线右边的第 1 个数的索引为 <code>i</code></li><li>数组 <code>nums2</code> 在红线右边的第 1 个数的索引为 <code>j</code></li></ul><p>此时恒有 <code>size(左) = i + j = (m + n + 1) &gt;&gt;&gt; 1</code></p><p><strong><font color="purple">此时问题转化为在区间 [0, m] 中寻找索引 i，使得条件①和②成立</font></strong></p><blockquote><p>时间复杂度：$O(log(min(m,n)))$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 为了让搜索范围更小，我们始终让 num1 是那个更短的数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> nums1<span class="token punctuation">;</span>            nums1 <span class="token operator">=</span> nums2<span class="token punctuation">;</span>            nums2 <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 上述交换保证了 m &lt;= n，在更短的区间 [0, m] 中搜索，会更快一些</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">// 使用二分查找在区间 [left, right] 中寻找索引 i，使得条件①和②成立</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> m<span class="token punctuation">;</span>        <span class="token comment">// size(左)。可通过该数求得 j = totalLeft - i;</span>        <span class="token keyword">int</span> totalLeft <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 注意这里，left &lt; right ，故均值向下取整后 &lt; right &lt;= m ，即索引不会越界</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> totalLeft <span class="token operator">-</span> i<span class="token punctuation">;</span>            <span class="token comment">// nums2 左边的最大值比 nums1 右边的最小值要大，说明 i 需要扩大</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">// 左边的最大值小于等于 nums1 右边的最小值，因此 i 不需要扩大</span>                right <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">// 退出循环时的 i = (left = right) 即为满足条件①和②的 i</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> totalLeft <span class="token operator">-</span> i<span class="token punctuation">;</span>        <span class="token comment">// 边界情况需要特殊考虑</span>        <span class="token keyword">int</span> nums1LeftMax <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE <span class="token operator">:</span> nums1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> nums1RightMin <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> nums2LeftMax <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE <span class="token operator">:</span> nums2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> nums2RightMin <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>nums1LeftMax<span class="token punctuation">,</span> nums2LeftMax<span class="token punctuation">)</span>                <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>nums1LeftMax<span class="token punctuation">,</span> nums2LeftMax<span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>nums1RightMin<span class="token punctuation">,</span> nums2RightMin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 3 题：无重复字符的最长子串（中等）</title>
      <link href="/leetcode/3/"/>
      <url>/leetcode/3/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-3-题：无重复字符的最长子串"><a href="#「力扣」第-3-题：无重复字符的最长子串" class="headerlink" title="「力扣」第 3 题：无重复字符的最长子串"></a>「力扣」第 3 题：无重复字符的最长子串</h2><ul><li><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的&nbsp;<strong>最长子串&nbsp;</strong>的长度。</p><p>&nbsp;</p><pre><strong>示例&nbsp;1:</strong><strong>输入: </strong>s = "abcabcbb"<strong>输出: </strong>3 <strong>解释:</strong> 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</pre><pre><strong>示例 2:</strong><strong>输入: </strong>s = "bbbbb"<strong>输出: </strong>1<strong>解释: </strong>因为无重复字符的最长子串是 "b"，所以其长度为 1。</pre><pre><strong>示例 3:</strong><strong>输入: </strong>s = "pwwkew"<strong>输出: </strong>3<strong>解释: </strong>因为无重复字符的最长子串是&nbsp;"wke"，所以其长度为 3。&nbsp;    请注意，你的答案必须是 <strong>子串 </strong>的长度，"pwke"&nbsp;是一个子序列，不是子串。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>    <li><code>s</code>&nbsp;由英文字母、数字、符号和空格组成</li></ul><p></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：左右指针"><a href="#参考代码：左右指针" class="headerlink" title="参考代码：左右指针"></a>参考代码：左右指针</h3><p><strong><font color="red">关于复杂度中出现常数的一些说明：</font></strong></p><ul><li>常数表示字符集中字符的个数，故没有将常数省略</li></ul><p><strong><font color="blue">滑动窗口类题目的一些优化技巧：</font></strong></p><ul><li>在滑动窗口一类题中往往会开辟一个窗口数组。对于本题是可以用哈希表来代替窗口数组的，但哈希表的效率是会低于数组检索效率的，故并没有使用哈希表的方式。</li><li>对于字符串中字符的遍历，由于 <code>Java</code> 中字符串的 <code>charAt()</code> 方法每次都会检查下标是否越界，对于长字符串这会降低其性能，故一般会先将字符串转成字符数组，通过数组的检索来提高运行效率。</li></ul><blockquote><p>时间复杂度：$O(n + 128)$    <code>若使用哈希表而不采用窗口数组，则时间复杂度为 O(n)</code></p><p>空间复杂度：$O(n + 128)$    <code>若不使用字符串转字符数组，则空间复杂度为 O(128)</code></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">// windows[i] 存储的是 chars 中字符值为 i 的最新索引</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> window <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// s.charAt(i) 操作会去检查下标是否越界，故将字符串转换成字符数组</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// chars 在 [left, right] 中没有重复元素</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> right<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 字符值为 chars[right] 在前面出现过了，</span>            <span class="token comment">// 前一次出现的索引是否在 [left, right] 中决定是否进行窗口滑动</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">[</span>chars<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> window<span class="token punctuation">[</span>chars<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 更新一下字符值为 chars[right] 的最新索引</span>            window<span class="token punctuation">[</span>chars<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">;</span>            <span class="token comment">// 计算 [left, right] 区间长度，决定是否更新 res</span>            res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 2 题：两数相加（中等）</title>
      <link href="/leetcode/2/"/>
      <url>/leetcode/2/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-2-题：两数相加"><a href="#「力扣」第-2-题：两数相加" class="headerlink" title="「力扣」第 2 题：两数相加"></a>「力扣」<strong>第</strong> 2 题：两数相加</h2><ul><li><a href="https://leetcode.cn/problems/add-two-numbers/">链接</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个&nbsp;<strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照&nbsp;<strong>逆序</strong>&nbsp;的方式存储的，并且每个节点只能存储&nbsp;<strong>一位</strong>&nbsp;数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0&nbsp;开头。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><img alt="" src="../../images/leetcode/2/addtwonumber1.jpg" style="width: 483px; height: 342px;"><strong>输入：</strong>l1 = [2,4,3], l2 = [5,6,4]<strong>输出：</strong>[7,0,8]<strong>解释：</strong>342 + 465 = 807.</pre><pre><strong>示例 2：</strong><strong>输入：</strong>l1 = [0], l2 = [0]<strong>输出：</strong>[0]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<strong>输出：</strong>[8,9,9,9,0,0,0,1]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>    <li><code>0 &lt;= Node.val &lt;= 9</code></li>    <li>题目数据保证列表表示的数字不含前导零</li></ul><p></p><p>&nbsp;</p><p><strong>链表结点定义</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：链表"><a href="#参考代码：链表" class="headerlink" title="参考代码：链表"></a>参考代码：链表</h3><blockquote><p>时间复杂度：$O(max(m,n))$</p><p>空间复杂度：$O(1)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> l1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 设置虚拟头结点（常用技巧）</span>        <span class="token class-name">ListNode</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token comment">// 两个链表有一个非空，求和就不会终止</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> l2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum <span class="token operator">+=</span> l1<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum <span class="token operator">+=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sum <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment">// 最后可能会进位，注意判断</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 1 题：两数之和（简单）</title>
      <link href="/leetcode/1/"/>
      <url>/leetcode/1/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-1-题：两数之和"><a href="#「力扣」第-1-题：两数之和" class="headerlink" title="「力扣」第 1 题：两数之和"></a>「力扣」第 1 题：两数之和</h2><ul><li><a href="https://leetcode.cn/problems/two-sum/">链接</a></li><li><a href="https://iiifox.github.io/leetcode/15/">「力扣」第 15 题：三数之和</a></li><li><a href="https://iiifox.github.io/leetcode/560/">「力扣」第 560 题：和为 K 的子数组</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 <code>nums</code>&nbsp;和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值 </strong><code>target</code>&nbsp; 的那&nbsp;<strong>两个</strong>&nbsp;整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>&nbsp;</p><pre><strong>示例 1：</strong><strong>输入：</strong>nums = [2,7,11,15], target = 9<strong>输出：</strong>[0,1]<strong>解释：</strong>因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</pre><pre><strong>示例 2：</strong><strong>输入：</strong>nums = [3,2,4], target = 6<strong>输出：</strong>[1,2]</pre><pre><strong>示例 3：</strong><strong>输入：</strong>nums = [3,3], target = 6<strong>输出：</strong>[0,1]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>    <li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>    <li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>    <li><strong>只会存在一个有效答案</strong></li></ul><p></p><p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n<sup>2</sup>)</code> 的算法吗？</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="参考代码：哈希表"><a href="#参考代码：哈希表" class="headerlink" title="参考代码：哈希表"></a>参考代码：哈希表</h3><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 以数组元素为键，数组元素索引为值</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"No two sum solution"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode 热题 HOT 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
